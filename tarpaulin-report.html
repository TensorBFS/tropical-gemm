<!doctype html>
<html>
<head>
    <meta charset="utf-8">
    <style>:root {
  --color: black;
  --bg: white;
  --head-bg: white;
  --link: #338;

  --blue: #ccf;
  --red: #fcc;
  --yellow: #ffc;
  --green: #cfc;
}

[data-theme='dark'] {
  --color: white;
  --bg: black;
  --head-bg: #333;
  --link: #aaf;

  --blue: #225;
  --red: #522;
  --yellow: #552;
  --green: #252;
}

html,
body {
  margin: 0;
  padding: 0;
  color: var(--color);
  background: var(--bg);
}

.app {
  margin: 10px;
  padding: 0;
}

.files-list {
  margin: 10px 0 0;
  width: 100%;
  border-collapse: collapse;
}
.files-list__head {
  border: 1px solid #999;
}
.files-list__head > tr > th {
  padding: 10px;
  border: 1px solid #999;
  text-align: left;
  font-weight: normal;
  background: var(--head-bg);
}
.files-list__body {
}
.files-list__file {
  cursor: pointer;
}
.files-list__file:hover {
  background: var(--blue);
}
.files-list__file > td {
  padding: 10px;
  border: 1px solid #999;
}
.files-list__file > td:first-child::before {
  content: '\01F4C4';
  margin-right: 1em;
}
.files-list__file_low {
  background: var(--red);
}
.files-list__file_medium {
  background: var(--yellow);
}
.files-list__file_high {
  background: var(--green);
}
.files-list__file_folder > td:first-child::before {
  content: '\01F4C1';
  margin-right: 1em;
}

.file-header {
  border: 1px solid #999;
  display: flex;
  justify-content: space-between;
  align-items: center;
  position: sticky;
  top: 0;
  background: var(--bg);
}

.file-header__back {
  margin: 10px;
  cursor: pointer;
  flex-shrink: 0;
  flex-grow: 0;
  text-decoration: underline;
  color: var(--link);
}

.file-header__name {
  margin: 10px;
  flex-shrink: 2;
  flex-grow: 2;
}

.file-header__stat {
  margin: 10px;
  flex-shrink: 0;
  flex-grow: 0;
}

.file-content {
  margin: 10px 0 0;
  border: 1px solid #999;
  padding: 10px;
  counter-reset: line;
  display: flex;
  flex-direction: column;
}

.code-line::before {
  content: counter(line);
  margin-right: 72px;
}
.code-line {
  margin: 0;
  height: 1em;
  counter-increment: line;

  position: absolute;
  padding: 0 0.3em 0.3em 0.3em;
  display: inherit;
  width: 100%;
}
.code-line_covered {
  background: var(--green);
}
.code-line_uncovered {
  background: var(--red);
}

.code-text-container {
  position: relative;
  height: 1em;
  padding: 0.3em 0;
}

.cover-indicator {
  display: flex;
  width: 100%;
  position: absolute;
  justify-content: end;
  height: 1em;
  align-items: center;
  padding: 0 0.3em 0.3em 0.3em;
}

.cover-indicator.check-cover::after {
  content: "\2713";
  font-weight: bold;
  background-color: var(--green);
  height: 1em;
}

.cover-indicator.no-cover::after {
  content: "\2716";
  font-weight: bold;
  background-color: var(--red);
  height: 1em;
}

.stat-line-hit {
  max-width: 48px;
  overflow: hidden;
  font-weight: bold;
  margin-right: 4px;
  background-color: var(--green);
  position: relative;
  top: 0.1em;
}

#theme-toggle-label {
  margin-left: 1ch;
}
</style>
</head>
<body>
    <div id="root"></div>
    <script>
        var data = {"files":[{"path":["/","home","leo","rcode","cutropicalgemm","crates","tropical-gemm","benches","gemm_bench.rs"],"content":"use criterion::{black_box, criterion_group, criterion_main, BenchmarkId, Criterion, Throughput};\nuse tropical_gemm::prelude::*;\n\nfn bench_tropical_gemm_f32(c: \u0026mut Criterion) {\n    let mut group = c.benchmark_group(\"TropicalGemm_f32\");\n    group.sample_size(20);\n\n    // Matrix sizes to benchmark (matching Julia comparison)\n    for size in [128, 256, 512, 1024, 2048, 4096].iter() {\n        let n = *size;\n        let elements = (n * n) as u64;\n\n        // Create test matrices\n        let a: Vec\u003cf32\u003e = (0..n * n).map(|i| ((i % 1000) as f32) * 0.01).collect();\n        let b: Vec\u003cf32\u003e = (0..n * n)\n            .map(|i| (((i + 500) % 1000) as f32) * 0.01)\n            .collect();\n\n        group.throughput(Throughput::Elements(elements * 2)); // 2 matrices read\n\n        group.bench_with_input(BenchmarkId::new(\"MaxPlus\", n), \u0026n, |bench, \u0026n| {\n            bench.iter(|| black_box(tropical_matmul::\u003cTropicalMaxPlus\u003cf32\u003e\u003e(\u0026a, n, n, \u0026b, n)));\n        });\n\n        group.bench_with_input(BenchmarkId::new(\"MinPlus\", n), \u0026n, |bench, \u0026n| {\n            bench.iter(|| black_box(tropical_matmul::\u003cTropicalMinPlus\u003cf32\u003e\u003e(\u0026a, n, n, \u0026b, n)));\n        });\n\n        group.bench_with_input(BenchmarkId::new(\"MaxMul\", n), \u0026n, |bench, \u0026n| {\n            bench.iter(|| black_box(tropical_matmul::\u003cTropicalMaxMul\u003cf32\u003e\u003e(\u0026a, n, n, \u0026b, n)));\n        });\n    }\n\n    group.finish();\n}\n\nfn bench_tropical_gemm_f64(c: \u0026mut Criterion) {\n    let mut group = c.benchmark_group(\"TropicalGemm_f64\");\n    group.sample_size(20);\n\n    for size in [128, 256, 512, 1024, 2048].iter() {\n        let n = *size;\n        let elements = (n * n) as u64;\n\n        let a: Vec\u003cf64\u003e = (0..n * n).map(|i| ((i % 1000) as f64) * 0.01).collect();\n        let b: Vec\u003cf64\u003e = (0..n * n)\n            .map(|i| (((i + 500) % 1000) as f64) * 0.01)\n            .collect();\n\n        group.throughput(Throughput::Elements(elements * 2));\n\n        group.bench_with_input(BenchmarkId::new(\"MaxPlus\", n), \u0026n, |bench, \u0026n| {\n            bench.iter(|| black_box(tropical_matmul::\u003cTropicalMaxPlus\u003cf64\u003e\u003e(\u0026a, n, n, \u0026b, n)));\n        });\n    }\n\n    group.finish();\n}\n\nfn bench_with_argmax(c: \u0026mut Criterion) {\n    let mut group = c.benchmark_group(\"TropicalGemm_Argmax\");\n    group.sample_size(20);\n\n    for size in [128, 256, 512, 1024].iter() {\n        let n = *size;\n        let a: Vec\u003cf64\u003e = (0..n * n).map(|i| ((i % 100) as f64) * 0.1).collect();\n        let b: Vec\u003cf64\u003e = (0..n * n)\n            .map(|i| (((i + 50) % 100) as f64) * 0.1)\n            .collect();\n\n        group.bench_with_input(\n            BenchmarkId::new(\"MaxPlus_with_argmax\", n),\n            \u0026n,\n            |bench, \u0026n| {\n                bench.iter(|| {\n                    black_box(tropical_matmul_with_argmax::\u003cTropicalMaxPlus\u003cf64\u003e\u003e(\n                        \u0026a, n, n, \u0026b, n,\n                    ))\n                });\n            },\n        );\n    }\n\n    group.finish();\n}\n\n/// Quick benchmark for command-line timing comparison\nfn bench_quick(c: \u0026mut Criterion) {\n    let mut group = c.benchmark_group(\"Quick\");\n    group.sample_size(10);\n\n    // Standard comparison sizes\n    for size in [1024, 2048, 4096].iter() {\n        let n = *size;\n        let a: Vec\u003cf32\u003e = (0..n * n).map(|i| ((i % 1000) as f32) * 0.01).collect();\n        let b: Vec\u003cf32\u003e = (0..n * n)\n            .map(|i| (((i + 500) % 1000) as f32) * 0.01)\n            .collect();\n\n        group.bench_with_input(BenchmarkId::new(\"MaxPlus_f32\", n), \u0026n, |bench, \u0026n| {\n            bench.iter(|| black_box(tropical_matmul::\u003cTropicalMaxPlus\u003cf32\u003e\u003e(\u0026a, n, n, \u0026b, n)));\n        });\n    }\n\n    group.finish();\n}\n\ncriterion_group!(\n    benches,\n    bench_tropical_gemm_f32,\n    bench_tropical_gemm_f64,\n    bench_with_argmax,\n    bench_quick\n);\ncriterion_main!(benches);\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","leo","rcode","cutropicalgemm","crates","tropical-gemm","examples","basic.rs"],"content":"//! Basic example of tropical matrix multiplication.\n\nuse tropical_gemm::prelude::*;\n\nfn main() {\n    println!(\"Tropical GEMM - Basic Example\\n\");\n    println!(\"{}\\n\", tropical_gemm::version_info());\n\n    // Create two 3x3 matrices\n    // A represents edge weights in a graph (rows = from, cols = to)\n    // We'll use TropicalMaxPlus for longest path computation\n    let a = vec![\n        0.0f64, 1.0, 3.0, // from node 0\n        2.0, 0.0, 1.0, // from node 1\n        1.0, 2.0, 0.0, // from node 2\n    ];\n\n    let b = vec![\n        0.0f64, 2.0, 1.0, // from node 0\n        1.0, 0.0, 3.0, // from node 1\n        2.0, 1.0, 0.0, // from node 2\n    ];\n\n    println!(\"Matrix A (3x3):\");\n    print_matrix(\u0026a, 3, 3);\n\n    println!(\"\\nMatrix B (3x3):\");\n    print_matrix(\u0026b, 3, 3);\n\n    // Compute C = A ⊗ B using TropicalMaxPlus\n    // C[i,j] = max_k(A[i,k] + B[k,j])\n    // This gives the maximum 2-hop path weight from i to j\n    let c = tropical_matmul::\u003cTropicalMaxPlus\u003cf64\u003e\u003e(\u0026a, 3, 3, \u0026b, 3);\n\n    println!(\"\\nResult C = A ⊗ B (TropicalMaxPlus - longest 2-hop paths):\");\n    let c_values: Vec\u003cf64\u003e = c.iter().map(|x| x.value()).collect();\n    print_matrix(\u0026c_values, 3, 3);\n\n    // Now with argmax tracking\n    println!(\"\\n--- With Argmax Tracking ---\\n\");\n\n    let result = tropical_matmul_with_argmax::\u003cTropicalMaxPlus\u003cf64\u003e\u003e(\u0026a, 3, 3, \u0026b, 3);\n\n    println!(\"Longest 2-hop path analysis:\");\n    for i in 0..3 {\n        for j in 0..3 {\n            let value = result.get(i, j).value();\n            let via = result.get_argmax(i, j);\n            println!(\"  {} -\u003e {} via {}: total weight = {:.1}\", i, j, via, value);\n        }\n    }\n\n    // MinPlus example for shortest paths\n    println!(\"\\n--- Shortest Paths (TropicalMinPlus) ---\\n\");\n\n    // Use large values instead of infinity for cleaner output\n    let dist = vec![\n        0.0f64, 1.0, 5.0, // distances from node 0\n        2.0, 0.0, 1.0, // distances from node 1\n        4.0, 3.0, 0.0, // distances from node 2\n    ];\n\n    println!(\"Distance matrix:\");\n    print_matrix(\u0026dist, 3, 3);\n\n    let shortest = tropical_matmul::\u003cTropicalMinPlus\u003cf64\u003e\u003e(\u0026dist, 3, 3, \u0026dist, 3);\n    let shortest_values: Vec\u003cf64\u003e = shortest.iter().map(|x| x.value()).collect();\n\n    println!(\"\\nShortest 2-hop distances:\");\n    print_matrix(\u0026shortest_values, 3, 3);\n\n    // AndOr example for reachability\n    println!(\"\\n--- Graph Reachability (TropicalAndOr) ---\\n\");\n\n    let adj = [\n        false, true, false, // node 0 connects to 1\n        false, false, true, // node 1 connects to 2\n        true, false, false, // node 2 connects to 0\n    ];\n\n    println!(\"Adjacency matrix:\");\n    for i in 0..3 {\n        print!(\"  \");\n        for j in 0..3 {\n            print!(\"{} \", if adj[i * 3 + j] { \"1\" } else { \"0\" });\n        }\n        println!();\n    }\n\n    let adj_tropical: Vec\u003cTropicalAndOr\u003e = adj.iter().map(|\u0026b| TropicalAndOr::new(b)).collect();\n    let mut reach = adj_tropical.clone();\n\n    // Manual 2-hop reachability (since AndOr doesn't implement KernelDispatch for matmul)\n    // This is a simplified example\n    for i in 0..3 {\n        for j in 0..3 {\n            let mut can_reach = adj_tropical[i * 3 + j];\n            for k in 0..3 {\n                can_reach = can_reach\n                    .tropical_add(adj_tropical[i * 3 + k].tropical_mul(adj_tropical[k * 3 + j]));\n            }\n            reach[i * 3 + j] = can_reach;\n        }\n    }\n\n    println!(\"\\n2-hop reachability:\");\n    for i in 0..3 {\n        print!(\"  \");\n        for j in 0..3 {\n            print!(\"{} \", if reach[i * 3 + j].value() { \"1\" } else { \"0\" });\n        }\n        println!();\n    }\n\n    println!(\"\\nDone!\");\n}\n\nfn print_matrix(data: \u0026[f64], rows: usize, cols: usize) {\n    for i in 0..rows {\n        print!(\"  \");\n        for j in 0..cols {\n            print!(\"{:6.1} \", data[i * cols + j]);\n        }\n        println!();\n    }\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","leo","rcode","cutropicalgemm","crates","tropical-gemm","examples","bench_rust.rs"],"content":"//! Quick benchmark for comparison with Julia/CUDA\n//!\n//! Run with: cargo run --release --example bench_rust\n\nuse std::time::Instant;\nuse tropical_gemm::prelude::*;\n\nconst SIZES: \u0026[usize] = \u0026[128, 256, 512, 1024, 2048, 4096];\nconst WARMUP_ITERS: usize = 3;\nconst BENCH_ITERS: usize = 10;\n\nfn bench_maxplus_f32(n: usize) -\u003e (f64, f64) {\n    let a: Vec\u003cf32\u003e = (0..n * n).map(|i| ((i % 1000) as f32) * 0.01).collect();\n    let b: Vec\u003cf32\u003e = (0..n * n)\n        .map(|i| (((i + 500) % 1000) as f32) * 0.01)\n        .collect();\n\n    // Warmup\n    for _ in 0..WARMUP_ITERS {\n        let _ = tropical_matmul::\u003cTropicalMaxPlus\u003cf32\u003e\u003e(\u0026a, n, n, \u0026b, n);\n    }\n\n    // Benchmark\n    let mut times = Vec::with_capacity(BENCH_ITERS);\n    for _ in 0..BENCH_ITERS {\n        let start = Instant::now();\n        let _ = tropical_matmul::\u003cTropicalMaxPlus\u003cf32\u003e\u003e(\u0026a, n, n, \u0026b, n);\n        times.push(start.elapsed().as_secs_f64());\n    }\n\n    times.sort_by(|a, b| a.partial_cmp(b).unwrap());\n    (times[times.len() / 2], times[0])\n}\n\nfn bench_maxplus_f64(n: usize) -\u003e (f64, f64) {\n    let a: Vec\u003cf64\u003e = (0..n * n).map(|i| ((i % 1000) as f64) * 0.01).collect();\n    let b: Vec\u003cf64\u003e = (0..n * n)\n        .map(|i| (((i + 500) % 1000) as f64) * 0.01)\n        .collect();\n\n    for _ in 0..WARMUP_ITERS {\n        let _ = tropical_matmul::\u003cTropicalMaxPlus\u003cf64\u003e\u003e(\u0026a, n, n, \u0026b, n);\n    }\n\n    let mut times = Vec::with_capacity(BENCH_ITERS);\n    for _ in 0..BENCH_ITERS {\n        let start = Instant::now();\n        let _ = tropical_matmul::\u003cTropicalMaxPlus\u003cf64\u003e\u003e(\u0026a, n, n, \u0026b, n);\n        times.push(start.elapsed().as_secs_f64());\n    }\n\n    times.sort_by(|a, b| a.partial_cmp(b).unwrap());\n    (times[times.len() / 2], times[0])\n}\n\nfn bench_minplus_f32(n: usize) -\u003e (f64, f64) {\n    let a: Vec\u003cf32\u003e = (0..n * n).map(|i| ((i % 1000) as f32) * 0.01).collect();\n    let b: Vec\u003cf32\u003e = (0..n * n)\n        .map(|i| (((i + 500) % 1000) as f32) * 0.01)\n        .collect();\n\n    for _ in 0..WARMUP_ITERS {\n        let _ = tropical_matmul::\u003cTropicalMinPlus\u003cf32\u003e\u003e(\u0026a, n, n, \u0026b, n);\n    }\n\n    let mut times = Vec::with_capacity(BENCH_ITERS);\n    for _ in 0..BENCH_ITERS {\n        let start = Instant::now();\n        let _ = tropical_matmul::\u003cTropicalMinPlus\u003cf32\u003e\u003e(\u0026a, n, n, \u0026b, n);\n        times.push(start.elapsed().as_secs_f64());\n    }\n\n    times.sort_by(|a, b| a.partial_cmp(b).unwrap());\n    (times[times.len() / 2], times[0])\n}\n\nfn bench_maxmul_f32(n: usize) -\u003e (f64, f64) {\n    let a: Vec\u003cf32\u003e = (0..n * n).map(|i| ((i % 1000) as f32) * 0.01).collect();\n    let b: Vec\u003cf32\u003e = (0..n * n)\n        .map(|i| (((i + 500) % 1000) as f32) * 0.01)\n        .collect();\n\n    for _ in 0..WARMUP_ITERS {\n        let _ = tropical_matmul::\u003cTropicalMaxMul\u003cf32\u003e\u003e(\u0026a, n, n, \u0026b, n);\n    }\n\n    let mut times = Vec::with_capacity(BENCH_ITERS);\n    for _ in 0..BENCH_ITERS {\n        let start = Instant::now();\n        let _ = tropical_matmul::\u003cTropicalMaxMul\u003cf32\u003e\u003e(\u0026a, n, n, \u0026b, n);\n        times.push(start.elapsed().as_secs_f64());\n    }\n\n    times.sort_by(|a, b| a.partial_cmp(b).unwrap());\n    (times[times.len() / 2], times[0])\n}\n\nfn main() {\n    println!(\"{}\", \"=\".repeat(70));\n    println!(\"Tropical GEMM Rust CPU Benchmark\");\n    println!(\"{}\", \"=\".repeat(70));\n    println!();\n    println!(\"Backend: {}\", Backend::description());\n    println!();\n\n    let mut results: Vec\u003c(\u0026str, Vec\u003c(usize, f64, f64)\u003e)\u003e = Vec::new();\n\n    // Benchmark TropicalMaxPlus\u003cf32\u003e\n    {\n        println!(\"{}\", \"-\".repeat(70));\n        println!(\"Benchmarking: TropicalMaxPlus\u003cf32\u003e\");\n        println!(\"{}\", \"-\".repeat(70));\n        println!(\n            \"{:\u003c8}  {:\u003e12}  {:\u003e12}  {:\u003e12}\",\n            \"Size\", \"Median (ms)\", \"Min (ms)\", \"GFLOPS equiv\"\n        );\n\n        let mut data = Vec::new();\n        for \u0026n in SIZES {\n            let (median, min) = bench_maxplus_f32(n);\n            let gflops = 2.0 * (n as f64).powi(3) / min / 1e9;\n            println!(\n                \"{:\u003c8}  {:\u003e12.3}  {:\u003e12.3}  {:\u003e12.2}\",\n                n,\n                median * 1000.0,\n                min * 1000.0,\n                gflops\n            );\n            data.push((n, median, min));\n        }\n        results.push((\"TropicalMaxPlus\u003cf32\u003e\", data));\n        println!();\n    }\n\n    // Benchmark TropicalMaxPlus\u003cf64\u003e\n    {\n        println!(\"{}\", \"-\".repeat(70));\n        println!(\"Benchmarking: TropicalMaxPlus\u003cf64\u003e\");\n        println!(\"{}\", \"-\".repeat(70));\n        println!(\n            \"{:\u003c8}  {:\u003e12}  {:\u003e12}  {:\u003e12}\",\n            \"Size\", \"Median (ms)\", \"Min (ms)\", \"GFLOPS equiv\"\n        );\n\n        let mut data = Vec::new();\n        for \u0026n in \u0026SIZES[..5] {\n            let (median, min) = bench_maxplus_f64(n);\n            let gflops = 2.0 * (n as f64).powi(3) / min / 1e9;\n            println!(\n                \"{:\u003c8}  {:\u003e12.3}  {:\u003e12.3}  {:\u003e12.2}\",\n                n,\n                median * 1000.0,\n                min * 1000.0,\n                gflops\n            );\n            data.push((n, median, min));\n        }\n        results.push((\"TropicalMaxPlus\u003cf64\u003e\", data));\n        println!();\n    }\n\n    // Benchmark TropicalMinPlus\u003cf32\u003e\n    {\n        println!(\"{}\", \"-\".repeat(70));\n        println!(\"Benchmarking: TropicalMinPlus\u003cf32\u003e\");\n        println!(\"{}\", \"-\".repeat(70));\n        println!(\n            \"{:\u003c8}  {:\u003e12}  {:\u003e12}  {:\u003e12}\",\n            \"Size\", \"Median (ms)\", \"Min (ms)\", \"GFLOPS equiv\"\n        );\n\n        let mut data = Vec::new();\n        for \u0026n in SIZES {\n            let (median, min) = bench_minplus_f32(n);\n            let gflops = 2.0 * (n as f64).powi(3) / min / 1e9;\n            println!(\n                \"{:\u003c8}  {:\u003e12.3}  {:\u003e12.3}  {:\u003e12.2}\",\n                n,\n                median * 1000.0,\n                min * 1000.0,\n                gflops\n            );\n            data.push((n, median, min));\n        }\n        results.push((\"TropicalMinPlus\u003cf32\u003e\", data));\n        println!();\n    }\n\n    // Benchmark TropicalMaxMul\u003cf32\u003e\n    {\n        println!(\"{}\", \"-\".repeat(70));\n        println!(\"Benchmarking: TropicalMaxMul\u003cf32\u003e\");\n        println!(\"{}\", \"-\".repeat(70));\n        println!(\n            \"{:\u003c8}  {:\u003e12}  {:\u003e12}  {:\u003e12}\",\n            \"Size\", \"Median (ms)\", \"Min (ms)\", \"GFLOPS equiv\"\n        );\n\n        let mut data = Vec::new();\n        for \u0026n in SIZES {\n            let (median, min) = bench_maxmul_f32(n);\n            let gflops = 2.0 * (n as f64).powi(3) / min / 1e9;\n            println!(\n                \"{:\u003c8}  {:\u003e12.3}  {:\u003e12.3}  {:\u003e12.2}\",\n                n,\n                median * 1000.0,\n                min * 1000.0,\n                gflops\n            );\n            data.push((n, median, min));\n        }\n        results.push((\"TropicalMaxMul\u003cf32\u003e\", data));\n        println!();\n    }\n\n    // Print summary\n    println!(\"{}\", \"=\".repeat(70));\n    println!(\"Summary (min times in milliseconds) - for comparison with Julia/CUDA\");\n    println!(\"{}\", \"=\".repeat(70));\n    print!(\"{:\u003c8}\", \"Size\");\n    for (name, _) in \u0026results {\n        print!(\"  {:\u003e18}\", name);\n    }\n    println!();\n\n    for (i, \u0026n) in SIZES.iter().enumerate() {\n        print!(\"{:\u003c8}\", n);\n        for (_, data) in \u0026results {\n            if i \u003c data.len() {\n                print!(\"  {:\u003e18.3}\", data[i].2 * 1000.0);\n            } else {\n                print!(\"  {:\u003e18}\", \"N/A\");\n            }\n        }\n        println!();\n    }\n\n    println!();\n    println!(\"Benchmark complete!\");\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","leo","rcode","cutropicalgemm","crates","tropical-gemm","examples","shortest_path.rs"],"content":"//! Shortest path computation using tropical matrix multiplication.\n//!\n//! This example demonstrates how to compute all-pairs shortest paths\n//! using TropicalMinPlus matrix multiplication.\n\nuse tropical_gemm::prelude::*;\n\nfn main() {\n    println!(\"All-Pairs Shortest Path using Tropical GEMM\\n\");\n\n    // Create a weighted directed graph with 5 nodes\n    // Using f64::INFINITY for no direct edge\n    let inf = f64::INFINITY;\n\n    // Distance matrix: dist[i][j] = direct edge weight from i to j\n    #[rustfmt::skip]\n    let dist = vec![\n        0.0, 3.0, inf, 7.0, inf,   // from node 0\n        inf, 0.0, 2.0, inf, inf,   // from node 1\n        inf, inf, 0.0, 1.0, 5.0,   // from node 2\n        inf, inf, inf, 0.0, 2.0,   // from node 3\n        inf, inf, inf, inf, 0.0,   // from node 4\n    ];\n\n    println!(\"Initial distance matrix (direct edges):\");\n    print_matrix(\u0026dist, 5);\n\n    // Compute powers of the distance matrix to find shortest paths\n    // D^2 gives shortest 2-hop paths\n    // D^4 = D^2 * D^2 gives shortest 4-hop paths\n    // For a graph with n nodes, D^(n-1) gives all shortest paths\n\n    let n = 5;\n\n    // D^2\n    let d2 = tropical_matmul::\u003cTropicalMinPlus\u003cf64\u003e\u003e(\u0026dist, n, n, \u0026dist, n);\n    let d2_values: Vec\u003cf64\u003e = d2.iter().map(|x| x.value()).collect();\n\n    println!(\"\\nD^2 (shortest paths up to 2 hops):\");\n    print_matrix(\u0026d2_values, 5);\n\n    // D^4 = D^2 * D^2\n    let d4 = tropical_matmul::\u003cTropicalMinPlus\u003cf64\u003e\u003e(\u0026d2_values, n, n, \u0026d2_values, n);\n    let d4_values: Vec\u003cf64\u003e = d4.iter().map(|x| x.value()).collect();\n\n    println!(\"\\nD^4 (all shortest paths, n-1=4 iterations sufficient):\");\n    print_matrix(\u0026d4_values, 5);\n\n    // Verify some paths\n    println!(\"\\nShortest path distances:\");\n    println!(\"  0 -\u003e 4: {} (path: 0-\u003e3-\u003e4 = 7+2 = 9)\", d4_values[4]);\n    println!(\"  0 -\u003e 2: {} (path: 0-\u003e1-\u003e2 = 3+2 = 5)\", d4_values[2]);\n    println!(\n        \"  1 -\u003e 4: {} (path: 1-\u003e2-\u003e3-\u003e4 = 2+1+2 = 5)\",\n        d4_values[n + 4]\n    );\n\n    // With argmax tracking to find the intermediate nodes\n    println!(\"\\n--- Path Reconstruction with Argmax ---\\n\");\n\n    let result =\n        tropical_matmul_with_argmax::\u003cTropicalMinPlus\u003cf64\u003e\u003e(\u0026d2_values, n, n, \u0026d2_values, n);\n\n    println!(\"For D^4, the argmax indicates which intermediate 2-hop point was used:\");\n    for i in 0..n {\n        for j in 0..n {\n            if i != j {\n                let dist = result.get(i, j).value();\n                let via = result.get_argmax(i, j);\n                if dist \u003c inf {\n                    println!(\"  {} -\u003e {}: distance = {:.1}, via node {}\", i, j, dist, via);\n                }\n            }\n        }\n    }\n}\n\nfn print_matrix(data: \u0026[f64], n: usize) {\n    print!(\"     \");\n    for j in 0..n {\n        print!(\"{:5} \", j);\n    }\n    println!();\n    println!(\"   {}\", \"-\".repeat(n * 6 + 1));\n\n    for i in 0..n {\n        print!(\"{:2} | \", i);\n        for j in 0..n {\n            let val = data[i * n + j];\n            if val == f64::INFINITY {\n                print!(\"  inf \");\n            } else {\n                print!(\"{:5.1} \", val);\n            }\n        }\n        println!();\n    }\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","leo","rcode","cutropicalgemm","crates","tropical-gemm","src","api.rs"],"content":"use crate::core::{GemmWithArgmax, Transpose};\nuse crate::simd::{tropical_gemm_dispatch, KernelDispatch};\nuse crate::types::{TropicalSemiring, TropicalWithArgmax};\n\n/// Simple tropical matrix multiplication: C = A ⊗ B\n///\n/// Computes C[i,j] = ⊕_k (A[i,k] ⊗ B[k,j])\n///\n/// # Arguments\n/// - `a`: Matrix A data in row-major order\n/// - `m`: Number of rows in A\n/// - `k`: Number of columns in A / rows in B\n/// - `b`: Matrix B data in row-major order\n/// - `n`: Number of columns in B\n///\n/// # Returns\n/// Result matrix C of size m×n in row-major order\n///\n/// # Example\n///\n/// ```\n/// use tropical_gemm::{tropical_matmul, TropicalMaxPlus};\n///\n/// let a = vec![1.0f32, 2.0, 3.0, 4.0, 5.0, 6.0]; // 2x3\n/// let b = vec![1.0f32, 2.0, 3.0, 4.0, 5.0, 6.0]; // 3x2\n///\n/// let c = tropical_matmul::\u003cTropicalMaxPlus\u003cf32\u003e\u003e(\u0026a, 2, 3, \u0026b, 2);\n/// assert_eq!(c.len(), 4); // 2x2 result\n/// ```\npub fn tropical_matmul\u003cT: TropicalSemiring + KernelDispatch\u003e(\n    a: \u0026[T::Scalar],\n    m: usize,\n    k: usize,\n    b: \u0026[T::Scalar],\n    n: usize,\n) -\u003e Vec\u003cT\u003e {\n    assert_eq!(a.len(), m * k, \"A dimensions mismatch\");\n    assert_eq!(b.len(), k * n, \"B dimensions mismatch\");\n\n    let mut c = vec![T::tropical_zero(); m * n];\n\n    unsafe {\n        tropical_gemm_dispatch::\u003cT\u003e(\n            m,\n            n,\n            k,\n            a.as_ptr(),\n            k,\n            Transpose::NoTrans,\n            b.as_ptr(),\n            n,\n            Transpose::NoTrans,\n            c.as_mut_ptr(),\n            n,\n        );\n    }\n\n    c\n}\n\n/// Tropical matrix multiplication with argmax tracking.\n///\n/// Returns both the result matrix and the argmax indices indicating\n/// which k produced each optimal C[i,j].\n///\n/// # Example\n///\n/// ```\n/// use tropical_gemm::{tropical_matmul_with_argmax, TropicalMaxPlus};\n///\n/// let a = vec![1.0f64, 2.0, 3.0, 4.0, 5.0, 6.0]; // 2x3\n/// let b = vec![1.0f64, 2.0, 3.0, 4.0, 5.0, 6.0]; // 3x2\n///\n/// let result = tropical_matmul_with_argmax::\u003cTropicalMaxPlus\u003cf64\u003e\u003e(\u0026a, 2, 3, \u0026b, 2);\n/// assert_eq!(result.m, 2);\n/// assert_eq!(result.n, 2);\n/// ```\npub fn tropical_matmul_with_argmax\u003cT: TropicalWithArgmax\u003cIndex = u32\u003e + KernelDispatch\u003e(\n    a: \u0026[T::Scalar],\n    m: usize,\n    k: usize,\n    b: \u0026[T::Scalar],\n    n: usize,\n) -\u003e GemmWithArgmax\u003cT\u003e {\n    assert_eq!(a.len(), m * k, \"A dimensions mismatch\");\n    assert_eq!(b.len(), k * n, \"B dimensions mismatch\");\n\n    let mut result = GemmWithArgmax::new(m, n);\n\n    unsafe {\n        crate::core::tropical_gemm_with_argmax_portable::\u003cT\u003e(\n            m,\n            n,\n            k,\n            a.as_ptr(),\n            k,\n            Transpose::NoTrans,\n            b.as_ptr(),\n            n,\n            Transpose::NoTrans,\n            \u0026mut result,\n        );\n    }\n\n    result\n}\n\n/// Builder for configuring tropical GEMM operations.\n///\n/// Provides a fluent API for setting options like transposition,\n/// alpha/beta scaling, and output preferences.\n///\n/// # Example\n///\n/// ```\n/// use tropical_gemm::{TropicalGemm, TropicalMaxPlus, TropicalSemiring};\n///\n/// let a = vec![1.0f32; 6]; // 2x3\n/// let b = vec![1.0f32; 6]; // 3x2\n/// let mut c = vec![TropicalMaxPlus::tropical_zero(); 4]; // 2x2\n///\n/// TropicalGemm::\u003cTropicalMaxPlus\u003cf32\u003e\u003e::new(2, 2, 3)\n///     .execute(\u0026a, 3, \u0026b, 2, \u0026mut c, 2);\n/// ```\npub struct TropicalGemm\u003cT: TropicalSemiring\u003e {\n    m: usize,\n    n: usize,\n    k: usize,\n    trans_a: Transpose,\n    trans_b: Transpose,\n    _phantom: std::marker::PhantomData\u003cT\u003e,\n}\n\nimpl\u003cT: TropicalSemiring + KernelDispatch\u003e TropicalGemm\u003cT\u003e {\n    /// Create a new GEMM builder.\n    pub fn new(m: usize, n: usize, k: usize) -\u003e Self {\n        Self {\n            m,\n            n,\n            k,\n            trans_a: Transpose::NoTrans,\n            trans_b: Transpose::NoTrans,\n            _phantom: std::marker::PhantomData,\n        }\n    }\n\n    /// Transpose matrix A.\n    pub fn trans_a(mut self) -\u003e Self {\n        self.trans_a = Transpose::Trans;\n        self\n    }\n\n    /// Transpose matrix B.\n    pub fn trans_b(mut self) -\u003e Self {\n        self.trans_b = Transpose::Trans;\n        self\n    }\n\n    /// Execute the GEMM operation.\n    ///\n    /// # Arguments\n    /// - `a`: Matrix A data\n    /// - `lda`: Leading dimension of A\n    /// - `b`: Matrix B data\n    /// - `ldb`: Leading dimension of B\n    /// - `c`: Output matrix C (must be pre-allocated)\n    /// - `ldc`: Leading dimension of C\n    pub fn execute(\n        self,\n        a: \u0026[T::Scalar],\n        lda: usize,\n        b: \u0026[T::Scalar],\n        ldb: usize,\n        c: \u0026mut [T],\n        ldc: usize,\n    ) {\n        unsafe {\n            tropical_gemm_dispatch::\u003cT\u003e(\n                self.m,\n                self.n,\n                self.k,\n                a.as_ptr(),\n                lda,\n                self.trans_a,\n                b.as_ptr(),\n                ldb,\n                self.trans_b,\n                c.as_mut_ptr(),\n                ldc,\n            );\n        }\n    }\n}\n\n/// BLAS-style GEMM interface.\n///\n/// C = A ⊗ B\n///\n/// # Safety\n/// All pointers must be valid for the specified dimensions.\npub unsafe fn tropical_gemm\u003cT: TropicalSemiring + KernelDispatch\u003e(\n    m: usize,\n    n: usize,\n    k: usize,\n    a: *const T::Scalar,\n    lda: usize,\n    trans_a: Transpose,\n    b: *const T::Scalar,\n    ldb: usize,\n    trans_b: Transpose,\n    c: *mut T,\n    ldc: usize,\n) {\n    tropical_gemm_dispatch::\u003cT\u003e(m, n, k, a, lda, trans_a, b, ldb, trans_b, c, ldc);\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use crate::types::TropicalMaxPlus;\n\n    #[test]\n    fn test_tropical_matmul() {\n        let a = vec![1.0f64, 2.0, 3.0, 4.0, 5.0, 6.0];\n        let b = vec![1.0f64, 2.0, 3.0, 4.0, 5.0, 6.0];\n\n        let c = tropical_matmul::\u003cTropicalMaxPlus\u003cf64\u003e\u003e(\u0026a, 2, 3, \u0026b, 2);\n\n        // C[0,0] = max(1+1, 2+3, 3+5) = 8\n        assert_eq!(c[0].0, 8.0);\n        // C[0,1] = max(1+2, 2+4, 3+6) = 9\n        assert_eq!(c[1].0, 9.0);\n        // C[1,0] = max(4+1, 5+3, 6+5) = 11\n        assert_eq!(c[2].0, 11.0);\n        // C[1,1] = max(4+2, 5+4, 6+6) = 12\n        assert_eq!(c[3].0, 12.0);\n    }\n\n    #[test]\n    fn test_tropical_matmul_with_argmax() {\n        let a = vec![1.0f64, 2.0, 3.0, 4.0, 5.0, 6.0];\n        let b = vec![1.0f64, 2.0, 3.0, 4.0, 5.0, 6.0];\n\n        let result = tropical_matmul_with_argmax::\u003cTropicalMaxPlus\u003cf64\u003e\u003e(\u0026a, 2, 3, \u0026b, 2);\n\n        assert_eq!(result.get(0, 0).0, 8.0);\n        assert_eq!(result.get_argmax(0, 0), 2); // k=2 produced max\n\n        assert_eq!(result.get(1, 1).0, 12.0);\n        assert_eq!(result.get_argmax(1, 1), 2); // k=2 produced max\n    }\n\n    #[test]\n    fn test_builder_api() {\n        let a = vec![1.0f32; 6];\n        let b = vec![1.0f32; 6];\n        let mut c = vec![TropicalMaxPlus::tropical_zero(); 4];\n\n        TropicalGemm::\u003cTropicalMaxPlus\u003cf32\u003e\u003e::new(2, 2, 3).execute(\u0026a, 3, \u0026b, 2, \u0026mut c, 2);\n\n        // C[0,0] = max(1+1, 1+1, 1+1) = 2 (tropical mul is addition, tropical add is max)\n        assert_eq!(c[0].0, 2.0);\n    }\n\n    #[test]\n    fn test_builder_api_trans_a() {\n        // A is 3x2 stored as column-major (actually 2x3 in row-major transposed)\n        // A^T is 2x3, B is 3x2, result is 2x2\n        let a = vec![1.0f32, 4.0, 2.0, 5.0, 3.0, 6.0]; // col-major 3x2\n        let b = vec![1.0f32, 2.0, 3.0, 4.0, 5.0, 6.0]; // row-major 3x2\n        let mut c = vec![TropicalMaxPlus::tropical_zero(); 4];\n\n        TropicalGemm::\u003cTropicalMaxPlus\u003cf32\u003e\u003e::new(2, 2, 3)\n            .trans_a()\n            .execute(\u0026a, 2, \u0026b, 2, \u0026mut c, 2);\n\n        // A^T = [[1, 2, 3], [4, 5, 6]]\n        // B = [[1, 2], [3, 4], [5, 6]]\n        // C[0,0] = max(1+1, 2+3, 3+5) = 8\n        assert_eq!(c[0].0, 8.0);\n    }\n\n    #[test]\n    fn test_builder_api_trans_b() {\n        // A is 2x3, B^T is 2x3 stored as column-major, result is 2x2\n        let a = vec![1.0f32, 2.0, 3.0, 4.0, 5.0, 6.0]; // row-major 2x3\n        let b = vec![1.0f32, 3.0, 5.0, 2.0, 4.0, 6.0]; // col-major 2x3\n        let mut c = vec![TropicalMaxPlus::tropical_zero(); 4];\n\n        TropicalGemm::\u003cTropicalMaxPlus\u003cf32\u003e\u003e::new(2, 2, 3)\n            .trans_b()\n            .execute(\u0026a, 3, \u0026b, 3, \u0026mut c, 2);\n\n        // A = [[1, 2, 3], [4, 5, 6]]\n        // B^T = [[1, 2], [3, 4], [5, 6]]\n        // C[0,0] = max(1+1, 2+3, 3+5) = 8\n        assert_eq!(c[0].0, 8.0);\n    }\n\n    #[test]\n    fn test_tropical_matmul_min_plus() {\n        use crate::types::TropicalMinPlus;\n\n        let a = vec![1.0f64, 2.0, 3.0, 4.0, 5.0, 6.0];\n        let b = vec![1.0f64, 2.0, 3.0, 4.0, 5.0, 6.0];\n\n        let c = tropical_matmul::\u003cTropicalMinPlus\u003cf64\u003e\u003e(\u0026a, 2, 3, \u0026b, 2);\n\n        // C[0,0] = min(1+1, 2+3, 3+5) = 2\n        assert_eq!(c[0].0, 2.0);\n        // C[0,1] = min(1+2, 2+4, 3+6) = 3\n        assert_eq!(c[1].0, 3.0);\n        // C[1,0] = min(4+1, 5+3, 6+5) = 5\n        assert_eq!(c[2].0, 5.0);\n        // C[1,1] = min(4+2, 5+4, 6+6) = 6\n        assert_eq!(c[3].0, 6.0);\n    }\n\n    #[test]\n    fn test_tropical_matmul_max_mul() {\n        use crate::types::TropicalMaxMul;\n\n        let a = vec![2.0f64, 3.0, 4.0, 5.0];\n        let b = vec![1.0f64, 2.0, 3.0, 4.0];\n\n        let c = tropical_matmul::\u003cTropicalMaxMul\u003cf64\u003e\u003e(\u0026a, 2, 2, \u0026b, 2);\n\n        // C[0,0] = max(2*1, 3*3) = max(2, 9) = 9\n        assert_eq!(c[0].0, 9.0);\n        // C[0,1] = max(2*2, 3*4) = max(4, 12) = 12\n        assert_eq!(c[1].0, 12.0);\n        // C[1,0] = max(4*1, 5*3) = max(4, 15) = 15\n        assert_eq!(c[2].0, 15.0);\n        // C[1,1] = max(4*2, 5*4) = max(8, 20) = 20\n        assert_eq!(c[3].0, 20.0);\n    }\n\n    #[test]\n    fn test_tropical_matmul_f32() {\n        let a = vec![1.0f32, 2.0, 3.0, 4.0, 5.0, 6.0];\n        let b = vec![1.0f32, 2.0, 3.0, 4.0, 5.0, 6.0];\n\n        let c = tropical_matmul::\u003cTropicalMaxPlus\u003cf32\u003e\u003e(\u0026a, 2, 3, \u0026b, 2);\n\n        assert!((c[0].0 - 8.0).abs() \u003c 1e-6);\n        assert!((c[1].0 - 9.0).abs() \u003c 1e-6);\n        assert!((c[2].0 - 11.0).abs() \u003c 1e-6);\n        assert!((c[3].0 - 12.0).abs() \u003c 1e-6);\n    }\n\n    #[test]\n    fn test_non_square_matrices() {\n        // 3x2 * 2x4 = 3x4\n        let a = vec![1.0f64, 2.0, 3.0, 4.0, 5.0, 6.0];\n        let b = vec![1.0f64, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0];\n\n        let c = tropical_matmul::\u003cTropicalMaxPlus\u003cf64\u003e\u003e(\u0026a, 3, 2, \u0026b, 4);\n\n        assert_eq!(c.len(), 12);\n        // C[0,0] = max(1+1, 2+5) = 7\n        assert_eq!(c[0].0, 7.0);\n    }\n\n    #[test]\n    fn test_single_element() {\n        let a = vec![5.0f64];\n        let b = vec![3.0f64];\n\n        let c = tropical_matmul::\u003cTropicalMaxPlus\u003cf64\u003e\u003e(\u0026a, 1, 1, \u0026b, 1);\n\n        assert_eq!(c.len(), 1);\n        assert_eq!(c[0].0, 8.0); // 5 + 3 = 8\n    }\n\n    #[test]\n    fn test_larger_matrix() {\n        let n = 16;\n        let a: Vec\u003cf64\u003e = (0..n * n).map(|i| i as f64).collect();\n        let b: Vec\u003cf64\u003e = (0..n * n).map(|i| (n * n - 1 - i) as f64).collect();\n\n        let c = tropical_matmul::\u003cTropicalMaxPlus\u003cf64\u003e\u003e(\u0026a, n, n, \u0026b, n);\n\n        assert_eq!(c.len(), n * n);\n        // Just verify it doesn't panic and produces reasonable results\n        for val in \u0026c {\n            assert!(val.0.is_finite());\n        }\n    }\n\n    #[test]\n    fn test_tropical_matmul_i32() {\n        let a = vec![1i32, 2, 3, 4, 5, 6];\n        let b = vec![1i32, 2, 3, 4, 5, 6];\n\n        let c = tropical_matmul::\u003cTropicalMaxPlus\u003ci32\u003e\u003e(\u0026a, 2, 3, \u0026b, 2);\n\n        assert_eq!(c[0].0, 8);\n        assert_eq!(c[1].0, 9);\n        assert_eq!(c[2].0, 11);\n        assert_eq!(c[3].0, 12);\n    }\n\n    #[test]\n    fn test_tropical_matmul_i64() {\n        let a = vec![1i64, 2, 3, 4, 5, 6];\n        let b = vec![1i64, 2, 3, 4, 5, 6];\n\n        let c = tropical_matmul::\u003cTropicalMaxPlus\u003ci64\u003e\u003e(\u0026a, 2, 3, \u0026b, 2);\n\n        assert_eq!(c[0].0, 8);\n        assert_eq!(c[1].0, 9);\n        assert_eq!(c[2].0, 11);\n        assert_eq!(c[3].0, 12);\n    }\n\n    #[test]\n    fn test_tropical_matmul_minplus_i32() {\n        use crate::types::TropicalMinPlus;\n\n        let a = vec![1i32, 2, 3, 4, 5, 6];\n        let b = vec![1i32, 2, 3, 4, 5, 6];\n\n        let c = tropical_matmul::\u003cTropicalMinPlus\u003ci32\u003e\u003e(\u0026a, 2, 3, \u0026b, 2);\n\n        assert_eq!(c[0].0, 2);\n        assert_eq!(c[1].0, 3);\n        assert_eq!(c[2].0, 5);\n        assert_eq!(c[3].0, 6);\n    }\n\n    #[test]\n    fn test_unsafe_tropical_gemm() {\n        let a = vec![1.0f64, 2.0, 3.0, 4.0, 5.0, 6.0];\n        let b = vec![1.0f64, 2.0, 3.0, 4.0, 5.0, 6.0];\n        let mut c = vec![TropicalMaxPlus::tropical_zero(); 4];\n\n        unsafe {\n            tropical_gemm::\u003cTropicalMaxPlus\u003cf64\u003e\u003e(\n                2,\n                2,\n                3,\n                a.as_ptr(),\n                3,\n                Transpose::NoTrans,\n                b.as_ptr(),\n                2,\n                Transpose::NoTrans,\n                c.as_mut_ptr(),\n                2,\n            );\n        }\n\n        assert_eq!(c[0].0, 8.0);\n        assert_eq!(c[1].0, 9.0);\n        assert_eq!(c[2].0, 11.0);\n        assert_eq!(c[3].0, 12.0);\n    }\n\n    #[test]\n    fn test_minplus_with_argmax() {\n        use crate::types::TropicalMinPlus;\n\n        let a = vec![1.0f64, 2.0, 3.0, 4.0, 5.0, 6.0];\n        let b = vec![1.0f64, 2.0, 3.0, 4.0, 5.0, 6.0];\n\n        let result = tropical_matmul_with_argmax::\u003cTropicalMinPlus\u003cf64\u003e\u003e(\u0026a, 2, 3, \u0026b, 2);\n\n        // C[0,0] = min(1+1, 2+3, 3+5) = 2 at k=0\n        assert_eq!(result.get(0, 0).0, 2.0);\n        assert_eq!(result.get_argmax(0, 0), 0);\n\n        // C[1,1] = min(4+2, 5+4, 6+6) = 6 at k=0\n        assert_eq!(result.get(1, 1).0, 6.0);\n        assert_eq!(result.get_argmax(1, 1), 0);\n    }\n\n    #[test]\n    fn test_maxmul_with_argmax() {\n        use crate::types::TropicalMaxMul;\n\n        let a = vec![2.0f64, 3.0, 4.0, 5.0];\n        let b = vec![1.0f64, 2.0, 3.0, 4.0];\n\n        let result = tropical_matmul_with_argmax::\u003cTropicalMaxMul\u003cf64\u003e\u003e(\u0026a, 2, 2, \u0026b, 2);\n\n        // C[0,0] = max(2*1, 3*3) = 9 at k=1\n        assert_eq!(result.get(0, 0).0, 9.0);\n        assert_eq!(result.get_argmax(0, 0), 1);\n    }\n\n    #[test]\n    fn test_gemmwithargmax_dimensions() {\n        let a = vec![1.0f64; 12]; // 3x4\n        let b = vec![1.0f64; 20]; // 4x5\n\n        let result = tropical_matmul_with_argmax::\u003cTropicalMaxPlus\u003cf64\u003e\u003e(\u0026a, 3, 4, \u0026b, 5);\n\n        assert_eq!(result.m, 3);\n        assert_eq!(result.n, 5);\n        assert_eq!(result.values.len(), 15);\n        assert_eq!(result.argmax.len(), 15);\n    }\n\n    #[test]\n    fn test_identity_like_matrix() {\n        // Matrix with -inf everywhere except diagonal has 0\n        let a = vec![0.0f64, f64::NEG_INFINITY, f64::NEG_INFINITY, 0.0];\n        let b = vec![1.0f64, 2.0, 3.0, 4.0];\n\n        let c = tropical_matmul::\u003cTropicalMaxPlus\u003cf64\u003e\u003e(\u0026a, 2, 2, \u0026b, 2);\n\n        // With \"identity\" A, C should equal B\n        assert_eq!(c[0].0, 1.0);\n        assert_eq!(c[1].0, 2.0);\n        assert_eq!(c[2].0, 3.0);\n        assert_eq!(c[3].0, 4.0);\n    }\n}\n","traces":[{"line":30,"address":[],"length":0,"stats":{"Line":11}},{"line":37,"address":[],"length":0,"stats":{"Line":44}},{"line":38,"address":[],"length":0,"stats":{"Line":44}},{"line":40,"address":[],"length":0,"stats":{"Line":44}},{"line":44,"address":[],"length":0,"stats":{"Line":22}},{"line":45,"address":[],"length":0,"stats":{"Line":22}},{"line":46,"address":[],"length":0,"stats":{"Line":22}},{"line":47,"address":[],"length":0,"stats":{"Line":33}},{"line":48,"address":[],"length":0,"stats":{"Line":22}},{"line":49,"address":[],"length":0,"stats":{"Line":22}},{"line":50,"address":[],"length":0,"stats":{"Line":33}},{"line":51,"address":[],"length":0,"stats":{"Line":22}},{"line":52,"address":[],"length":0,"stats":{"Line":22}},{"line":53,"address":[],"length":0,"stats":{"Line":22}},{"line":54,"address":[],"length":0,"stats":{"Line":11}},{"line":58,"address":[],"length":0,"stats":{"Line":11}},{"line":78,"address":[],"length":0,"stats":{"Line":4}},{"line":85,"address":[],"length":0,"stats":{"Line":16}},{"line":86,"address":[],"length":0,"stats":{"Line":16}},{"line":88,"address":[],"length":0,"stats":{"Line":16}},{"line":92,"address":[],"length":0,"stats":{"Line":8}},{"line":93,"address":[],"length":0,"stats":{"Line":8}},{"line":94,"address":[],"length":0,"stats":{"Line":8}},{"line":95,"address":[],"length":0,"stats":{"Line":12}},{"line":96,"address":[],"length":0,"stats":{"Line":8}},{"line":97,"address":[],"length":0,"stats":{"Line":8}},{"line":98,"address":[],"length":0,"stats":{"Line":12}},{"line":99,"address":[],"length":0,"stats":{"Line":8}},{"line":100,"address":[],"length":0,"stats":{"Line":4}},{"line":101,"address":[],"length":0,"stats":{"Line":4}},{"line":105,"address":[],"length":0,"stats":{"Line":4}},{"line":136,"address":[],"length":0,"stats":{"Line":3}},{"line":148,"address":[],"length":0,"stats":{"Line":1}},{"line":149,"address":[],"length":0,"stats":{"Line":1}},{"line":150,"address":[],"length":0,"stats":{"Line":1}},{"line":154,"address":[],"length":0,"stats":{"Line":1}},{"line":155,"address":[],"length":0,"stats":{"Line":1}},{"line":156,"address":[],"length":0,"stats":{"Line":1}},{"line":168,"address":[],"length":0,"stats":{"Line":3}},{"line":179,"address":[],"length":0,"stats":{"Line":6}},{"line":180,"address":[],"length":0,"stats":{"Line":6}},{"line":181,"address":[],"length":0,"stats":{"Line":6}},{"line":182,"address":[],"length":0,"stats":{"Line":9}},{"line":183,"address":[],"length":0,"stats":{"Line":6}},{"line":184,"address":[],"length":0,"stats":{"Line":6}},{"line":185,"address":[],"length":0,"stats":{"Line":9}},{"line":186,"address":[],"length":0,"stats":{"Line":6}},{"line":187,"address":[],"length":0,"stats":{"Line":6}},{"line":188,"address":[],"length":0,"stats":{"Line":6}},{"line":189,"address":[],"length":0,"stats":{"Line":3}},{"line":201,"address":[],"length":0,"stats":{"Line":1}},{"line":214,"address":[],"length":0,"stats":{"Line":12}}],"covered":52,"coverable":52},{"path":["/","home","leo","rcode","cutropicalgemm","crates","tropical-gemm","src","core","argmax.rs"],"content":"use crate::types::TropicalWithArgmax;\n\n/// Result of GEMM with argmax tracking.\n///\n/// For each element C[i,j], tracks which k index produced the optimal value:\n/// C[i,j] = ⊕_{k} A[i,k] ⊗ B[k,j]\n/// argmax[i,j] = argmax_k (A[i,k] ⊗ B[k,j])\n#[derive(Debug, Clone)]\npub struct GemmWithArgmax\u003cT: TropicalWithArgmax\u003cIndex = u32\u003e\u003e {\n    /// The result matrix values.\n    pub values: Vec\u003cT\u003e,\n    /// The argmax indices for each element.\n    pub argmax: Vec\u003cu32\u003e,\n    /// Number of rows in the result.\n    pub m: usize,\n    /// Number of columns in the result.\n    pub n: usize,\n    /// Leading dimension (stride between rows).\n    pub ld: usize,\n}\n\nimpl\u003cT: TropicalWithArgmax\u003cIndex = u32\u003e\u003e GemmWithArgmax\u003cT\u003e {\n    /// Create a new result container with tropical zeros.\n    pub fn new(m: usize, n: usize) -\u003e Self {\n        let size = m * n;\n        Self {\n            values: vec![T::tropical_zero(); size],\n            argmax: vec![0u32; size],\n            m,\n            n,\n            ld: n,\n        }\n    }\n\n    /// Create a new result container with specified leading dimension.\n    pub fn with_ld(m: usize, n: usize, ld: usize) -\u003e Self {\n        assert!(ld \u003e= n, \"Leading dimension must be \u003e= n\");\n        let size = m * ld;\n        Self {\n            values: vec![T::tropical_zero(); size],\n            argmax: vec![0u32; size],\n            m,\n            n,\n            ld,\n        }\n    }\n\n    /// Get value at (i, j).\n    #[inline]\n    pub fn get(\u0026self, i: usize, j: usize) -\u003e T {\n        debug_assert!(i \u003c self.m \u0026\u0026 j \u003c self.n);\n        self.values[i * self.ld + j]\n    }\n\n    /// Get argmax at (i, j).\n    #[inline]\n    pub fn get_argmax(\u0026self, i: usize, j: usize) -\u003e u32 {\n        debug_assert!(i \u003c self.m \u0026\u0026 j \u003c self.n);\n        self.argmax[i * self.ld + j]\n    }\n\n    /// Get mutable reference to value at (i, j).\n    #[inline]\n    pub fn get_mut(\u0026mut self, i: usize, j: usize) -\u003e \u0026mut T {\n        debug_assert!(i \u003c self.m \u0026\u0026 j \u003c self.n);\n        \u0026mut self.values[i * self.ld + j]\n    }\n\n    /// Get mutable reference to argmax at (i, j).\n    #[inline]\n    pub fn get_argmax_mut(\u0026mut self, i: usize, j: usize) -\u003e \u0026mut u32 {\n        debug_assert!(i \u003c self.m \u0026\u0026 j \u003c self.n);\n        \u0026mut self.argmax[i * self.ld + j]\n    }\n\n    /// Get raw pointers to the data.\n    #[inline]\n    pub fn as_mut_ptrs(\u0026mut self) -\u003e (*mut T, *mut u32) {\n        (self.values.as_mut_ptr(), self.argmax.as_mut_ptr())\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use crate::types::TropicalMaxPlus;\n\n    #[test]\n    fn test_gemm_with_argmax_new() {\n        let result: GemmWithArgmax\u003cTropicalMaxPlus\u003cf64\u003e\u003e = GemmWithArgmax::new(3, 4);\n\n        assert_eq!(result.m, 3);\n        assert_eq!(result.n, 4);\n        assert_eq!(result.ld, 4);\n        assert_eq!(result.values.len(), 12);\n        assert_eq!(result.argmax.len(), 12);\n\n        // All values should be tropical zero (-inf)\n        for i in 0..3 {\n            for j in 0..4 {\n                assert_eq!(result.get(i, j).0, f64::NEG_INFINITY);\n                assert_eq!(result.get_argmax(i, j), 0);\n            }\n        }\n    }\n\n    #[test]\n    fn test_gemm_with_argmax_with_ld() {\n        let result: GemmWithArgmax\u003cTropicalMaxPlus\u003cf64\u003e\u003e = GemmWithArgmax::with_ld(3, 4, 8);\n\n        assert_eq!(result.m, 3);\n        assert_eq!(result.n, 4);\n        assert_eq!(result.ld, 8);\n        // Size is m * ld = 3 * 8 = 24\n        assert_eq!(result.values.len(), 24);\n        assert_eq!(result.argmax.len(), 24);\n    }\n\n    #[test]\n    #[should_panic(expected = \"Leading dimension must be \u003e= n\")]\n    fn test_gemm_with_argmax_with_ld_invalid() {\n        let _: GemmWithArgmax\u003cTropicalMaxPlus\u003cf64\u003e\u003e = GemmWithArgmax::with_ld(3, 4, 2);\n    }\n\n    #[test]\n    fn test_gemm_with_argmax_get_mut() {\n        let mut result: GemmWithArgmax\u003cTropicalMaxPlus\u003cf64\u003e\u003e = GemmWithArgmax::new(2, 2);\n\n        // Modify value using get_mut\n        *result.get_mut(0, 1) = TropicalMaxPlus(5.0);\n        *result.get_mut(1, 0) = TropicalMaxPlus(3.0);\n\n        assert_eq!(result.get(0, 1).0, 5.0);\n        assert_eq!(result.get(1, 0).0, 3.0);\n        assert_eq!(result.get(0, 0).0, f64::NEG_INFINITY);\n    }\n\n    #[test]\n    fn test_gemm_with_argmax_get_argmax_mut() {\n        let mut result: GemmWithArgmax\u003cTropicalMaxPlus\u003cf64\u003e\u003e = GemmWithArgmax::new(2, 2);\n\n        // Modify argmax using get_argmax_mut\n        *result.get_argmax_mut(0, 1) = 42;\n        *result.get_argmax_mut(1, 0) = 7;\n\n        assert_eq!(result.get_argmax(0, 1), 42);\n        assert_eq!(result.get_argmax(1, 0), 7);\n        assert_eq!(result.get_argmax(0, 0), 0);\n    }\n\n    #[test]\n    fn test_gemm_with_argmax_as_mut_ptrs() {\n        let mut result: GemmWithArgmax\u003cTropicalMaxPlus\u003cf64\u003e\u003e = GemmWithArgmax::new(2, 3);\n        let (values_ptr, argmax_ptr) = result.as_mut_ptrs();\n\n        // Write through raw pointers\n        unsafe {\n            *values_ptr.add(0) = TropicalMaxPlus(1.0);\n            *values_ptr.add(5) = TropicalMaxPlus(6.0);\n            *argmax_ptr.add(0) = 10;\n            *argmax_ptr.add(5) = 20;\n        }\n\n        assert_eq!(result.get(0, 0).0, 1.0);\n        assert_eq!(result.get(1, 2).0, 6.0);\n        assert_eq!(result.get_argmax(0, 0), 10);\n        assert_eq!(result.get_argmax(1, 2), 20);\n    }\n}\n","traces":[{"line":24,"address":[],"length":0,"stats":{"Line":17}},{"line":25,"address":[],"length":0,"stats":{"Line":34}},{"line":27,"address":[],"length":0,"stats":{"Line":68}},{"line":28,"address":[],"length":0,"stats":{"Line":51}},{"line":36,"address":[],"length":0,"stats":{"Line":2}},{"line":37,"address":[],"length":0,"stats":{"Line":5}},{"line":38,"address":[],"length":0,"stats":{"Line":2}},{"line":40,"address":[],"length":0,"stats":{"Line":4}},{"line":41,"address":[],"length":0,"stats":{"Line":3}},{"line":50,"address":[],"length":0,"stats":{"Line":98}},{"line":51,"address":[],"length":0,"stats":{"Line":294}},{"line":52,"address":[],"length":0,"stats":{"Line":196}},{"line":57,"address":[],"length":0,"stats":{"Line":98}},{"line":58,"address":[],"length":0,"stats":{"Line":294}},{"line":59,"address":[],"length":0,"stats":{"Line":196}},{"line":64,"address":[],"length":0,"stats":{"Line":2}},{"line":65,"address":[],"length":0,"stats":{"Line":6}},{"line":66,"address":[],"length":0,"stats":{"Line":4}},{"line":71,"address":[],"length":0,"stats":{"Line":2}},{"line":72,"address":[],"length":0,"stats":{"Line":6}},{"line":73,"address":[],"length":0,"stats":{"Line":4}},{"line":78,"address":[],"length":0,"stats":{"Line":13}},{"line":79,"address":[],"length":0,"stats":{"Line":39}}],"covered":23,"coverable":23},{"path":["/","home","leo","rcode","cutropicalgemm","crates","tropical-gemm","src","core","gemm.rs"],"content":"use super::argmax::GemmWithArgmax;\nuse super::kernel::{Microkernel, MicrokernelWithArgmax, PortableMicrokernel};\nuse super::packing::{pack_a, pack_b, packed_a_size, packed_b_size, Layout, Transpose};\nuse super::tiling::{BlockIterator, TilingParams};\nuse crate::types::{TropicalSemiring, TropicalWithArgmax};\n\n/// Tropical GEMM: C = A ⊗ B\n///\n/// Computes C[i,j] = ⊕_k (A[i,k] ⊗ B[k,j])\n///\n/// This is a portable (non-SIMD) implementation using BLIS-style blocking\n/// for cache efficiency.\n///\n/// # Parameters\n/// - `m`: Number of rows in A and C\n/// - `n`: Number of columns in B and C\n/// - `k`: Number of columns in A / rows in B\n/// - `a`: Pointer to matrix A data\n/// - `lda`: Leading dimension of A\n/// - `trans_a`: Whether A is transposed\n/// - `b`: Pointer to matrix B data\n/// - `ldb`: Leading dimension of B\n/// - `trans_b`: Whether B is transposed\n/// - `c`: Pointer to matrix C data (output)\n/// - `ldc`: Leading dimension of C\n///\n/// # Safety\n/// - All pointers must be valid for the specified dimensions\n/// - Memory regions must not overlap inappropriately\npub unsafe fn tropical_gemm_portable\u003cT: TropicalSemiring\u003e(\n    m: usize,\n    n: usize,\n    k: usize,\n    a: *const T::Scalar,\n    lda: usize,\n    trans_a: Transpose,\n    b: *const T::Scalar,\n    ldb: usize,\n    trans_b: Transpose,\n    c: *mut T,\n    ldc: usize,\n) {\n    let params = TilingParams::PORTABLE;\n    let kernel = PortableMicrokernel;\n\n    tropical_gemm_inner::\u003cT, PortableMicrokernel\u003e(\n        m, n, k, a, lda, trans_a, b, ldb, trans_b, c, ldc, \u0026params, \u0026kernel,\n    );\n}\n\n/// Tropical GEMM with custom kernel and tiling parameters.\n///\n/// # Safety\n/// Same requirements as `tropical_gemm_portable`\npub unsafe fn tropical_gemm_inner\u003cT: TropicalSemiring, K: Microkernel\u003cT\u003e\u003e(\n    m: usize,\n    n: usize,\n    k: usize,\n    a: *const T::Scalar,\n    lda: usize,\n    trans_a: Transpose,\n    b: *const T::Scalar,\n    ldb: usize,\n    trans_b: Transpose,\n    c: *mut T,\n    ldc: usize,\n    params: \u0026TilingParams,\n    kernel: \u0026K,\n) {\n    if m == 0 || n == 0 || k == 0 {\n        return;\n    }\n\n    // Allocate packing buffers\n    let mut packed_a = vec![T::Scalar::scalar_zero(); packed_a_size(params.mc, params.kc, K::MR)];\n    let mut packed_b = vec![T::Scalar::scalar_zero(); packed_b_size(params.kc, params.nc, K::NR)];\n\n    // BLIS-style 5-loop blocking\n    // Loop 5: blocks of n\n    for (jc, nc) in BlockIterator::new(n, params.nc) {\n        // Loop 4: blocks of k\n        for (pc, kc) in BlockIterator::new(k, params.kc) {\n            // Pack B panel: kc × nc\n            pack_b::\u003cT::Scalar\u003e(\n                kc,\n                nc,\n                b_panel_ptr(b, pc, jc, ldb, trans_b),\n                ldb,\n                Layout::RowMajor,\n                trans_b,\n                packed_b.as_mut_ptr(),\n                K::NR,\n            );\n\n            // Loop 3: blocks of m\n            for (ic, mc) in BlockIterator::new(m, params.mc) {\n                // Pack A panel: mc × kc\n                pack_a::\u003cT::Scalar\u003e(\n                    mc,\n                    kc,\n                    a_panel_ptr(a, ic, pc, lda, trans_a),\n                    lda,\n                    Layout::RowMajor,\n                    trans_a,\n                    packed_a.as_mut_ptr(),\n                    K::MR,\n                );\n\n                // Loop 2: micro-blocks of n\n                let n_blocks = nc.div_ceil(K::NR);\n                for jr in 0..n_blocks {\n                    let j_start = jr * K::NR;\n                    let nr = (nc - j_start).min(K::NR);\n\n                    // Loop 1: micro-blocks of m\n                    let m_blocks = mc.div_ceil(K::MR);\n                    for ir in 0..m_blocks {\n                        let i_start = ir * K::MR;\n                        let mr = (mc - i_start).min(K::MR);\n\n                        // Microkernel\n                        let a_ptr = packed_a.as_ptr().add(ir * K::MR * kc);\n                        let b_ptr = packed_b.as_ptr().add(jr * K::NR * kc);\n                        let c_ptr = c.add((ic + i_start) * ldc + (jc + j_start));\n\n                        kernel.execute(mr, nr, kc, a_ptr, b_ptr, c_ptr, ldc);\n                    }\n                }\n            }\n        }\n    }\n}\n\n/// Tropical GEMM with argmax tracking.\n///\n/// Same as `tropical_gemm_portable` but also computes argmax indices.\n///\n/// # Safety\n/// Same requirements as `tropical_gemm_portable`\npub unsafe fn tropical_gemm_with_argmax_portable\u003cT: TropicalWithArgmax\u003cIndex = u32\u003e\u003e(\n    m: usize,\n    n: usize,\n    k: usize,\n    a: *const T::Scalar,\n    lda: usize,\n    trans_a: Transpose,\n    b: *const T::Scalar,\n    ldb: usize,\n    trans_b: Transpose,\n    result: \u0026mut GemmWithArgmax\u003cT\u003e,\n) {\n    let params = TilingParams::PORTABLE;\n    let kernel = PortableMicrokernel;\n\n    tropical_gemm_with_argmax_inner::\u003cT, PortableMicrokernel\u003e(\n        m, n, k, a, lda, trans_a, b, ldb, trans_b, result, \u0026params, \u0026kernel,\n    );\n}\n\n/// Tropical GEMM with argmax tracking and custom kernel.\n///\n/// # Safety\n/// Same requirements as `tropical_gemm_portable`\npub unsafe fn tropical_gemm_with_argmax_inner\u003c\n    T: TropicalWithArgmax\u003cIndex = u32\u003e,\n    K: MicrokernelWithArgmax\u003cT\u003e,\n\u003e(\n    m: usize,\n    n: usize,\n    k: usize,\n    a: *const T::Scalar,\n    lda: usize,\n    trans_a: Transpose,\n    b: *const T::Scalar,\n    ldb: usize,\n    trans_b: Transpose,\n    result: \u0026mut GemmWithArgmax\u003cT\u003e,\n    params: \u0026TilingParams,\n    kernel: \u0026K,\n) {\n    if m == 0 || n == 0 || k == 0 {\n        return;\n    }\n\n    let ldc = result.ld;\n    let (c, argmax) = result.as_mut_ptrs();\n\n    // Allocate packing buffers\n    let mut packed_a = vec![T::Scalar::scalar_zero(); packed_a_size(params.mc, params.kc, K::MR)];\n    let mut packed_b = vec![T::Scalar::scalar_zero(); packed_b_size(params.kc, params.nc, K::NR)];\n\n    // BLIS-style 5-loop blocking\n    for (jc, nc) in BlockIterator::new(n, params.nc) {\n        for (pc, kc) in BlockIterator::new(k, params.kc) {\n            pack_b::\u003cT::Scalar\u003e(\n                kc,\n                nc,\n                b_panel_ptr(b, pc, jc, ldb, trans_b),\n                ldb,\n                Layout::RowMajor,\n                trans_b,\n                packed_b.as_mut_ptr(),\n                K::NR,\n            );\n\n            for (ic, mc) in BlockIterator::new(m, params.mc) {\n                pack_a::\u003cT::Scalar\u003e(\n                    mc,\n                    kc,\n                    a_panel_ptr(a, ic, pc, lda, trans_a),\n                    lda,\n                    Layout::RowMajor,\n                    trans_a,\n                    packed_a.as_mut_ptr(),\n                    K::MR,\n                );\n\n                let n_blocks = nc.div_ceil(K::NR);\n                for jr in 0..n_blocks {\n                    let j_start = jr * K::NR;\n                    let nr = (nc - j_start).min(K::NR);\n\n                    let m_blocks = mc.div_ceil(K::MR);\n                    for ir in 0..m_blocks {\n                        let i_start = ir * K::MR;\n                        let mr = (mc - i_start).min(K::MR);\n\n                        let a_ptr = packed_a.as_ptr().add(ir * K::MR * kc);\n                        let b_ptr = packed_b.as_ptr().add(jr * K::NR * kc);\n                        let c_ptr = c.add((ic + i_start) * ldc + (jc + j_start));\n                        let argmax_ptr = argmax.add((ic + i_start) * ldc + (jc + j_start));\n\n                        kernel.execute_with_argmax(\n                            mr, nr, kc, pc, a_ptr, b_ptr, c_ptr, argmax_ptr, ldc,\n                        );\n                    }\n                }\n            }\n        }\n    }\n}\n\n/// Get pointer to A panel considering transpose.\n#[inline]\nunsafe fn a_panel_ptr\u003cT\u003e(\n    a: *const T,\n    row: usize,\n    col: usize,\n    lda: usize,\n    trans: Transpose,\n) -\u003e *const T {\n    match trans {\n        Transpose::NoTrans =\u003e a.add(row * lda + col),\n        Transpose::Trans =\u003e a.add(col * lda + row),\n    }\n}\n\n/// Get pointer to B panel considering transpose.\n#[inline]\nunsafe fn b_panel_ptr\u003cT\u003e(\n    b: *const T,\n    row: usize,\n    col: usize,\n    ldb: usize,\n    trans: Transpose,\n) -\u003e *const T {\n    match trans {\n        Transpose::NoTrans =\u003e b.add(row * ldb + col),\n        Transpose::Trans =\u003e b.add(col * ldb + row),\n    }\n}\n\nuse crate::types::TropicalScalar;\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use crate::types::TropicalMaxPlus;\n\n    #[test]\n    fn test_simple_gemm() {\n        let m = 2;\n        let n = 2;\n        let k = 3;\n\n        // A: 2x3 matrix\n        let a: [f64; 6] = [\n            1.0, 2.0, 3.0, // row 0\n            4.0, 5.0, 6.0, // row 1\n        ];\n\n        // B: 3x2 matrix\n        let b: [f64; 6] = [\n            1.0, 2.0, // row 0\n            3.0, 4.0, // row 1\n            5.0, 6.0, // row 2\n        ];\n\n        let mut c = vec![TropicalMaxPlus::tropical_zero(); m * n];\n\n        unsafe {\n            tropical_gemm_portable::\u003cTropicalMaxPlus\u003cf64\u003e\u003e(\n                m,\n                n,\n                k,\n                a.as_ptr(),\n                3,\n                Transpose::NoTrans,\n                b.as_ptr(),\n                2,\n                Transpose::NoTrans,\n                c.as_mut_ptr(),\n                n,\n            );\n        }\n\n        // C[0,0] = max(1+1, 2+3, 3+5) = max(2, 5, 8) = 8\n        assert_eq!(c[0].0, 8.0);\n        // C[0,1] = max(1+2, 2+4, 3+6) = max(3, 6, 9) = 9\n        assert_eq!(c[1].0, 9.0);\n        // C[1,0] = max(4+1, 5+3, 6+5) = max(5, 8, 11) = 11\n        assert_eq!(c[2].0, 11.0);\n        // C[1,1] = max(4+2, 5+4, 6+6) = max(6, 9, 12) = 12\n        assert_eq!(c[3].0, 12.0);\n    }\n\n    #[test]\n    fn test_gemm_with_argmax() {\n        let m = 2;\n        let n = 2;\n        let k = 3;\n\n        let a: [f64; 6] = [1.0, 2.0, 3.0, 4.0, 5.0, 6.0];\n        let b: [f64; 6] = [1.0, 2.0, 3.0, 4.0, 5.0, 6.0];\n\n        let mut result: GemmWithArgmax\u003cTropicalMaxPlus\u003cf64\u003e\u003e = GemmWithArgmax::new(m, n);\n\n        unsafe {\n            tropical_gemm_with_argmax_portable::\u003cTropicalMaxPlus\u003cf64\u003e\u003e(\n                m,\n                n,\n                k,\n                a.as_ptr(),\n                3,\n                Transpose::NoTrans,\n                b.as_ptr(),\n                2,\n                Transpose::NoTrans,\n                \u0026mut result,\n            );\n        }\n\n        // C[0,0] = max(1+1, 2+3, 3+5) = 8 at k=2\n        assert_eq!(result.get(0, 0).0, 8.0);\n        assert_eq!(result.get_argmax(0, 0), 2);\n\n        // C[1,1] = max(4+2, 5+4, 6+6) = 12 at k=2\n        assert_eq!(result.get(1, 1).0, 12.0);\n        assert_eq!(result.get_argmax(1, 1), 2);\n    }\n\n    #[test]\n    fn test_gemm_with_argmax_all_positions() {\n        // Test that argmax correctly tracks the optimal k for all positions\n        let m = 2;\n        let n = 2;\n        let k = 3;\n\n        // Design A and B so each C[i,j] has a different optimal k\n        // A: 2x3, B: 3x2\n        // C[i,j] = max_k(A[i,k] + B[k,j])\n        let a: [f64; 6] = [\n            10.0, 1.0, 1.0, // row 0: k=0 dominates for C[0,*]\n            1.0, 1.0, 10.0, // row 1: k=2 dominates for C[1,*]\n        ];\n        let b: [f64; 6] = [\n            10.0, 1.0, // row 0: col 0 prefers k=0\n            1.0, 10.0, // row 1: col 1 prefers k=1\n            1.0, 1.0, // row 2\n        ];\n\n        let mut result: GemmWithArgmax\u003cTropicalMaxPlus\u003cf64\u003e\u003e = GemmWithArgmax::new(m, n);\n\n        unsafe {\n            tropical_gemm_with_argmax_portable::\u003cTropicalMaxPlus\u003cf64\u003e\u003e(\n                m,\n                n,\n                k,\n                a.as_ptr(),\n                3,\n                Transpose::NoTrans,\n                b.as_ptr(),\n                2,\n                Transpose::NoTrans,\n                \u0026mut result,\n            );\n        }\n\n        // C[0,0] = max(10+10, 1+1, 1+1) = 20 at k=0\n        assert_eq!(result.get(0, 0).0, 20.0);\n        assert_eq!(result.get_argmax(0, 0), 0);\n\n        // C[0,1] = max(10+1, 1+10, 1+1) = 11 at k=0 or k=1 (both give 11)\n        assert_eq!(result.get(0, 1).0, 11.0);\n        // k=0 gives 11, k=1 gives 11 - first wins (\u003e=)\n        assert_eq!(result.get_argmax(0, 1), 0);\n\n        // C[1,0] = max(1+10, 1+1, 10+1) = 11 at k=0 or k=2\n        assert_eq!(result.get(1, 0).0, 11.0);\n        assert_eq!(result.get_argmax(1, 0), 0); // k=0 wins first\n\n        // C[1,1] = max(1+1, 1+10, 10+1) = 11 at k=1 or k=2\n        assert_eq!(result.get(1, 1).0, 11.0);\n        assert_eq!(result.get_argmax(1, 1), 1); // k=1 wins first with 11\n    }\n\n    #[test]\n    fn test_gemm_minplus_with_argmax() {\n        use crate::types::TropicalMinPlus;\n\n        let m = 2;\n        let n = 2;\n        let k = 3;\n\n        // For MinPlus, argmax tracks argmin\n        let a: [f64; 6] = [\n            1.0, 5.0, 3.0, // row 0\n            2.0, 4.0, 6.0, // row 1\n        ];\n        let b: [f64; 6] = [\n            1.0, 2.0, // row 0\n            3.0, 4.0, // row 1\n            5.0, 6.0, // row 2\n        ];\n\n        let mut result: GemmWithArgmax\u003cTropicalMinPlus\u003cf64\u003e\u003e = GemmWithArgmax::new(m, n);\n\n        unsafe {\n            tropical_gemm_with_argmax_portable::\u003cTropicalMinPlus\u003cf64\u003e\u003e(\n                m,\n                n,\n                k,\n                a.as_ptr(),\n                3,\n                Transpose::NoTrans,\n                b.as_ptr(),\n                2,\n                Transpose::NoTrans,\n                \u0026mut result,\n            );\n        }\n\n        // C[0,0] = min(1+1, 5+3, 3+5) = min(2, 8, 8) = 2 at k=0\n        assert_eq!(result.get(0, 0).0, 2.0);\n        assert_eq!(result.get_argmax(0, 0), 0);\n\n        // C[0,1] = min(1+2, 5+4, 3+6) = min(3, 9, 9) = 3 at k=0\n        assert_eq!(result.get(0, 1).0, 3.0);\n        assert_eq!(result.get_argmax(0, 1), 0);\n\n        // C[1,0] = min(2+1, 4+3, 6+5) = min(3, 7, 11) = 3 at k=0\n        assert_eq!(result.get(1, 0).0, 3.0);\n        assert_eq!(result.get_argmax(1, 0), 0);\n\n        // C[1,1] = min(2+2, 4+4, 6+6) = min(4, 8, 12) = 4 at k=0\n        assert_eq!(result.get(1, 1).0, 4.0);\n        assert_eq!(result.get_argmax(1, 1), 0);\n    }\n\n    #[test]\n    fn test_gemm_larger_with_argmax() {\n        // Test with larger matrix to exercise blocking code paths\n        let m = 8;\n        let n = 8;\n        let k = 8;\n\n        let a: Vec\u003cf64\u003e = (0..m * k).map(|i| i as f64).collect();\n        let b: Vec\u003cf64\u003e = (0..k * n).map(|i| (k * n - 1 - i) as f64).collect();\n\n        let mut result: GemmWithArgmax\u003cTropicalMaxPlus\u003cf64\u003e\u003e = GemmWithArgmax::new(m, n);\n\n        unsafe {\n            tropical_gemm_with_argmax_portable::\u003cTropicalMaxPlus\u003cf64\u003e\u003e(\n                m,\n                n,\n                k,\n                a.as_ptr(),\n                k,\n                Transpose::NoTrans,\n                b.as_ptr(),\n                n,\n                Transpose::NoTrans,\n                \u0026mut result,\n            );\n        }\n\n        // Verify all results are finite and argmax indices are valid\n        for i in 0..m {\n            for j in 0..n {\n                assert!(result.get(i, j).0.is_finite());\n                assert!(result.get_argmax(i, j) \u003c k as u32);\n            }\n        }\n    }\n\n    #[test]\n    fn test_gemm_trans_a() {\n        // Test with A transposed\n        // A is stored column-major (3x2), so A^T is 2x3\n        // A^T = [[1, 2, 3], [4, 5, 6]]\n        let m = 2;\n        let n = 2;\n        let k = 3;\n\n        let a: [f64; 6] = [\n            1.0, 4.0, // column 0\n            2.0, 5.0, // column 1\n            3.0, 6.0, // column 2\n        ];\n\n        let b: [f64; 6] = [\n            1.0, 2.0, // row 0\n            3.0, 4.0, // row 1\n            5.0, 6.0, // row 2\n        ];\n\n        let mut c = vec![TropicalMaxPlus::tropical_zero(); m * n];\n\n        unsafe {\n            tropical_gemm_portable::\u003cTropicalMaxPlus\u003cf64\u003e\u003e(\n                m,\n                n,\n                k,\n                a.as_ptr(),\n                2,\n                Transpose::Trans, // lda=2 for column-major 3x2\n                b.as_ptr(),\n                2,\n                Transpose::NoTrans,\n                c.as_mut_ptr(),\n                n,\n            );\n        }\n\n        // A^T = [[1, 2, 3], [4, 5, 6]]\n        // B = [[1, 2], [3, 4], [5, 6]]\n        // C[0,0] = max(1+1, 2+3, 3+5) = 8\n        assert_eq!(c[0].0, 8.0);\n        // C[0,1] = max(1+2, 2+4, 3+6) = 9\n        assert_eq!(c[1].0, 9.0);\n        // C[1,0] = max(4+1, 5+3, 6+5) = 11\n        assert_eq!(c[2].0, 11.0);\n        // C[1,1] = max(4+2, 5+4, 6+6) = 12\n        assert_eq!(c[3].0, 12.0);\n    }\n\n    #[test]\n    fn test_gemm_trans_b() {\n        // Test with B transposed\n        // B is stored column-major (2x3), so B^T is 3x2\n        let m = 2;\n        let n = 2;\n        let k = 3;\n\n        let a: [f64; 6] = [\n            1.0, 2.0, 3.0, // row 0\n            4.0, 5.0, 6.0, // row 1\n        ];\n\n        // B stored column-major: columns are [1,3,5], [2,4,6]\n        let b: [f64; 6] = [\n            1.0, 3.0, 5.0, // column 0 of B^T = row of B\n            2.0, 4.0, 6.0, // column 1 of B^T\n        ];\n\n        let mut c = vec![TropicalMaxPlus::tropical_zero(); m * n];\n\n        unsafe {\n            tropical_gemm_portable::\u003cTropicalMaxPlus\u003cf64\u003e\u003e(\n                m,\n                n,\n                k,\n                a.as_ptr(),\n                3,\n                Transpose::NoTrans,\n                b.as_ptr(),\n                3,\n                Transpose::Trans, // ldb=3 for column-major 2x3\n                c.as_mut_ptr(),\n                n,\n            );\n        }\n\n        // A = [[1, 2, 3], [4, 5, 6]]\n        // B^T = [[1, 2], [3, 4], [5, 6]]\n        // C[0,0] = max(1+1, 2+3, 3+5) = 8\n        assert_eq!(c[0].0, 8.0);\n        assert_eq!(c[1].0, 9.0);\n        assert_eq!(c[2].0, 11.0);\n        assert_eq!(c[3].0, 12.0);\n    }\n\n    #[test]\n    fn test_gemm_trans_both() {\n        // Test with both A and B transposed\n        let m = 2;\n        let n = 2;\n        let k = 3;\n\n        // A column-major (3x2), A^T is 2x3\n        let a: [f64; 6] = [1.0, 4.0, 2.0, 5.0, 3.0, 6.0];\n        // B column-major (2x3), B^T is 3x2\n        let b: [f64; 6] = [1.0, 3.0, 5.0, 2.0, 4.0, 6.0];\n\n        let mut c = vec![TropicalMaxPlus::tropical_zero(); m * n];\n\n        unsafe {\n            tropical_gemm_portable::\u003cTropicalMaxPlus\u003cf64\u003e\u003e(\n                m,\n                n,\n                k,\n                a.as_ptr(),\n                2,\n                Transpose::Trans,\n                b.as_ptr(),\n                3,\n                Transpose::Trans,\n                c.as_mut_ptr(),\n                n,\n            );\n        }\n\n        assert_eq!(c[0].0, 8.0);\n        assert_eq!(c[1].0, 9.0);\n        assert_eq!(c[2].0, 11.0);\n        assert_eq!(c[3].0, 12.0);\n    }\n\n    #[test]\n    fn test_gemm_empty_m() {\n        let m = 0;\n        let n = 2;\n        let k = 3;\n\n        let a: [f64; 0] = [];\n        let b: [f64; 6] = [1.0, 2.0, 3.0, 4.0, 5.0, 6.0];\n        let mut c: Vec\u003cTropicalMaxPlus\u003cf64\u003e\u003e = vec![];\n\n        unsafe {\n            tropical_gemm_portable::\u003cTropicalMaxPlus\u003cf64\u003e\u003e(\n                m,\n                n,\n                k,\n                a.as_ptr(),\n                3,\n                Transpose::NoTrans,\n                b.as_ptr(),\n                2,\n                Transpose::NoTrans,\n                c.as_mut_ptr(),\n                n,\n            );\n        }\n\n        // Should complete without panic\n        assert!(c.is_empty());\n    }\n\n    #[test]\n    fn test_gemm_empty_n() {\n        let m = 2;\n        let n = 0;\n        let k = 3;\n\n        let a: [f64; 6] = [1.0, 2.0, 3.0, 4.0, 5.0, 6.0];\n        let b: [f64; 0] = [];\n        let mut c: Vec\u003cTropicalMaxPlus\u003cf64\u003e\u003e = vec![];\n\n        unsafe {\n            tropical_gemm_portable::\u003cTropicalMaxPlus\u003cf64\u003e\u003e(\n                m,\n                n,\n                k,\n                a.as_ptr(),\n                3,\n                Transpose::NoTrans,\n                b.as_ptr(),\n                2,\n                Transpose::NoTrans,\n                c.as_mut_ptr(),\n                n,\n            );\n        }\n\n        assert!(c.is_empty());\n    }\n\n    #[test]\n    fn test_gemm_empty_k() {\n        let m = 2;\n        let n = 2;\n        let k = 0;\n\n        let a: [f64; 0] = [];\n        let b: [f64; 0] = [];\n        let mut c = vec![TropicalMaxPlus::tropical_zero(); m * n];\n\n        unsafe {\n            tropical_gemm_portable::\u003cTropicalMaxPlus\u003cf64\u003e\u003e(\n                m,\n                n,\n                k,\n                a.as_ptr(),\n                0,\n                Transpose::NoTrans,\n                b.as_ptr(),\n                2,\n                Transpose::NoTrans,\n                c.as_mut_ptr(),\n                n,\n            );\n        }\n\n        // C should remain initialized to tropical_zero\n        for val in \u0026c {\n            assert!(val.0.is_infinite() \u0026\u0026 val.0 \u003c 0.0);\n        }\n    }\n\n    #[test]\n    fn test_gemm_with_argmax_empty_k() {\n        let m = 2;\n        let n = 2;\n        let k = 0;\n\n        let a: [f64; 0] = [];\n        let b: [f64; 0] = [];\n        let mut result: GemmWithArgmax\u003cTropicalMaxPlus\u003cf64\u003e\u003e = GemmWithArgmax::new(m, n);\n\n        unsafe {\n            tropical_gemm_with_argmax_portable::\u003cTropicalMaxPlus\u003cf64\u003e\u003e(\n                m,\n                n,\n                k,\n                a.as_ptr(),\n                0,\n                Transpose::NoTrans,\n                b.as_ptr(),\n                2,\n                Transpose::NoTrans,\n                \u0026mut result,\n            );\n        }\n\n        // Should complete without panic\n        assert_eq!(result.m, 2);\n        assert_eq!(result.n, 2);\n    }\n\n    #[test]\n    fn test_gemm_with_argmax_trans_a() {\n        let m = 2;\n        let n = 2;\n        let k = 3;\n\n        let a: [f64; 6] = [1.0, 4.0, 2.0, 5.0, 3.0, 6.0];\n        let b: [f64; 6] = [1.0, 2.0, 3.0, 4.0, 5.0, 6.0];\n\n        let mut result: GemmWithArgmax\u003cTropicalMaxPlus\u003cf64\u003e\u003e = GemmWithArgmax::new(m, n);\n\n        unsafe {\n            tropical_gemm_with_argmax_portable::\u003cTropicalMaxPlus\u003cf64\u003e\u003e(\n                m,\n                n,\n                k,\n                a.as_ptr(),\n                2,\n                Transpose::Trans,\n                b.as_ptr(),\n                2,\n                Transpose::NoTrans,\n                \u0026mut result,\n            );\n        }\n\n        assert_eq!(result.get(0, 0).0, 8.0);\n        assert_eq!(result.get_argmax(0, 0), 2);\n    }\n\n    #[test]\n    fn test_gemm_with_argmax_trans_b() {\n        let m = 2;\n        let n = 2;\n        let k = 3;\n\n        let a: [f64; 6] = [1.0, 2.0, 3.0, 4.0, 5.0, 6.0];\n        let b: [f64; 6] = [1.0, 3.0, 5.0, 2.0, 4.0, 6.0];\n\n        let mut result: GemmWithArgmax\u003cTropicalMaxPlus\u003cf64\u003e\u003e = GemmWithArgmax::new(m, n);\n\n        unsafe {\n            tropical_gemm_with_argmax_portable::\u003cTropicalMaxPlus\u003cf64\u003e\u003e(\n                m,\n                n,\n                k,\n                a.as_ptr(),\n                3,\n                Transpose::NoTrans,\n                b.as_ptr(),\n                3,\n                Transpose::Trans,\n                \u0026mut result,\n            );\n        }\n\n        assert_eq!(result.get(0, 0).0, 8.0);\n        assert_eq!(result.get_argmax(0, 0), 2);\n    }\n}\n","traces":[{"line":30,"address":[],"length":0,"stats":{"Line":7}},{"line":43,"address":[],"length":0,"stats":{"Line":14}},{"line":44,"address":[],"length":0,"stats":{"Line":14}},{"line":47,"address":[],"length":0,"stats":{"Line":91}},{"line":55,"address":[],"length":0,"stats":{"Line":43}},{"line":70,"address":[],"length":0,"stats":{"Line":126}},{"line":71,"address":[],"length":0,"stats":{"Line":3}},{"line":75,"address":[],"length":0,"stats":{"Line":240}},{"line":76,"address":[],"length":0,"stats":{"Line":240}},{"line":80,"address":[],"length":0,"stats":{"Line":200}},{"line":82,"address":[],"length":0,"stats":{"Line":200}},{"line":85,"address":[],"length":0,"stats":{"Line":40}},{"line":86,"address":[],"length":0,"stats":{"Line":40}},{"line":87,"address":[],"length":0,"stats":{"Line":240}},{"line":88,"address":[],"length":0,"stats":{"Line":40}},{"line":89,"address":[],"length":0,"stats":{"Line":40}},{"line":90,"address":[],"length":0,"stats":{"Line":40}},{"line":91,"address":[],"length":0,"stats":{"Line":80}},{"line":92,"address":[],"length":0,"stats":{"Line":0}},{"line":96,"address":[],"length":0,"stats":{"Line":200}},{"line":99,"address":[],"length":0,"stats":{"Line":40}},{"line":100,"address":[],"length":0,"stats":{"Line":40}},{"line":101,"address":[],"length":0,"stats":{"Line":240}},{"line":102,"address":[],"length":0,"stats":{"Line":40}},{"line":103,"address":[],"length":0,"stats":{"Line":40}},{"line":104,"address":[],"length":0,"stats":{"Line":40}},{"line":105,"address":[],"length":0,"stats":{"Line":80}},{"line":106,"address":[],"length":0,"stats":{"Line":0}},{"line":110,"address":[],"length":0,"stats":{"Line":120}},{"line":111,"address":[],"length":0,"stats":{"Line":84}},{"line":112,"address":[],"length":0,"stats":{"Line":88}},{"line":113,"address":[],"length":0,"stats":{"Line":132}},{"line":116,"address":[],"length":0,"stats":{"Line":132}},{"line":117,"address":[],"length":0,"stats":{"Line":160}},{"line":118,"address":[],"length":0,"stats":{"Line":174}},{"line":119,"address":[],"length":0,"stats":{"Line":232}},{"line":122,"address":[],"length":0,"stats":{"Line":348}},{"line":123,"address":[],"length":0,"stats":{"Line":348}},{"line":124,"address":[],"length":0,"stats":{"Line":348}},{"line":126,"address":[],"length":0,"stats":{"Line":464}},{"line":140,"address":[],"length":0,"stats":{"Line":13}},{"line":152,"address":[],"length":0,"stats":{"Line":26}},{"line":153,"address":[],"length":0,"stats":{"Line":26}},{"line":156,"address":[],"length":0,"stats":{"Line":156}},{"line":164,"address":[],"length":0,"stats":{"Line":13}},{"line":181,"address":[],"length":0,"stats":{"Line":39}},{"line":182,"address":[],"length":0,"stats":{"Line":1}},{"line":185,"address":[],"length":0,"stats":{"Line":24}},{"line":186,"address":[],"length":0,"stats":{"Line":36}},{"line":189,"address":[],"length":0,"stats":{"Line":72}},{"line":190,"address":[],"length":0,"stats":{"Line":72}},{"line":193,"address":[],"length":0,"stats":{"Line":60}},{"line":194,"address":[],"length":0,"stats":{"Line":60}},{"line":196,"address":[],"length":0,"stats":{"Line":12}},{"line":197,"address":[],"length":0,"stats":{"Line":12}},{"line":198,"address":[],"length":0,"stats":{"Line":72}},{"line":199,"address":[],"length":0,"stats":{"Line":12}},{"line":200,"address":[],"length":0,"stats":{"Line":12}},{"line":201,"address":[],"length":0,"stats":{"Line":12}},{"line":202,"address":[],"length":0,"stats":{"Line":24}},{"line":203,"address":[],"length":0,"stats":{"Line":0}},{"line":206,"address":[],"length":0,"stats":{"Line":60}},{"line":208,"address":[],"length":0,"stats":{"Line":12}},{"line":209,"address":[],"length":0,"stats":{"Line":12}},{"line":210,"address":[],"length":0,"stats":{"Line":72}},{"line":211,"address":[],"length":0,"stats":{"Line":12}},{"line":212,"address":[],"length":0,"stats":{"Line":12}},{"line":213,"address":[],"length":0,"stats":{"Line":12}},{"line":214,"address":[],"length":0,"stats":{"Line":24}},{"line":215,"address":[],"length":0,"stats":{"Line":0}},{"line":218,"address":[],"length":0,"stats":{"Line":36}},{"line":219,"address":[],"length":0,"stats":{"Line":26}},{"line":220,"address":[],"length":0,"stats":{"Line":28}},{"line":221,"address":[],"length":0,"stats":{"Line":42}},{"line":223,"address":[],"length":0,"stats":{"Line":42}},{"line":224,"address":[],"length":0,"stats":{"Line":46}},{"line":225,"address":[],"length":0,"stats":{"Line":48}},{"line":226,"address":[],"length":0,"stats":{"Line":64}},{"line":228,"address":[],"length":0,"stats":{"Line":96}},{"line":229,"address":[],"length":0,"stats":{"Line":96}},{"line":230,"address":[],"length":0,"stats":{"Line":96}},{"line":231,"address":[],"length":0,"stats":{"Line":96}},{"line":233,"address":[],"length":0,"stats":{"Line":48}},{"line":234,"address":[],"length":0,"stats":{"Line":128}},{"line":245,"address":[],"length":0,"stats":{"Line":52}},{"line":252,"address":[],"length":0,"stats":{"Line":52}},{"line":253,"address":[],"length":0,"stats":{"Line":144}},{"line":254,"address":[],"length":0,"stats":{"Line":12}},{"line":260,"address":[],"length":0,"stats":{"Line":52}},{"line":267,"address":[],"length":0,"stats":{"Line":52}},{"line":268,"address":[],"length":0,"stats":{"Line":144}},{"line":269,"address":[],"length":0,"stats":{"Line":12}}],"covered":88,"coverable":92},{"path":["/","home","leo","rcode","cutropicalgemm","crates","tropical-gemm","src","core","kernel.rs"],"content":"use crate::types::{TropicalSemiring, TropicalWithArgmax};\n\n/// Trait for GEMM microkernels.\n///\n/// A microkernel computes a small block of C += A * B using register blocking.\n/// The dimensions mr x nr define the \"register tile\" that fits in CPU registers.\npub trait Microkernel\u003cT: TropicalSemiring\u003e {\n    /// Rows of the microkernel (typically 4-8 for f32).\n    const MR: usize;\n\n    /// Columns of the microkernel (typically 4-8 for f32).\n    const NR: usize;\n\n    /// Execute the microkernel.\n    ///\n    /// Computes C[0..mr, 0..nr] = A[0..mr, 0..k] ⊗ B[0..k, 0..nr]\n    /// where the result is combined with existing C values using tropical addition.\n    ///\n    /// # Safety\n    /// - `a` must point to at least `mr * k` elements (packed column-major)\n    /// - `b` must point to at least `k * nr` elements (packed row-major)\n    /// - `c` must point to at least `mr * ldc` elements\n    /// - `mr \u003c= Self::MR` and `nr \u003c= Self::NR`\n    unsafe fn execute(\n        \u0026self,\n        mr: usize,\n        nr: usize,\n        k: usize,\n        a: *const T::Scalar,\n        b: *const T::Scalar,\n        c: *mut T,\n        ldc: usize,\n    );\n}\n\n/// Trait for microkernels that track argmax during computation.\npub trait MicrokernelWithArgmax\u003cT: TropicalWithArgmax\u003cIndex = u32\u003e\u003e: Microkernel\u003cT\u003e {\n    /// Execute the microkernel with argmax tracking.\n    ///\n    /// Same as `execute`, but also fills `argmax` with the k-index that\n    /// produced each optimal C[i,j] value.\n    ///\n    /// # Safety\n    /// Same requirements as `execute`, plus:\n    /// - `argmax` must point to at least `mr * ldc` elements\n    unsafe fn execute_with_argmax(\n        \u0026self,\n        mr: usize,\n        nr: usize,\n        k: usize,\n        k_offset: usize,\n        a: *const T::Scalar,\n        b: *const T::Scalar,\n        c: *mut T,\n        argmax: *mut u32,\n        ldc: usize,\n    );\n}\n\n/// Portable (non-SIMD) microkernel implementation.\n#[derive(Default, Clone, Copy)]\npub struct PortableMicrokernel;\n\n/// Constants for PortableMicrokernel\nimpl PortableMicrokernel {\n    /// Microkernel row dimension.\n    pub const MR: usize = 4;\n    /// Microkernel column dimension.\n    pub const NR: usize = 4;\n}\n\nimpl\u003cT: TropicalSemiring\u003e Microkernel\u003cT\u003e for PortableMicrokernel {\n    const MR: usize = 4;\n    const NR: usize = 4;\n\n    unsafe fn execute(\n        \u0026self,\n        mr: usize,\n        nr: usize,\n        k: usize,\n        a: *const T::Scalar,\n        b: *const T::Scalar,\n        c: *mut T,\n        ldc: usize,\n    ) {\n        const MR: usize = 4;\n        const NR: usize = 4;\n\n        // Initialize accumulators from C\n        let mut acc = [[T::tropical_zero(); NR]; MR];\n        for i in 0..mr {\n            for j in 0..nr {\n                acc[i][j] = *c.add(i * ldc + j);\n            }\n        }\n\n        // Main loop\n        for p in 0..k {\n            for i in 0..mr {\n                let a_val = T::from_scalar(*a.add(p * MR + i));\n                for j in 0..nr {\n                    let b_val = T::from_scalar(*b.add(p * NR + j));\n                    let product = a_val.tropical_mul(b_val);\n                    acc[i][j] = acc[i][j].tropical_add(product);\n                }\n            }\n        }\n\n        // Write back\n        for i in 0..mr {\n            for j in 0..nr {\n                *c.add(i * ldc + j) = acc[i][j];\n            }\n        }\n    }\n}\n\nimpl\u003cT: TropicalWithArgmax\u003cIndex = u32\u003e\u003e MicrokernelWithArgmax\u003cT\u003e for PortableMicrokernel {\n    unsafe fn execute_with_argmax(\n        \u0026self,\n        mr: usize,\n        nr: usize,\n        k: usize,\n        k_offset: usize,\n        a: *const T::Scalar,\n        b: *const T::Scalar,\n        c: *mut T,\n        argmax: *mut u32,\n        ldc: usize,\n    ) {\n        const MR: usize = 4;\n        const NR: usize = 4;\n\n        // Initialize accumulators from C and existing argmax\n        let mut acc = [[T::tropical_zero(); NR]; MR];\n        let mut idx = [[0u32; NR]; MR];\n        for i in 0..mr {\n            for j in 0..nr {\n                acc[i][j] = *c.add(i * ldc + j);\n                idx[i][j] = *argmax.add(i * ldc + j);\n            }\n        }\n\n        // Main loop with argmax tracking\n        for p in 0..k {\n            let current_k = (k_offset + p) as u32;\n            for i in 0..mr {\n                let a_val = T::from_scalar(*a.add(p * MR + i));\n                for j in 0..nr {\n                    let b_val = T::from_scalar(*b.add(p * NR + j));\n                    let product = a_val.tropical_mul(b_val);\n                    let (new_acc, new_idx) =\n                        acc[i][j].tropical_add_argmax(idx[i][j], product, current_k);\n                    acc[i][j] = new_acc;\n                    idx[i][j] = new_idx;\n                }\n            }\n        }\n\n        // Write back\n        for i in 0..mr {\n            for j in 0..nr {\n                *c.add(i * ldc + j) = acc[i][j];\n                *argmax.add(i * ldc + j) = idx[i][j];\n            }\n        }\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use crate::types::TropicalMaxPlus;\n\n    #[test]\n    fn test_portable_kernel() {\n        let kernel = PortableMicrokernel;\n        let mr = 2;\n        let nr = 2;\n        let k = 3;\n\n        // A: 2x3 matrix (packed column-major in MR chunks)\n        // A = [[1, 2, 3],\n        //      [4, 5, 6]]\n        let a: [f64; 12] = [1.0, 4.0, 0.0, 0.0, 2.0, 5.0, 0.0, 0.0, 3.0, 6.0, 0.0, 0.0];\n\n        // B: 3x2 matrix (packed row-major in NR chunks)\n        // B = [[1, 2],\n        //      [3, 4],\n        //      [5, 6]]\n        let b: [f64; 12] = [1.0, 2.0, 0.0, 0.0, 3.0, 4.0, 0.0, 0.0, 5.0, 6.0, 0.0, 0.0];\n\n        // C: 2x2 output\n        let mut c = [TropicalMaxPlus::tropical_zero(); 4];\n        let ldc = 2;\n\n        unsafe {\n            kernel.execute(mr, nr, k, a.as_ptr(), b.as_ptr(), c.as_mut_ptr(), ldc);\n        }\n\n        // C[0,0] = max(A[0,0]+B[0,0], A[0,1]+B[1,0], A[0,2]+B[2,0])\n        //        = max(1+1, 2+3, 3+5) = max(2, 5, 8) = 8\n        assert_eq!(c[0].0, 8.0);\n\n        // C[0,1] = max(1+2, 2+4, 3+6) = max(3, 6, 9) = 9\n        assert_eq!(c[1].0, 9.0);\n\n        // C[1,0] = max(4+1, 5+3, 6+5) = max(5, 8, 11) = 11\n        assert_eq!(c[2].0, 11.0);\n\n        // C[1,1] = max(4+2, 5+4, 6+6) = max(6, 9, 12) = 12\n        assert_eq!(c[3].0, 12.0);\n    }\n\n    #[test]\n    fn test_portable_kernel_minplus() {\n        use crate::types::TropicalMinPlus;\n\n        let kernel = PortableMicrokernel;\n        let mr = 2;\n        let nr = 2;\n        let k = 3;\n\n        let a: [f64; 12] = [1.0, 4.0, 0.0, 0.0, 2.0, 5.0, 0.0, 0.0, 3.0, 6.0, 0.0, 0.0];\n        let b: [f64; 12] = [1.0, 2.0, 0.0, 0.0, 3.0, 4.0, 0.0, 0.0, 5.0, 6.0, 0.0, 0.0];\n\n        let mut c = [TropicalMinPlus::tropical_zero(); 4];\n        let ldc = 2;\n\n        unsafe {\n            kernel.execute(mr, nr, k, a.as_ptr(), b.as_ptr(), c.as_mut_ptr(), ldc);\n        }\n\n        // C[0,0] = min(1+1, 2+3, 3+5) = min(2, 5, 8) = 2\n        assert_eq!(c[0].0, 2.0);\n        // C[0,1] = min(1+2, 2+4, 3+6) = min(3, 6, 9) = 3\n        assert_eq!(c[1].0, 3.0);\n        // C[1,0] = min(4+1, 5+3, 6+5) = min(5, 8, 11) = 5\n        assert_eq!(c[2].0, 5.0);\n        // C[1,1] = min(4+2, 5+4, 6+6) = min(6, 9, 12) = 6\n        assert_eq!(c[3].0, 6.0);\n    }\n\n    #[test]\n    fn test_portable_kernel_maxmul() {\n        use crate::types::TropicalMaxMul;\n\n        let kernel = PortableMicrokernel;\n        let mr = 2;\n        let nr = 2;\n        let k = 2;\n\n        // A: [[2, 4], [3, 5]]\n        let a: [f64; 8] = [2.0, 3.0, 0.0, 0.0, 4.0, 5.0, 0.0, 0.0];\n        // B: [[1, 2], [3, 4]]\n        let b: [f64; 8] = [1.0, 2.0, 0.0, 0.0, 3.0, 4.0, 0.0, 0.0];\n\n        let mut c = [TropicalMaxMul::tropical_zero(); 4];\n        let ldc = 2;\n\n        unsafe {\n            kernel.execute(mr, nr, k, a.as_ptr(), b.as_ptr(), c.as_mut_ptr(), ldc);\n        }\n\n        // C[0,0] = max(2*1, 4*3) = max(2, 12) = 12\n        assert_eq!(c[0].0, 12.0);\n        // C[0,1] = max(2*2, 4*4) = max(4, 16) = 16\n        assert_eq!(c[1].0, 16.0);\n        // C[1,0] = max(3*1, 5*3) = max(3, 15) = 15\n        assert_eq!(c[2].0, 15.0);\n        // C[1,1] = max(3*2, 5*4) = max(6, 20) = 20\n        assert_eq!(c[3].0, 20.0);\n    }\n\n    #[test]\n    fn test_portable_kernel_with_argmax() {\n        let kernel = PortableMicrokernel;\n        let mr = 2;\n        let nr = 2;\n        let k = 3;\n\n        let a: [f64; 12] = [1.0, 4.0, 0.0, 0.0, 2.0, 5.0, 0.0, 0.0, 3.0, 6.0, 0.0, 0.0];\n        let b: [f64; 12] = [1.0, 2.0, 0.0, 0.0, 3.0, 4.0, 0.0, 0.0, 5.0, 6.0, 0.0, 0.0];\n\n        let mut c = [TropicalMaxPlus::tropical_zero(); 4];\n        let mut argmax = [0u32; 4];\n        let ldc = 2;\n        let k_offset = 0;\n\n        unsafe {\n            kernel.execute_with_argmax(\n                mr,\n                nr,\n                k,\n                k_offset,\n                a.as_ptr(),\n                b.as_ptr(),\n                c.as_mut_ptr(),\n                argmax.as_mut_ptr(),\n                ldc,\n            );\n        }\n\n        // C[0,0] = max(1+1, 2+3, 3+5) = 8 at k=2\n        assert_eq!(c[0].0, 8.0);\n        assert_eq!(argmax[0], 2);\n\n        // C[0,1] = max(1+2, 2+4, 3+6) = 9 at k=2\n        assert_eq!(c[1].0, 9.0);\n        assert_eq!(argmax[1], 2);\n\n        // C[1,0] = max(4+1, 5+3, 6+5) = 11 at k=2\n        assert_eq!(c[2].0, 11.0);\n        assert_eq!(argmax[2], 2);\n\n        // C[1,1] = max(4+2, 5+4, 6+6) = 12 at k=2\n        assert_eq!(c[3].0, 12.0);\n        assert_eq!(argmax[3], 2);\n    }\n\n    #[test]\n    fn test_portable_kernel_with_argmax_offset() {\n        // Test that k_offset is correctly applied\n        let kernel = PortableMicrokernel;\n        let mr = 2;\n        let nr = 2;\n        let k = 2;\n\n        let a: [f64; 8] = [1.0, 2.0, 0.0, 0.0, 10.0, 20.0, 0.0, 0.0];\n        let b: [f64; 8] = [1.0, 1.0, 0.0, 0.0, 1.0, 1.0, 0.0, 0.0];\n\n        let mut c = [TropicalMaxPlus::tropical_zero(); 4];\n        let mut argmax = [0u32; 4];\n        let ldc = 2;\n        let k_offset = 5; // Start from global k=5\n\n        unsafe {\n            kernel.execute_with_argmax(\n                mr,\n                nr,\n                k,\n                k_offset,\n                a.as_ptr(),\n                b.as_ptr(),\n                c.as_mut_ptr(),\n                argmax.as_mut_ptr(),\n                ldc,\n            );\n        }\n\n        // A[:,1] has larger values, so k=1 (global k=6) should win\n        // C[0,0] = max(1+1, 10+1) = 11 at local k=1, global k=6\n        assert_eq!(c[0].0, 11.0);\n        assert_eq!(argmax[0], 6); // k_offset + 1\n\n        // C[1,0] = max(2+1, 20+1) = 21 at local k=1, global k=6\n        assert_eq!(c[2].0, 21.0);\n        assert_eq!(argmax[2], 6);\n    }\n\n    #[test]\n    fn test_portable_kernel_f32() {\n        let kernel = PortableMicrokernel;\n        let mr = 2;\n        let nr = 2;\n        let k = 2;\n\n        let a: [f32; 8] = [1.0, 2.0, 0.0, 0.0, 3.0, 4.0, 0.0, 0.0];\n        let b: [f32; 8] = [1.0, 2.0, 0.0, 0.0, 3.0, 4.0, 0.0, 0.0];\n\n        let mut c = [TropicalMaxPlus::tropical_zero(); 4];\n        let ldc = 2;\n\n        unsafe {\n            kernel.execute(mr, nr, k, a.as_ptr(), b.as_ptr(), c.as_mut_ptr(), ldc);\n        }\n\n        // C[0,0] = max(1+1, 3+3) = 6\n        assert!((c[0].0 - 6.0).abs() \u003c 1e-6);\n        // C[0,1] = max(1+2, 3+4) = 7\n        assert!((c[1].0 - 7.0).abs() \u003c 1e-6);\n    }\n}\n","traces":[{"line":76,"address":[],"length":0,"stats":{"Line":24}},{"line":90,"address":[],"length":0,"stats":{"Line":48}},{"line":91,"address":[],"length":0,"stats":{"Line":72}},{"line":92,"address":[],"length":0,"stats":{"Line":240}},{"line":93,"address":[],"length":0,"stats":{"Line":384}},{"line":98,"address":[],"length":0,"stats":{"Line":84}},{"line":99,"address":[],"length":0,"stats":{"Line":180}},{"line":100,"address":[],"length":0,"stats":{"Line":600}},{"line":101,"address":[],"length":0,"stats":{"Line":600}},{"line":102,"address":[],"length":0,"stats":{"Line":1440}},{"line":103,"address":[],"length":0,"stats":{"Line":1200}},{"line":104,"address":[],"length":0,"stats":{"Line":720}},{"line":110,"address":[],"length":0,"stats":{"Line":72}},{"line":111,"address":[],"length":0,"stats":{"Line":240}},{"line":112,"address":[],"length":0,"stats":{"Line":384}},{"line":119,"address":[],"length":0,"stats":{"Line":19}},{"line":135,"address":[],"length":0,"stats":{"Line":38}},{"line":136,"address":[],"length":0,"stats":{"Line":38}},{"line":137,"address":[],"length":0,"stats":{"Line":67}},{"line":138,"address":[],"length":0,"stats":{"Line":310}},{"line":139,"address":[],"length":0,"stats":{"Line":655}},{"line":140,"address":[],"length":0,"stats":{"Line":524}},{"line":145,"address":[],"length":0,"stats":{"Line":95}},{"line":146,"address":[],"length":0,"stats":{"Line":152}},{"line":147,"address":[],"length":0,"stats":{"Line":300}},{"line":148,"address":[],"length":0,"stats":{"Line":1120}},{"line":149,"address":[],"length":0,"stats":{"Line":1656}},{"line":150,"address":[],"length":0,"stats":{"Line":4296}},{"line":151,"address":[],"length":0,"stats":{"Line":3580}},{"line":152,"address":[],"length":0,"stats":{"Line":2148}},{"line":153,"address":[],"length":0,"stats":{"Line":3580}},{"line":154,"address":[],"length":0,"stats":{"Line":1432}},{"line":155,"address":[],"length":0,"stats":{"Line":716}},{"line":161,"address":[],"length":0,"stats":{"Line":67}},{"line":162,"address":[],"length":0,"stats":{"Line":310}},{"line":163,"address":[],"length":0,"stats":{"Line":655}},{"line":164,"address":[],"length":0,"stats":{"Line":524}}],"covered":37,"coverable":37},{"path":["/","home","leo","rcode","cutropicalgemm","crates","tropical-gemm","src","core","mod.rs"],"content":"//! Core tropical GEMM algorithms.\n//!\n//! This module provides the portable implementation of tropical\n//! matrix multiplication using BLIS-style blocking for cache efficiency.\n\nmod argmax;\nmod gemm;\nmod kernel;\nmod packing;\nmod tiling;\n\npub use argmax::GemmWithArgmax;\npub use gemm::{\n    tropical_gemm_inner, tropical_gemm_portable, tropical_gemm_with_argmax_inner,\n    tropical_gemm_with_argmax_portable,\n};\npub use kernel::{Microkernel, MicrokernelWithArgmax, PortableMicrokernel};\npub use packing::{pack_a, pack_b, packed_a_size, packed_b_size, Layout, Transpose};\npub use tiling::{BlockIterator, TilingParams};\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","leo","rcode","cutropicalgemm","crates","tropical-gemm","src","core","packing.rs"],"content":"use crate::types::TropicalScalar;\n\n/// Matrix layout enumeration.\n#[derive(Debug, Clone, Copy, PartialEq, Eq)]\npub enum Layout {\n    /// Row-major layout (C-style).\n    RowMajor,\n    /// Column-major layout (Fortran-style).\n    ColMajor,\n}\n\n/// Transpose specification.\n#[derive(Debug, Clone, Copy, PartialEq, Eq)]\npub enum Transpose {\n    /// No transpose.\n    NoTrans,\n    /// Transpose the matrix.\n    Trans,\n}\n\n/// Pack a panel of matrix A into a contiguous buffer.\n///\n/// The packed format stores `mc` rows in column-major order within\n/// blocks of `mr` rows. This improves cache locality during the\n/// microkernel computation.\n///\n/// # Layout\n/// For A with dimensions m×k:\n/// ```text\n/// Original A (row-major, m=6, k=4, mr=4):\n/// [ a00 a01 a02 a03 ]\n/// [ a10 a11 a12 a13 ]\n/// [ a20 a21 a22 a23 ]\n/// [ a30 a31 a32 a33 ]\n/// [ a40 a41 a42 a43 ]\n/// [ a50 a51 a52 a53 ]\n///\n/// Packed (column-major within mr×k blocks):\n/// Block 0 (rows 0-3): a00 a10 a20 a30 | a01 a11 a21 a31 | a02 a12 a22 a32 | a03 a13 a23 a33\n/// Block 1 (rows 4-5): a40 a50 0   0   | a41 a51 0   0   | a42 a52 0   0   | a43 a53 0   0\n/// ```\n///\n/// # Safety\n/// - `a` must point to valid memory for at least `m * lda` elements\n/// - `packed` must have capacity for at least `((m + mr - 1) / mr) * mr * k` elements\npub unsafe fn pack_a\u003cT: TropicalScalar\u003e(\n    m: usize,\n    k: usize,\n    a: *const T,\n    lda: usize,\n    layout: Layout,\n    trans: Transpose,\n    packed: *mut T,\n    mr: usize,\n) {\n    let zero = T::scalar_zero();\n\n    let mut packed_idx = 0;\n\n    // Process full mr×k blocks\n    let m_blocks = m / mr;\n    let m_rem = m % mr;\n\n    for block in 0..m_blocks {\n        let row_start = block * mr;\n        for col in 0..k {\n            for row_offset in 0..mr {\n                let row = row_start + row_offset;\n                let val = get_element(a, row, col, lda, layout, trans);\n                *packed.add(packed_idx) = val;\n                packed_idx += 1;\n            }\n        }\n    }\n\n    // Process remaining rows (if any)\n    if m_rem \u003e 0 {\n        let row_start = m_blocks * mr;\n        for col in 0..k {\n            for row_offset in 0..mr {\n                let row = row_start + row_offset;\n                let val = if row \u003c m {\n                    get_element(a, row, col, lda, layout, trans)\n                } else {\n                    zero\n                };\n                *packed.add(packed_idx) = val;\n                packed_idx += 1;\n            }\n        }\n    }\n}\n\n/// Pack a panel of matrix B into a contiguous buffer.\n///\n/// The packed format stores `nc` columns in row-major order within\n/// blocks of `nr` columns.\n///\n/// # Layout\n/// For B with dimensions k×n:\n/// ```text\n/// Original B (row-major, k=3, n=6, nr=4):\n/// [ b00 b01 b02 b03 b04 b05 ]\n/// [ b10 b11 b12 b13 b14 b15 ]\n/// [ b20 b21 b22 b23 b24 b25 ]\n///\n/// Packed (row-major within k×nr blocks):\n/// Block 0 (cols 0-3): b00 b01 b02 b03 | b10 b11 b12 b13 | b20 b21 b22 b23\n/// Block 1 (cols 4-5): b04 b05 0   0   | b14 b15 0   0   | b24 b25 0   0\n/// ```\n///\n/// # Safety\n/// - `b` must point to valid memory for at least `k * ldb` or `ldb * n` elements\n/// - `packed` must have capacity for at least `((n + nr - 1) / nr) * nr * k` elements\npub unsafe fn pack_b\u003cT: TropicalScalar\u003e(\n    k: usize,\n    n: usize,\n    b: *const T,\n    ldb: usize,\n    layout: Layout,\n    trans: Transpose,\n    packed: *mut T,\n    nr: usize,\n) {\n    let zero = T::scalar_zero();\n\n    let mut packed_idx = 0;\n\n    // Process full k×nr blocks\n    let n_blocks = n / nr;\n    let n_rem = n % nr;\n\n    for block in 0..n_blocks {\n        let col_start = block * nr;\n        for row in 0..k {\n            for col_offset in 0..nr {\n                let col = col_start + col_offset;\n                let val = get_element(b, row, col, ldb, layout, trans);\n                *packed.add(packed_idx) = val;\n                packed_idx += 1;\n            }\n        }\n    }\n\n    // Process remaining columns (if any)\n    if n_rem \u003e 0 {\n        let col_start = n_blocks * nr;\n        for row in 0..k {\n            for col_offset in 0..nr {\n                let col = col_start + col_offset;\n                let val = if col \u003c n {\n                    get_element(b, row, col, ldb, layout, trans)\n                } else {\n                    zero\n                };\n                *packed.add(packed_idx) = val;\n                packed_idx += 1;\n            }\n        }\n    }\n}\n\n/// Get element from matrix considering layout and transpose.\n#[inline(always)]\nunsafe fn get_element\u003cT: Copy\u003e(\n    ptr: *const T,\n    row: usize,\n    col: usize,\n    ld: usize,\n    layout: Layout,\n    trans: Transpose,\n) -\u003e T {\n    let (actual_row, actual_col) = match trans {\n        Transpose::NoTrans =\u003e (row, col),\n        Transpose::Trans =\u003e (col, row),\n    };\n\n    let idx = match layout {\n        Layout::RowMajor =\u003e actual_row * ld + actual_col,\n        Layout::ColMajor =\u003e actual_col * ld + actual_row,\n    };\n\n    *ptr.add(idx)\n}\n\n/// Calculate packed buffer size for A.\n#[inline]\npub fn packed_a_size(m: usize, k: usize, mr: usize) -\u003e usize {\n    let m_padded = m.div_ceil(mr) * mr;\n    m_padded * k\n}\n\n/// Calculate packed buffer size for B.\n#[inline]\npub fn packed_b_size(k: usize, n: usize, nr: usize) -\u003e usize {\n    let n_padded = n.div_ceil(nr) * nr;\n    k * n_padded\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_pack_a_row_major() {\n        let a: [f64; 6] = [\n            1.0, 2.0, 3.0, // row 0\n            4.0, 5.0, 6.0, // row 1\n        ];\n        let m = 2;\n        let k = 3;\n        let mr = 4;\n        let lda = 3;\n\n        let mut packed = vec![0.0f64; packed_a_size(m, k, mr)];\n\n        unsafe {\n            pack_a(\n                m,\n                k,\n                a.as_ptr(),\n                lda,\n                Layout::RowMajor,\n                Transpose::NoTrans,\n                packed.as_mut_ptr(),\n                mr,\n            );\n        }\n\n        // Expected: column 0: [1,4,0,0], column 1: [2,5,0,0], column 2: [3,6,0,0]\n        assert_eq!(packed[0], 1.0); // a[0,0]\n        assert_eq!(packed[1], 4.0); // a[1,0]\n        assert_eq!(packed[2], 0.0); // padding\n        assert_eq!(packed[3], 0.0); // padding\n        assert_eq!(packed[4], 2.0); // a[0,1]\n        assert_eq!(packed[5], 5.0); // a[1,1]\n    }\n\n    #[test]\n    fn test_pack_a_col_major() {\n        // Column-major: columns are stored contiguously\n        // Matrix: [[1, 2, 3], [4, 5, 6]]\n        // Col-major storage: [1, 4, 2, 5, 3, 6]\n        let a: [f64; 6] = [1.0, 4.0, 2.0, 5.0, 3.0, 6.0];\n        let m = 2;\n        let k = 3;\n        let mr = 4;\n        let lda = 2; // Leading dimension for col-major\n\n        let mut packed = vec![0.0f64; packed_a_size(m, k, mr)];\n\n        unsafe {\n            pack_a(\n                m,\n                k,\n                a.as_ptr(),\n                lda,\n                Layout::ColMajor,\n                Transpose::NoTrans,\n                packed.as_mut_ptr(),\n                mr,\n            );\n        }\n\n        // Same result as row-major since we're extracting the same logical matrix\n        assert_eq!(packed[0], 1.0); // a[0,0]\n        assert_eq!(packed[1], 4.0); // a[1,0]\n        assert_eq!(packed[4], 2.0); // a[0,1]\n        assert_eq!(packed[5], 5.0); // a[1,1]\n    }\n\n    #[test]\n    fn test_pack_b_row_major() {\n        let b: [f64; 6] = [\n            1.0, 2.0, // row 0\n            3.0, 4.0, // row 1\n            5.0, 6.0, // row 2\n        ];\n        let k = 3;\n        let n = 2;\n        let nr = 4;\n        let ldb = 2;\n\n        let mut packed = vec![0.0f64; packed_b_size(k, n, nr)];\n\n        unsafe {\n            pack_b(\n                k,\n                n,\n                b.as_ptr(),\n                ldb,\n                Layout::RowMajor,\n                Transpose::NoTrans,\n                packed.as_mut_ptr(),\n                nr,\n            );\n        }\n\n        // Expected: row 0: [1,2,0,0], row 1: [3,4,0,0], row 2: [5,6,0,0]\n        assert_eq!(packed[0], 1.0); // b[0,0]\n        assert_eq!(packed[1], 2.0); // b[0,1]\n        assert_eq!(packed[2], 0.0); // padding\n        assert_eq!(packed[3], 0.0); // padding\n        assert_eq!(packed[4], 3.0); // b[1,0]\n        assert_eq!(packed[5], 4.0); // b[1,1]\n    }\n\n    #[test]\n    fn test_pack_b_col_major() {\n        // Column-major: columns are stored contiguously\n        // Matrix B (k=3, n=2): [[1, 2], [3, 4], [5, 6]]\n        // Col-major storage: [1, 3, 5, 2, 4, 6]\n        let b: [f64; 6] = [1.0, 3.0, 5.0, 2.0, 4.0, 6.0];\n        let k = 3;\n        let n = 2;\n        let nr = 4;\n        let ldb = 3; // Leading dimension for col-major (number of rows)\n\n        let mut packed = vec![0.0f64; packed_b_size(k, n, nr)];\n\n        unsafe {\n            pack_b(\n                k,\n                n,\n                b.as_ptr(),\n                ldb,\n                Layout::ColMajor,\n                Transpose::NoTrans,\n                packed.as_mut_ptr(),\n                nr,\n            );\n        }\n\n        // Expected: same logical values as row-major\n        assert_eq!(packed[0], 1.0); // b[0,0]\n        assert_eq!(packed[1], 2.0); // b[0,1]\n        assert_eq!(packed[4], 3.0); // b[1,0]\n        assert_eq!(packed[5], 4.0); // b[1,1]\n    }\n\n    #[test]\n    fn test_pack_a_with_transpose() {\n        // Test packing with transpose\n        let a: [f64; 6] = [\n            1.0, 2.0, // row 0 (becomes col 0 after trans)\n            3.0, 4.0, // row 1\n            5.0, 6.0, // row 2\n        ];\n        let m = 2; // After transpose: original 2 columns become 2 rows\n        let k = 3; // After transpose: original 3 rows become 3 cols\n        let mr = 4;\n        let lda = 2;\n\n        let mut packed = vec![0.0f64; packed_a_size(m, k, mr)];\n\n        unsafe {\n            pack_a(\n                m,\n                k,\n                a.as_ptr(),\n                lda,\n                Layout::RowMajor,\n                Transpose::Trans,\n                packed.as_mut_ptr(),\n                mr,\n            );\n        }\n\n        // A^T = [[1, 3, 5], [2, 4, 6]]\n        assert_eq!(packed[0], 1.0); // a^T[0,0]\n        assert_eq!(packed[1], 2.0); // a^T[1,0]\n        assert_eq!(packed[4], 3.0); // a^T[0,1]\n        assert_eq!(packed[5], 4.0); // a^T[1,1]\n    }\n\n    #[test]\n    fn test_pack_b_with_transpose() {\n        // Test packing B with transpose\n        let b: [f64; 6] = [\n            1.0, 2.0, 3.0, // row 0\n            4.0, 5.0, 6.0, // row 1\n        ];\n        let k = 3; // After transpose: original 3 cols become 3 rows\n        let n = 2; // After transpose: original 2 rows become 2 cols\n        let nr = 4;\n        let ldb = 3;\n\n        let mut packed = vec![0.0f64; packed_b_size(k, n, nr)];\n\n        unsafe {\n            pack_b(\n                k,\n                n,\n                b.as_ptr(),\n                ldb,\n                Layout::RowMajor,\n                Transpose::Trans,\n                packed.as_mut_ptr(),\n                nr,\n            );\n        }\n\n        // B^T = [[1, 4], [2, 5], [3, 6]]\n        assert_eq!(packed[0], 1.0); // b^T[0,0]\n        assert_eq!(packed[1], 4.0); // b^T[0,1]\n        assert_eq!(packed[4], 2.0); // b^T[1,0]\n        assert_eq!(packed[5], 5.0); // b^T[1,1]\n    }\n\n    #[test]\n    fn test_pack_a_exact_mr() {\n        // Test when m is exactly divisible by mr (no remainder path)\n        let a: [f64; 12] = [\n            1.0, 2.0, 3.0, // row 0\n            4.0, 5.0, 6.0, // row 1\n            7.0, 8.0, 9.0, // row 2\n            10.0, 11.0, 12.0, // row 3\n        ];\n        let m = 4;\n        let k = 3;\n        let mr = 4;\n        let lda = 3;\n\n        let mut packed = vec![0.0f64; packed_a_size(m, k, mr)];\n\n        unsafe {\n            pack_a(\n                m,\n                k,\n                a.as_ptr(),\n                lda,\n                Layout::RowMajor,\n                Transpose::NoTrans,\n                packed.as_mut_ptr(),\n                mr,\n            );\n        }\n\n        // No padding needed\n        assert_eq!(packed[0], 1.0);\n        assert_eq!(packed[1], 4.0);\n        assert_eq!(packed[2], 7.0);\n        assert_eq!(packed[3], 10.0);\n    }\n\n    #[test]\n    fn test_pack_b_exact_nr() {\n        // Test when n is exactly divisible by nr (no remainder path)\n        let b: [f64; 12] = [\n            1.0, 2.0, 3.0, 4.0, // row 0\n            5.0, 6.0, 7.0, 8.0, // row 1\n            9.0, 10.0, 11.0, 12.0, // row 2\n        ];\n        let k = 3;\n        let n = 4;\n        let nr = 4;\n        let ldb = 4;\n\n        let mut packed = vec![0.0f64; packed_b_size(k, n, nr)];\n\n        unsafe {\n            pack_b(\n                k,\n                n,\n                b.as_ptr(),\n                ldb,\n                Layout::RowMajor,\n                Transpose::NoTrans,\n                packed.as_mut_ptr(),\n                nr,\n            );\n        }\n\n        // No padding needed\n        assert_eq!(packed[0], 1.0);\n        assert_eq!(packed[1], 2.0);\n        assert_eq!(packed[2], 3.0);\n        assert_eq!(packed[3], 4.0);\n    }\n\n    #[test]\n    fn test_packed_a_size() {\n        // Exact multiple of mr\n        assert_eq!(packed_a_size(8, 10, 4), 8 * 10);\n        // Needs padding: m=5, mr=4 -\u003e m_padded=8\n        assert_eq!(packed_a_size(5, 10, 4), 8 * 10);\n        // m=1, mr=4 -\u003e m_padded=4\n        assert_eq!(packed_a_size(1, 10, 4), 4 * 10);\n    }\n\n    #[test]\n    fn test_packed_b_size() {\n        // Exact multiple of nr\n        assert_eq!(packed_b_size(10, 8, 4), 10 * 8);\n        // Needs padding: n=5, nr=4 -\u003e n_padded=8\n        assert_eq!(packed_b_size(10, 5, 4), 10 * 8);\n        // n=1, nr=4 -\u003e n_padded=4\n        assert_eq!(packed_b_size(10, 1, 4), 10 * 4);\n    }\n\n    #[test]\n    fn test_layout_debug() {\n        assert_eq!(format!(\"{:?}\", Layout::RowMajor), \"RowMajor\");\n        assert_eq!(format!(\"{:?}\", Layout::ColMajor), \"ColMajor\");\n    }\n\n    #[test]\n    fn test_layout_clone_eq() {\n        let l1 = Layout::RowMajor;\n        let l2 = l1;\n        assert_eq!(l1, l2);\n        assert_ne!(l1, Layout::ColMajor);\n    }\n\n    #[test]\n    fn test_transpose_debug() {\n        assert_eq!(format!(\"{:?}\", Transpose::NoTrans), \"NoTrans\");\n        assert_eq!(format!(\"{:?}\", Transpose::Trans), \"Trans\");\n    }\n\n    #[test]\n    fn test_transpose_clone_eq() {\n        let t1 = Transpose::Trans;\n        let t2 = t1;\n        assert_eq!(t1, t2);\n        assert_ne!(t1, Transpose::NoTrans);\n    }\n}\n","traces":[{"line":46,"address":[],"length":0,"stats":{"Line":56}},{"line":56,"address":[],"length":0,"stats":{"Line":112}},{"line":58,"address":[],"length":0,"stats":{"Line":112}},{"line":61,"address":[],"length":0,"stats":{"Line":112}},{"line":62,"address":[],"length":0,"stats":{"Line":112}},{"line":64,"address":[],"length":0,"stats":{"Line":65}},{"line":65,"address":[],"length":0,"stats":{"Line":18}},{"line":66,"address":[],"length":0,"stats":{"Line":124}},{"line":67,"address":[],"length":0,"stats":{"Line":1291}},{"line":68,"address":[],"length":0,"stats":{"Line":1764}},{"line":69,"address":[],"length":0,"stats":{"Line":5292}},{"line":70,"address":[],"length":0,"stats":{"Line":1764}},{"line":71,"address":[],"length":0,"stats":{"Line":588}},{"line":77,"address":[],"length":0,"stats":{"Line":56}},{"line":78,"address":[],"length":0,"stats":{"Line":104}},{"line":79,"address":[],"length":0,"stats":{"Line":188}},{"line":80,"address":[],"length":0,"stats":{"Line":752}},{"line":81,"address":[],"length":0,"stats":{"Line":1232}},{"line":82,"address":[],"length":0,"stats":{"Line":1232}},{"line":83,"address":[],"length":0,"stats":{"Line":1939}},{"line":85,"address":[],"length":0,"stats":{"Line":339}},{"line":87,"address":[],"length":0,"stats":{"Line":1848}},{"line":88,"address":[],"length":0,"stats":{"Line":616}},{"line":115,"address":[],"length":0,"stats":{"Line":56}},{"line":125,"address":[],"length":0,"stats":{"Line":112}},{"line":127,"address":[],"length":0,"stats":{"Line":112}},{"line":130,"address":[],"length":0,"stats":{"Line":112}},{"line":131,"address":[],"length":0,"stats":{"Line":112}},{"line":133,"address":[],"length":0,"stats":{"Line":67}},{"line":134,"address":[],"length":0,"stats":{"Line":22}},{"line":135,"address":[],"length":0,"stats":{"Line":132}},{"line":136,"address":[],"length":0,"stats":{"Line":1345}},{"line":137,"address":[],"length":0,"stats":{"Line":1836}},{"line":138,"address":[],"length":0,"stats":{"Line":5508}},{"line":139,"address":[],"length":0,"stats":{"Line":1836}},{"line":140,"address":[],"length":0,"stats":{"Line":612}},{"line":146,"address":[],"length":0,"stats":{"Line":56}},{"line":147,"address":[],"length":0,"stats":{"Line":102}},{"line":148,"address":[],"length":0,"stats":{"Line":185}},{"line":149,"address":[],"length":0,"stats":{"Line":742}},{"line":150,"address":[],"length":0,"stats":{"Line":1216}},{"line":151,"address":[],"length":0,"stats":{"Line":1216}},{"line":152,"address":[],"length":0,"stats":{"Line":1841}},{"line":154,"address":[],"length":0,"stats":{"Line":345}},{"line":156,"address":[],"length":0,"stats":{"Line":1824}},{"line":157,"address":[],"length":0,"stats":{"Line":608}},{"line":165,"address":[],"length":0,"stats":{"Line":1740}},{"line":173,"address":[],"length":0,"stats":{"Line":5220}},{"line":174,"address":[],"length":0,"stats":{"Line":1680}},{"line":175,"address":[],"length":0,"stats":{"Line":60}},{"line":178,"address":[],"length":0,"stats":{"Line":3480}},{"line":179,"address":[],"length":0,"stats":{"Line":1728}},{"line":180,"address":[],"length":0,"stats":{"Line":12}},{"line":183,"address":[],"length":0,"stats":{"Line":3480}},{"line":188,"address":[],"length":0,"stats":{"Line":59}},{"line":189,"address":[],"length":0,"stats":{"Line":236}},{"line":190,"address":[],"length":0,"stats":{"Line":59}},{"line":195,"address":[],"length":0,"stats":{"Line":59}},{"line":196,"address":[],"length":0,"stats":{"Line":236}},{"line":197,"address":[],"length":0,"stats":{"Line":59}}],"covered":60,"coverable":60},{"path":["/","home","leo","rcode","cutropicalgemm","crates","tropical-gemm","src","core","tiling.rs"],"content":"/// Tiling parameters for BLIS-style GEMM blocking.\n///\n/// These parameters control how matrices are partitioned to fit in\n/// various levels of the cache hierarchy.\n#[derive(Debug, Clone, Copy)]\npub struct TilingParams {\n    /// Block size for M dimension (L2 cache).\n    pub mc: usize,\n    /// Block size for N dimension (L2 cache).\n    pub nc: usize,\n    /// Block size for K dimension (L1 cache).\n    pub kc: usize,\n    /// Microkernel M dimension (registers).\n    pub mr: usize,\n    /// Microkernel N dimension (registers).\n    pub nr: usize,\n}\n\nimpl TilingParams {\n    /// Default parameters for f32 with AVX2.\n    pub const F32_AVX2: Self = Self {\n        mc: 256,\n        nc: 256,\n        kc: 512,\n        mr: 8,\n        nr: 8,\n    };\n\n    /// Default parameters for f64 with AVX2.\n    pub const F64_AVX2: Self = Self {\n        mc: 128,\n        nc: 128,\n        kc: 256,\n        mr: 4,\n        nr: 4,\n    };\n\n    /// Default parameters for portable (non-SIMD) execution.\n    pub const PORTABLE: Self = Self {\n        mc: 64,\n        nc: 64,\n        kc: 256,\n        mr: 4,\n        nr: 4,\n    };\n\n    /// Create custom tiling parameters.\n    pub const fn new(mc: usize, nc: usize, kc: usize, mr: usize, nr: usize) -\u003e Self {\n        Self { mc, nc, kc, mr, nr }\n    }\n\n    /// Validate that tiling parameters are consistent.\n    pub fn validate(\u0026self) -\u003e Result\u003c(), \u0026'static str\u003e {\n        // Check for zero values first (before divisibility checks)\n        if self.mr == 0 || self.nr == 0 {\n            return Err(\"mr and nr must be non-zero\");\n        }\n        if self.mc == 0 || self.nc == 0 || self.kc == 0 {\n            return Err(\"mc, nc, and kc must be non-zero\");\n        }\n        // Now check divisibility\n        if !self.mc.is_multiple_of(self.mr) {\n            return Err(\"mc must be divisible by mr\");\n        }\n        if !self.nc.is_multiple_of(self.nr) {\n            return Err(\"nc must be divisible by nr\");\n        }\n        Ok(())\n    }\n}\n\nimpl Default for TilingParams {\n    fn default() -\u003e Self {\n        Self::PORTABLE\n    }\n}\n\n/// Iterator over blocks for the outer loop.\npub struct BlockIterator {\n    total: usize,\n    block_size: usize,\n    current: usize,\n}\n\nimpl BlockIterator {\n    pub fn new(total: usize, block_size: usize) -\u003e Self {\n        Self {\n            total,\n            block_size,\n            current: 0,\n        }\n    }\n}\n\nimpl Iterator for BlockIterator {\n    /// (start, length) of each block\n    type Item = (usize, usize);\n\n    fn next(\u0026mut self) -\u003e Option\u003cSelf::Item\u003e {\n        if self.current \u003e= self.total {\n            return None;\n        }\n\n        let start = self.current;\n        let len = (self.total - start).min(self.block_size);\n        self.current += len;\n\n        Some((start, len))\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_block_iterator() {\n        let iter = BlockIterator::new(10, 3);\n        let blocks: Vec\u003c_\u003e = iter.collect();\n\n        assert_eq!(blocks, vec![(0, 3), (3, 3), (6, 3), (9, 1)]);\n    }\n\n    #[test]\n    fn test_block_iterator_exact() {\n        // When total is exactly divisible by block_size\n        let iter = BlockIterator::new(9, 3);\n        let blocks: Vec\u003c_\u003e = iter.collect();\n        assert_eq!(blocks, vec![(0, 3), (3, 3), (6, 3)]);\n    }\n\n    #[test]\n    fn test_block_iterator_empty() {\n        let iter = BlockIterator::new(0, 3);\n        let blocks: Vec\u003c_\u003e = iter.collect();\n        assert!(blocks.is_empty());\n    }\n\n    #[test]\n    fn test_validate_params() {\n        assert!(TilingParams::F32_AVX2.validate().is_ok());\n        assert!(TilingParams::F64_AVX2.validate().is_ok());\n        assert!(TilingParams::PORTABLE.validate().is_ok());\n\n        let bad = TilingParams::new(100, 64, 256, 8, 8);\n        assert!(bad.validate().is_err()); // 100 % 8 != 0\n    }\n\n    #[test]\n    fn test_validate_nc_not_divisible() {\n        // nc not divisible by nr\n        let bad = TilingParams::new(64, 100, 256, 8, 8);\n        assert_eq!(bad.validate(), Err(\"nc must be divisible by nr\"));\n    }\n\n    #[test]\n    fn test_validate_mr_zero() {\n        let bad = TilingParams::new(64, 64, 256, 0, 8);\n        assert_eq!(bad.validate(), Err(\"mr and nr must be non-zero\"));\n    }\n\n    #[test]\n    fn test_validate_nr_zero() {\n        let bad = TilingParams::new(64, 64, 256, 8, 0);\n        assert_eq!(bad.validate(), Err(\"mr and nr must be non-zero\"));\n    }\n\n    #[test]\n    fn test_validate_mc_zero() {\n        let bad = TilingParams::new(0, 64, 256, 8, 8);\n        assert_eq!(bad.validate(), Err(\"mc, nc, and kc must be non-zero\"));\n    }\n\n    #[test]\n    fn test_validate_nc_zero() {\n        let bad = TilingParams::new(64, 0, 256, 8, 8);\n        assert_eq!(bad.validate(), Err(\"mc, nc, and kc must be non-zero\"));\n    }\n\n    #[test]\n    fn test_validate_kc_zero() {\n        let bad = TilingParams::new(64, 64, 0, 8, 8);\n        assert_eq!(bad.validate(), Err(\"mc, nc, and kc must be non-zero\"));\n    }\n\n    #[test]\n    fn test_default() {\n        let default = TilingParams::default();\n        assert_eq!(default.mc, TilingParams::PORTABLE.mc);\n        assert_eq!(default.nc, TilingParams::PORTABLE.nc);\n        assert_eq!(default.kc, TilingParams::PORTABLE.kc);\n        assert_eq!(default.mr, TilingParams::PORTABLE.mr);\n        assert_eq!(default.nr, TilingParams::PORTABLE.nr);\n    }\n\n    #[test]\n    fn test_debug() {\n        let params = TilingParams::PORTABLE;\n        let debug_str = format!(\"{:?}\", params);\n        assert!(debug_str.contains(\"TilingParams\"));\n    }\n\n    #[test]\n    fn test_clone() {\n        let params = TilingParams::F32_AVX2;\n        let cloned = params;\n        assert_eq!(params.mc, cloned.mc);\n    }\n}\n","traces":[{"line":48,"address":[],"length":0,"stats":{"Line":7}},{"line":53,"address":[],"length":0,"stats":{"Line":10}},{"line":55,"address":[],"length":0,"stats":{"Line":19}},{"line":56,"address":[],"length":0,"stats":{"Line":2}},{"line":58,"address":[],"length":0,"stats":{"Line":21}},{"line":59,"address":[],"length":0,"stats":{"Line":3}},{"line":62,"address":[],"length":0,"stats":{"Line":10}},{"line":63,"address":[],"length":0,"stats":{"Line":1}},{"line":65,"address":[],"length":0,"stats":{"Line":8}},{"line":66,"address":[],"length":0,"stats":{"Line":1}},{"line":68,"address":[],"length":0,"stats":{"Line":3}},{"line":73,"address":[],"length":0,"stats":{"Line":1}},{"line":74,"address":[],"length":0,"stats":{"Line":1}},{"line":86,"address":[],"length":0,"stats":{"Line":159}},{"line":99,"address":[],"length":0,"stats":{"Line":322}},{"line":100,"address":[],"length":0,"stats":{"Line":322}},{"line":101,"address":[],"length":0,"stats":{"Line":159}},{"line":104,"address":[],"length":0,"stats":{"Line":326}},{"line":105,"address":[],"length":0,"stats":{"Line":652}},{"line":106,"address":[],"length":0,"stats":{"Line":163}},{"line":108,"address":[],"length":0,"stats":{"Line":163}}],"covered":21,"coverable":21},{"path":["/","home","leo","rcode","cutropicalgemm","crates","tropical-gemm","src","lib.rs"],"content":"//! High-performance tropical matrix multiplication.\n//!\n//! This library provides BLAS-level performance for tropical matrix\n//! multiplication across multiple semiring types.\n//!\n//! # GPU Acceleration\n//!\n//! For GPU-accelerated operations, add the `tropical-gemm-cuda` crate:\n//!\n//! ```toml\n//! [dependencies]\n//! tropical-gemm = \"0.1\"\n//! tropical-gemm-cuda = \"0.1\"\n//! ```\n//!\n//! Then use the GPU API:\n//!\n//! ```ignore\n//! use tropical_gemm::TropicalMaxPlus;\n//! use tropical_gemm_cuda::{tropical_matmul_gpu, CudaContext};\n//!\n//! let c = tropical_matmul_gpu::\u003cTropicalMaxPlus\u003cf32\u003e\u003e(\u0026a, m, k, \u0026b, n)?;\n//! ```\n//!\n//! # Tropical Semirings\n//!\n//! Tropical algebra replaces standard arithmetic operations:\n//! - Standard addition → tropical addition (typically max or min)\n//! - Standard multiplication → tropical multiplication (typically + or ×)\n//!\n//! | Type | ⊕ (add) | ⊗ (mul) | Zero | One | Use Case |\n//! |------|---------|---------|------|-----|----------|\n//! | [`TropicalMaxPlus\u003cT\u003e`] | max | + | -∞ | 0 | Viterbi, longest path |\n//! | [`TropicalMinPlus\u003cT\u003e`] | min | + | +∞ | 0 | Shortest path |\n//! | [`TropicalMaxMul\u003cT\u003e`] | max | × | 0 | 1 | Probability (non-log) |\n//! | [`TropicalAndOr`] | OR | AND | false | true | Graph reachability |\n//! | [`CountingTropical\u003cT,C\u003e`] | max+count | +,× | (-∞,0) | (0,1) | Path counting |\n//!\n//! # Quick Start\n//!\n//! ## Function-based API\n//!\n//! ```\n//! use tropical_gemm::{tropical_matmul, TropicalMaxPlus, TropicalSemiring};\n//!\n//! // Create 2x3 and 3x2 matrices\n//! let a = vec![1.0f32, 2.0, 3.0, 4.0, 5.0, 6.0];\n//! let b = vec![1.0f32, 2.0, 3.0, 4.0, 5.0, 6.0];\n//!\n//! // Compute C = A ⊗ B using TropicalMaxPlus semiring\n//! let c = tropical_matmul::\u003cTropicalMaxPlus\u003cf32\u003e\u003e(\u0026a, 2, 3, \u0026b, 2);\n//!\n//! // C[i,j] = max_k(A[i,k] + B[k,j])\n//! assert_eq!(c[0].value(), 8.0); // max(1+1, 2+3, 3+5) = 8\n//! ```\n//!\n//! ## Matrix-based API (faer-style)\n//!\n//! ```\n//! use tropical_gemm::{Mat, MatRef, MaxPlus, TropicalSemiring};\n//!\n//! // Create matrix views from raw data\n//! let a_data = [1.0f32, 2.0, 3.0, 4.0, 5.0, 6.0];\n//! let b_data = [1.0f32, 2.0, 3.0, 4.0, 5.0, 6.0];\n//!\n//! let a = MatRef::\u003cMaxPlus\u003cf32\u003e\u003e::from_slice(\u0026a_data, 2, 3);\n//! let b = MatRef::\u003cMaxPlus\u003cf32\u003e\u003e::from_slice(\u0026b_data, 3, 2);\n//!\n//! // Matrix multiplication using operators\n//! let c = \u0026a * \u0026b;\n//! assert_eq!(c[(0, 0)].value(), 8.0);\n//!\n//! // Or using methods\n//! let c = a.matmul(\u0026b);\n//!\n//! // Factory methods\n//! let zeros = Mat::\u003cMaxPlus\u003cf32\u003e\u003e::zeros(3, 3);\n//! let identity = Mat::\u003cMaxPlus\u003cf32\u003e\u003e::identity(3);\n//! ```\n//!\n//! # Argmax Tracking (Backpropagation)\n//!\n//! For gradient routing in neural networks, you can track which k index\n//! produced each optimal value:\n//!\n//! ```\n//! use tropical_gemm::{tropical_matmul_with_argmax, TropicalMaxPlus, TropicalSemiring};\n//!\n//! let a = vec![1.0f64, 2.0, 3.0, 4.0, 5.0, 6.0];\n//! let b = vec![1.0f64, 2.0, 3.0, 4.0, 5.0, 6.0];\n//!\n//! let result = tropical_matmul_with_argmax::\u003cTropicalMaxPlus\u003cf64\u003e\u003e(\u0026a, 2, 3, \u0026b, 2);\n//!\n//! // Get the optimal value and which k produced it\n//! let value = result.get(0, 0).value(); // 8.0\n//! let k_idx = result.get_argmax(0, 0);  // 2 (k=2 gave max)\n//! ```\n//!\n//! # Performance\n//!\n//! The library uses:\n//! - BLIS-style cache blocking for memory efficiency\n//! - Runtime CPU feature detection for optimal SIMD kernels\n//! - AVX2/AVX-512 on x86-64, NEON on ARM\n//!\n//! ```\n//! use tropical_gemm::Backend;\n//!\n//! println!(\"Using: {}\", Backend::description());\n//! ```\n//!\n//! # BLAS-style API\n//!\n//! For fine-grained control:\n//!\n//! ```\n//! use tropical_gemm::{TropicalGemm, TropicalMaxPlus, TropicalSemiring};\n//!\n//! let a = vec![1.0f32; 64 * 64];\n//! let b = vec![1.0f32; 64 * 64];\n//! let mut c = vec![TropicalMaxPlus::tropical_zero(); 64 * 64];\n//!\n//! TropicalGemm::\u003cTropicalMaxPlus\u003cf32\u003e\u003e::new(64, 64, 64)\n//!     .execute(\u0026a, 64, \u0026b, 64, \u0026mut c, 64);\n//! ```\n\n// Internal modules\npub mod core;\npub mod mat;\npub mod simd;\npub mod types;\n\nmod api;\nmod backend;\n\n// Public API\npub use api::{tropical_gemm, tropical_matmul, tropical_matmul_with_argmax, TropicalGemm};\npub use backend::{version_info, Backend};\n\n// Re-export commonly used types at crate root\npub use core::{GemmWithArgmax, Layout, Transpose};\npub use mat::{Mat, MatMut, MatRef, MatWithArgmax};\npub use simd::{simd_level, KernelDispatch, SimdLevel};\npub use types::{\n    CountingTropical, SimdTropical, TropicalAndOr, TropicalMaxMul, TropicalMaxPlus,\n    TropicalMinPlus, TropicalScalar, TropicalSemiring, TropicalWithArgmax,\n};\n\n// Convenient type aliases\n/// Alias for [`TropicalMaxPlus`].\npub type MaxPlus\u003cT\u003e = TropicalMaxPlus\u003cT\u003e;\n/// Alias for [`TropicalMinPlus`].\npub type MinPlus\u003cT\u003e = TropicalMinPlus\u003cT\u003e;\n/// Alias for [`TropicalMaxMul`].\npub type MaxMul\u003cT\u003e = TropicalMaxMul\u003cT\u003e;\n/// Alias for [`TropicalAndOr`].\npub type AndOr = TropicalAndOr;\n\n/// Prelude module for convenient imports.\npub mod prelude {\n    pub use super::{\n        tropical_matmul, tropical_matmul_with_argmax, AndOr, Backend, CountingTropical,\n        GemmWithArgmax, Mat, MatMut, MatRef, MatWithArgmax, MaxMul, MaxPlus, MinPlus, Transpose,\n        TropicalAndOr, TropicalGemm, TropicalMaxMul, TropicalMaxPlus, TropicalMinPlus,\n        TropicalSemiring, TropicalWithArgmax,\n    };\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","leo","rcode","cutropicalgemm","crates","tropical-gemm","src","mat","mod.rs"],"content":"//! Matrix types for tropical algebra.\n//!\n//! This module provides faer-inspired matrix types:\n//! - [`Mat\u003cS\u003e`]: Owned matrix storing semiring values\n//! - [`MatRef\u003c'a, S\u003e`]: Immutable view over scalar data\n//! - [`MatMut\u003c'a, S\u003e`]: Mutable view over semiring data\n//!\n//! # Example\n//!\n//! ```\n//! use tropical_gemm::{Mat, MatRef, MaxPlus};\n//!\n//! // Create a view from raw data\n//! let data = [1.0f32, 2.0, 3.0, 4.0, 5.0, 6.0];\n//! let a = MatRef::\u003cMaxPlus\u003cf32\u003e\u003e::from_slice(\u0026data, 2, 3);\n//! let b = MatRef::\u003cMaxPlus\u003cf32\u003e\u003e::from_slice(\u0026data, 3, 2);\n//!\n//! // Matrix multiplication using method\n//! let c = a.matmul(\u0026b);\n//!\n//! // Or using operator syntax\n//! let c = \u0026a * \u0026b;\n//!\n//! // Factory methods\n//! let zeros = Mat::\u003cMaxPlus\u003cf32\u003e\u003e::zeros(3, 3);\n//! let identity = Mat::\u003cMaxPlus\u003cf32\u003e\u003e::identity(3);\n//! ```\n\nmod mut_;\nmod ops;\nmod owned;\nmod ref_;\n\npub use mut_::MatMut;\npub use owned::Mat;\npub use ref_::MatRef;\n\n/// Result of matrix multiplication with argmax tracking.\npub struct MatWithArgmax\u003cS: crate::TropicalWithArgmax\u003e {\n    /// The result matrix values.\n    pub values: Mat\u003cS\u003e,\n    /// The argmax indices (which k produced each C[i,j]).\n    pub argmax: Vec\u003cu32\u003e,\n}\n\nimpl\u003cS: crate::TropicalWithArgmax\u003cIndex = u32\u003e\u003e MatWithArgmax\u003cS\u003e {\n    /// Get the value at position (i, j).\n    pub fn get(\u0026self, i: usize, j: usize) -\u003e S {\n        self.values[(i, j)]\n    }\n\n    /// Get the scalar value at position (i, j).\n    ///\n    /// This is a convenience method that extracts the underlying scalar\n    /// without requiring a trait import.\n    #[inline]\n    pub fn get_value(\u0026self, i: usize, j: usize) -\u003e S::Scalar {\n        self.values[(i, j)].value()\n    }\n\n    /// Get the argmax index at position (i, j).\n    pub fn get_argmax(\u0026self, i: usize, j: usize) -\u003e u32 {\n        self.argmax[i * self.values.ncols() + j]\n    }\n\n    /// Number of rows.\n    pub fn nrows(\u0026self) -\u003e usize {\n        self.values.nrows()\n    }\n\n    /// Number of columns.\n    pub fn ncols(\u0026self) -\u003e usize {\n        self.values.ncols()\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use crate::TropicalMaxPlus;\n\n    #[test]\n    fn test_mat_zeros() {\n        let m = Mat::\u003cTropicalMaxPlus\u003cf64\u003e\u003e::zeros(3, 4);\n        assert_eq!(m.nrows(), 3);\n        assert_eq!(m.ncols(), 4);\n        assert_eq!(m[(0, 0)].0, f64::NEG_INFINITY);\n    }\n\n    #[test]\n    fn test_mat_identity() {\n        let m = Mat::\u003cTropicalMaxPlus\u003cf64\u003e\u003e::identity(3);\n        assert_eq!(m.nrows(), 3);\n        assert_eq!(m.ncols(), 3);\n        assert_eq!(m[(0, 0)].0, 0.0); // tropical one\n        assert_eq!(m[(0, 1)].0, f64::NEG_INFINITY); // tropical zero\n        assert_eq!(m[(1, 1)].0, 0.0);\n        assert_eq!(m[(2, 2)].0, 0.0);\n    }\n\n    #[test]\n    fn test_mat_from_fn() {\n        let m =\n            Mat::\u003cTropicalMaxPlus\u003cf64\u003e\u003e::from_fn(2, 3, |i, j| TropicalMaxPlus((i * 3 + j) as f64));\n        assert_eq!(m[(0, 0)].0, 0.0);\n        assert_eq!(m[(0, 2)].0, 2.0);\n        assert_eq!(m[(1, 0)].0, 3.0);\n        assert_eq!(m[(1, 2)].0, 5.0);\n    }\n\n    #[test]\n    fn test_matref_from_slice() {\n        let data = [1.0f64, 2.0, 3.0, 4.0, 5.0, 6.0];\n        let m = MatRef::\u003cTropicalMaxPlus\u003cf64\u003e\u003e::from_slice(\u0026data, 2, 3);\n        assert_eq!(m.nrows(), 2);\n        assert_eq!(m.ncols(), 3);\n        assert_eq!(m.get(0, 0), 1.0);\n        assert_eq!(m.get(1, 2), 6.0);\n    }\n\n    #[test]\n    fn test_matmul() {\n        let a_data = [1.0f64, 2.0, 3.0, 4.0, 5.0, 6.0];\n        let b_data = [1.0f64, 2.0, 3.0, 4.0, 5.0, 6.0];\n\n        let a = MatRef::\u003cTropicalMaxPlus\u003cf64\u003e\u003e::from_slice(\u0026a_data, 2, 3);\n        let b = MatRef::\u003cTropicalMaxPlus\u003cf64\u003e\u003e::from_slice(\u0026b_data, 3, 2);\n\n        let c = a.matmul(\u0026b);\n\n        // C[0,0] = max(1+1, 2+3, 3+5) = 8\n        assert_eq!(c[(0, 0)].0, 8.0);\n        // C[0,1] = max(1+2, 2+4, 3+6) = 9\n        assert_eq!(c[(0, 1)].0, 9.0);\n        // C[1,0] = max(4+1, 5+3, 6+5) = 11\n        assert_eq!(c[(1, 0)].0, 11.0);\n        // C[1,1] = max(4+2, 5+4, 6+6) = 12\n        assert_eq!(c[(1, 1)].0, 12.0);\n    }\n\n    #[test]\n    fn test_matmul_operator() {\n        let a_data = [1.0f64, 2.0, 3.0, 4.0, 5.0, 6.0];\n        let b_data = [1.0f64, 2.0, 3.0, 4.0, 5.0, 6.0];\n\n        let a = MatRef::\u003cTropicalMaxPlus\u003cf64\u003e\u003e::from_slice(\u0026a_data, 2, 3);\n        let b = MatRef::\u003cTropicalMaxPlus\u003cf64\u003e\u003e::from_slice(\u0026b_data, 3, 2);\n\n        let c = \u0026a * \u0026b;\n\n        assert_eq!(c[(0, 0)].0, 8.0);\n        assert_eq!(c[(1, 1)].0, 12.0);\n    }\n\n    #[test]\n    fn test_matmul_argmax() {\n        let a_data = [1.0f64, 2.0, 3.0, 4.0, 5.0, 6.0];\n        let b_data = [1.0f64, 2.0, 3.0, 4.0, 5.0, 6.0];\n\n        let a = MatRef::\u003cTropicalMaxPlus\u003cf64\u003e\u003e::from_slice(\u0026a_data, 2, 3);\n        let b = MatRef::\u003cTropicalMaxPlus\u003cf64\u003e\u003e::from_slice(\u0026b_data, 3, 2);\n\n        let result = a.matmul_argmax(\u0026b);\n\n        assert_eq!(result.get(0, 0).0, 8.0);\n        assert_eq!(result.get_argmax(0, 0), 2); // k=2 gave max\n    }\n\n    #[test]\n    fn test_minplus_matmul() {\n        use crate::TropicalMinPlus;\n\n        let a_data = [1.0f64, 2.0, 3.0, 4.0, 5.0, 6.0];\n        let b_data = [1.0f64, 2.0, 3.0, 4.0, 5.0, 6.0];\n\n        let a = MatRef::\u003cTropicalMinPlus\u003cf64\u003e\u003e::from_slice(\u0026a_data, 2, 3);\n        let b = MatRef::\u003cTropicalMinPlus\u003cf64\u003e\u003e::from_slice(\u0026b_data, 3, 2);\n\n        let c = a.matmul(\u0026b);\n\n        // C[0,0] = min(1+1, 2+3, 3+5) = 2\n        assert_eq!(c[(0, 0)].0, 2.0);\n        // C[1,1] = min(4+2, 5+4, 6+6) = 6\n        assert_eq!(c[(1, 1)].0, 6.0);\n    }\n\n    #[test]\n    fn test_mat_as_ref() {\n        let m =\n            Mat::\u003cTropicalMaxPlus\u003cf64\u003e\u003e::from_fn(2, 3, |i, j| TropicalMaxPlus((i * 3 + j) as f64));\n\n        let r = m.as_ref();\n        assert_eq!(r.nrows(), 2);\n        assert_eq!(r.ncols(), 3);\n        assert_eq!(r.get(0, 0), 0.0);\n        assert_eq!(r.get(1, 2), 5.0);\n    }\n\n    #[test]\n    fn test_mat_matmul_direct() {\n        // Test Mat::matmul directly (no as_ref needed)\n        let a = Mat::\u003cTropicalMaxPlus\u003cf64\u003e\u003e::from_row_major(\u0026[1.0, 2.0, 3.0, 4.0, 5.0, 6.0], 2, 3);\n        let b = Mat::\u003cTropicalMaxPlus\u003cf64\u003e\u003e::from_row_major(\u0026[1.0, 2.0, 3.0, 4.0, 5.0, 6.0], 3, 2);\n\n        let c = a.matmul(\u0026b);\n\n        // C[0,0] = max(1+1, 2+3, 3+5) = 8\n        assert_eq!(c[(0, 0)].0, 8.0);\n        // C[1,1] = max(4+2, 5+4, 6+6) = 12\n        assert_eq!(c[(1, 1)].0, 12.0);\n    }\n\n    #[test]\n    fn test_mat_matmul_argmax_direct() {\n        // Test Mat::matmul_argmax directly\n        let a = Mat::\u003cTropicalMaxPlus\u003cf64\u003e\u003e::from_row_major(\u0026[1.0, 2.0, 3.0, 4.0, 5.0, 6.0], 2, 3);\n        let b = Mat::\u003cTropicalMaxPlus\u003cf64\u003e\u003e::from_row_major(\u0026[1.0, 2.0, 3.0, 4.0, 5.0, 6.0], 3, 2);\n\n        let result = a.matmul_argmax(\u0026b);\n\n        assert_eq!(result.get(0, 0).0, 8.0);\n        assert_eq!(result.get_argmax(0, 0), 2); // k=2 gave max\n    }\n\n    #[test]\n    fn test_mat_get_value() {\n        // Test get_value method - no trait import needed\n        let m = Mat::\u003cTropicalMaxPlus\u003cf64\u003e\u003e::from_row_major(\u0026[1.0, 2.0, 3.0, 4.0], 2, 2);\n\n        assert_eq!(m.get_value(0, 0), 1.0);\n        assert_eq!(m.get_value(0, 1), 2.0);\n        assert_eq!(m.get_value(1, 0), 3.0);\n        assert_eq!(m.get_value(1, 1), 4.0);\n    }\n\n    #[test]\n    fn test_minplus_mat_matmul_direct() {\n        use crate::TropicalMinPlus;\n\n        let a = Mat::\u003cTropicalMinPlus\u003cf64\u003e\u003e::from_row_major(\u0026[1.0, 2.0, 3.0, 4.0, 5.0, 6.0], 2, 3);\n        let b = Mat::\u003cTropicalMinPlus\u003cf64\u003e\u003e::from_row_major(\u0026[1.0, 2.0, 3.0, 4.0, 5.0, 6.0], 3, 2);\n\n        let c = a.matmul(\u0026b);\n\n        // C[0,0] = min(1+1, 2+3, 3+5) = 2\n        assert_eq!(c[(0, 0)].0, 2.0);\n        // C[1,1] = min(4+2, 5+4, 6+6) = 6\n        assert_eq!(c[(1, 1)].0, 6.0);\n    }\n}\n","traces":[{"line":48,"address":[],"length":0,"stats":{"Line":2}},{"line":49,"address":[],"length":0,"stats":{"Line":4}},{"line":57,"address":[],"length":0,"stats":{"Line":0}},{"line":58,"address":[],"length":0,"stats":{"Line":0}},{"line":62,"address":[],"length":0,"stats":{"Line":2}},{"line":63,"address":[],"length":0,"stats":{"Line":6}},{"line":67,"address":[],"length":0,"stats":{"Line":0}},{"line":68,"address":[],"length":0,"stats":{"Line":0}},{"line":72,"address":[],"length":0,"stats":{"Line":0}},{"line":73,"address":[],"length":0,"stats":{"Line":0}}],"covered":4,"coverable":10},{"path":["/","home","leo","rcode","cutropicalgemm","crates","tropical-gemm","src","mat","mut_.rs"],"content":"//! Mutable matrix reference type.\n\nuse crate::types::TropicalSemiring;\n\n/// Mutable view over semiring data.\n///\n/// Unlike `MatRef`, this holds mutable references to semiring values,\n/// not scalars. This is used for in-place operations.\n#[derive(Debug)]\npub struct MatMut\u003c'a, S: TropicalSemiring\u003e {\n    data: \u0026'a mut [S],\n    nrows: usize,\n    ncols: usize,\n}\n\nimpl\u003c'a, S: TropicalSemiring\u003e MatMut\u003c'a, S\u003e {\n    /// Create a mutable matrix reference from a slice.\n    pub fn from_slice(data: \u0026'a mut [S], nrows: usize, ncols: usize) -\u003e Self {\n        assert_eq!(\n            data.len(),\n            nrows * ncols,\n            \"data length {} != nrows {} * ncols {}\",\n            data.len(),\n            nrows,\n            ncols\n        );\n        Self { data, nrows, ncols }\n    }\n\n    /// Number of rows.\n    #[inline]\n    pub fn nrows(\u0026self) -\u003e usize {\n        self.nrows\n    }\n\n    /// Number of columns.\n    #[inline]\n    pub fn ncols(\u0026self) -\u003e usize {\n        self.ncols\n    }\n\n    /// Get the underlying data as a mutable slice.\n    #[inline]\n    pub fn as_mut_slice(\u0026mut self) -\u003e \u0026mut [S] {\n        self.data\n    }\n\n    /// Get a mutable pointer to the data.\n    #[inline]\n    pub fn as_mut_ptr(\u0026mut self) -\u003e *mut S {\n        self.data.as_mut_ptr()\n    }\n\n    /// Get a reference to the value at position (i, j).\n    #[inline]\n    pub fn get(\u0026self, i: usize, j: usize) -\u003e \u0026S {\n        debug_assert!(\n            i \u003c self.nrows,\n            \"row index {} out of bounds {}\",\n            i,\n            self.nrows\n        );\n        debug_assert!(\n            j \u003c self.ncols,\n            \"col index {} out of bounds {}\",\n            j,\n            self.ncols\n        );\n        \u0026self.data[i * self.ncols + j]\n    }\n\n    /// Get a mutable reference to the value at position (i, j).\n    #[inline]\n    pub fn get_mut(\u0026mut self, i: usize, j: usize) -\u003e \u0026mut S {\n        debug_assert!(\n            i \u003c self.nrows,\n            \"row index {} out of bounds {}\",\n            i,\n            self.nrows\n        );\n        debug_assert!(\n            j \u003c self.ncols,\n            \"col index {} out of bounds {}\",\n            j,\n            self.ncols\n        );\n        \u0026mut self.data[i * self.ncols + j]\n    }\n}\n","traces":[{"line":18,"address":[],"length":0,"stats":{"Line":0}},{"line":19,"address":[],"length":0,"stats":{"Line":0}},{"line":20,"address":[],"length":0,"stats":{"Line":0}},{"line":21,"address":[],"length":0,"stats":{"Line":0}},{"line":22,"address":[],"length":0,"stats":{"Line":0}},{"line":23,"address":[],"length":0,"stats":{"Line":0}},{"line":24,"address":[],"length":0,"stats":{"Line":0}},{"line":25,"address":[],"length":0,"stats":{"Line":0}},{"line":32,"address":[],"length":0,"stats":{"Line":0}},{"line":33,"address":[],"length":0,"stats":{"Line":0}},{"line":38,"address":[],"length":0,"stats":{"Line":0}},{"line":39,"address":[],"length":0,"stats":{"Line":0}},{"line":44,"address":[],"length":0,"stats":{"Line":0}},{"line":45,"address":[],"length":0,"stats":{"Line":0}},{"line":50,"address":[],"length":0,"stats":{"Line":0}},{"line":51,"address":[],"length":0,"stats":{"Line":0}},{"line":56,"address":[],"length":0,"stats":{"Line":0}},{"line":57,"address":[],"length":0,"stats":{"Line":0}},{"line":58,"address":[],"length":0,"stats":{"Line":0}},{"line":59,"address":[],"length":0,"stats":{"Line":0}},{"line":60,"address":[],"length":0,"stats":{"Line":0}},{"line":61,"address":[],"length":0,"stats":{"Line":0}},{"line":63,"address":[],"length":0,"stats":{"Line":0}},{"line":64,"address":[],"length":0,"stats":{"Line":0}},{"line":65,"address":[],"length":0,"stats":{"Line":0}},{"line":66,"address":[],"length":0,"stats":{"Line":0}},{"line":67,"address":[],"length":0,"stats":{"Line":0}},{"line":69,"address":[],"length":0,"stats":{"Line":0}},{"line":74,"address":[],"length":0,"stats":{"Line":0}},{"line":75,"address":[],"length":0,"stats":{"Line":0}},{"line":76,"address":[],"length":0,"stats":{"Line":0}},{"line":77,"address":[],"length":0,"stats":{"Line":0}},{"line":78,"address":[],"length":0,"stats":{"Line":0}},{"line":79,"address":[],"length":0,"stats":{"Line":0}},{"line":81,"address":[],"length":0,"stats":{"Line":0}},{"line":82,"address":[],"length":0,"stats":{"Line":0}},{"line":83,"address":[],"length":0,"stats":{"Line":0}},{"line":84,"address":[],"length":0,"stats":{"Line":0}},{"line":85,"address":[],"length":0,"stats":{"Line":0}},{"line":87,"address":[],"length":0,"stats":{"Line":0}}],"covered":0,"coverable":40},{"path":["/","home","leo","rcode","cutropicalgemm","crates","tropical-gemm","src","mat","ops.rs"],"content":"//! Operator implementations for matrix types.\n\nuse std::ops::Mul;\n\nuse crate::simd::KernelDispatch;\nuse crate::types::TropicalSemiring;\n\nuse super::{Mat, MatRef};\n\n// MatRef * MatRef\nimpl\u003c'a, 'b, S\u003e Mul\u003c\u0026'b MatRef\u003c'b, S\u003e\u003e for \u0026'a MatRef\u003c'a, S\u003e\nwhere\n    S: TropicalSemiring + KernelDispatch,\n{\n    type Output = Mat\u003cS\u003e;\n\n    fn mul(self, rhs: \u0026'b MatRef\u003c'b, S\u003e) -\u003e Mat\u003cS\u003e {\n        self.matmul(rhs)\n    }\n}\n\n// MatRef * MatRef (by value, since MatRef is Copy)\nimpl\u003c'a, 'b, S\u003e Mul\u003cMatRef\u003c'b, S\u003e\u003e for MatRef\u003c'a, S\u003e\nwhere\n    S: TropicalSemiring + KernelDispatch,\n{\n    type Output = Mat\u003cS\u003e;\n\n    fn mul(self, rhs: MatRef\u003c'b, S\u003e) -\u003e Mat\u003cS\u003e {\n        self.matmul(\u0026rhs)\n    }\n}\n\n// \u0026Mat * \u0026MatRef\nimpl\u003c'a, S\u003e Mul\u003c\u0026'a MatRef\u003c'a, S\u003e\u003e for \u0026Mat\u003cS\u003e\nwhere\n    S: TropicalSemiring + KernelDispatch,\n    S::Scalar: Copy,\n{\n    type Output = Mat\u003cS\u003e;\n\n    fn mul(self, rhs: \u0026'a MatRef\u003c'a, S\u003e) -\u003e Mat\u003cS\u003e {\n        self.as_ref().matmul(rhs)\n    }\n}\n\n// \u0026Mat * \u0026Mat\nimpl\u003cS\u003e Mul\u003c\u0026Mat\u003cS\u003e\u003e for \u0026Mat\u003cS\u003e\nwhere\n    S: TropicalSemiring + KernelDispatch,\n    S::Scalar: Copy,\n{\n    type Output = Mat\u003cS\u003e;\n\n    fn mul(self, rhs: \u0026Mat\u003cS\u003e) -\u003e Mat\u003cS\u003e {\n        self.as_ref().matmul(\u0026rhs.as_ref())\n    }\n}\n\n// Mat * Mat (consuming)\nimpl\u003cS\u003e Mul\u003cMat\u003cS\u003e\u003e for Mat\u003cS\u003e\nwhere\n    S: TropicalSemiring + KernelDispatch,\n    S::Scalar: Copy,\n{\n    type Output = Mat\u003cS\u003e;\n\n    fn mul(self, rhs: Mat\u003cS\u003e) -\u003e Mat\u003cS\u003e {\n        self.as_ref().matmul(\u0026rhs.as_ref())\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use crate::TropicalMaxPlus;\n\n    #[test]\n    fn test_matref_mul_matref() {\n        let a_data = [1.0f64, 2.0, 3.0, 4.0];\n        let b_data = [1.0f64, 2.0, 3.0, 4.0];\n\n        let a = MatRef::\u003cTropicalMaxPlus\u003cf64\u003e\u003e::from_slice(\u0026a_data, 2, 2);\n        let b = MatRef::\u003cTropicalMaxPlus\u003cf64\u003e\u003e::from_slice(\u0026b_data, 2, 2);\n\n        let c = \u0026a * \u0026b;\n\n        // C[0,0] = max(1+1, 2+3) = 5\n        assert_eq!(c[(0, 0)].0, 5.0);\n    }\n\n    #[test]\n    fn test_mat_mul_mat() {\n        let a = Mat::\u003cTropicalMaxPlus\u003cf64\u003e\u003e::from_row_major(\u0026[1.0, 2.0, 3.0, 4.0], 2, 2);\n        let b = Mat::\u003cTropicalMaxPlus\u003cf64\u003e\u003e::from_row_major(\u0026[1.0, 2.0, 3.0, 4.0], 2, 2);\n\n        let c = \u0026a * \u0026b;\n\n        assert_eq!(c[(0, 0)].0, 5.0);\n    }\n\n    #[test]\n    fn test_mat_mul_consuming() {\n        let a = Mat::\u003cTropicalMaxPlus\u003cf64\u003e\u003e::from_row_major(\u0026[1.0, 2.0, 3.0, 4.0], 2, 2);\n        let b = Mat::\u003cTropicalMaxPlus\u003cf64\u003e\u003e::from_row_major(\u0026[1.0, 2.0, 3.0, 4.0], 2, 2);\n\n        let c = a * b;\n\n        assert_eq!(c[(0, 0)].0, 5.0);\n    }\n}\n","traces":[{"line":17,"address":[],"length":0,"stats":{"Line":2}},{"line":18,"address":[],"length":0,"stats":{"Line":6}},{"line":29,"address":[],"length":0,"stats":{"Line":0}},{"line":30,"address":[],"length":0,"stats":{"Line":0}},{"line":42,"address":[],"length":0,"stats":{"Line":0}},{"line":43,"address":[],"length":0,"stats":{"Line":0}},{"line":55,"address":[],"length":0,"stats":{"Line":1}},{"line":56,"address":[],"length":0,"stats":{"Line":3}},{"line":68,"address":[],"length":0,"stats":{"Line":1}},{"line":69,"address":[],"length":0,"stats":{"Line":3}}],"covered":6,"coverable":10},{"path":["/","home","leo","rcode","cutropicalgemm","crates","tropical-gemm","src","mat","owned.rs"],"content":"//! Owned matrix type.\n\nuse std::ops::{Index, IndexMut};\n\nuse crate::core::Transpose;\nuse crate::simd::{tropical_gemm_dispatch, KernelDispatch};\nuse crate::types::{TropicalSemiring, TropicalWithArgmax};\n\nuse super::{MatRef, MatWithArgmax};\n\n/// Owned matrix storing semiring values.\n///\n/// The matrix stores values in row-major order. Use factory methods\n/// to create matrices:\n///\n/// ```\n/// use tropical_gemm::{Mat, MaxPlus, TropicalSemiring};\n///\n/// let zeros = Mat::\u003cMaxPlus\u003cf32\u003e\u003e::zeros(3, 4);\n/// let identity = Mat::\u003cMaxPlus\u003cf32\u003e\u003e::identity(3);\n/// let custom = Mat::\u003cMaxPlus\u003cf32\u003e\u003e::from_fn(2, 2, |i, j| {\n///     MaxPlus::\u003cf32\u003e::from_scalar((i + j) as f32)\n/// });\n/// ```\n#[derive(Debug, Clone)]\npub struct Mat\u003cS: TropicalSemiring\u003e {\n    pub(crate) data: Vec\u003cS\u003e,\n    pub(crate) nrows: usize,\n    pub(crate) ncols: usize,\n}\n\nimpl\u003cS: TropicalSemiring\u003e Mat\u003cS\u003e {\n    /// Create a matrix filled with tropical zeros.\n    ///\n    /// For MaxPlus, this fills with -∞.\n    /// For MinPlus, this fills with +∞.\n    pub fn zeros(nrows: usize, ncols: usize) -\u003e Self {\n        Self {\n            data: vec![S::tropical_zero(); nrows * ncols],\n            nrows,\n            ncols,\n        }\n    }\n\n    /// Create a tropical identity matrix.\n    ///\n    /// Diagonal elements are tropical one (0 for MaxPlus/MinPlus).\n    /// Off-diagonal elements are tropical zero (-∞ for MaxPlus, +∞ for MinPlus).\n    pub fn identity(n: usize) -\u003e Self {\n        let mut mat = Self::zeros(n, n);\n        for i in 0..n {\n            mat.data[i * n + i] = S::tropical_one();\n        }\n        mat\n    }\n\n    /// Create a matrix from a function.\n    ///\n    /// The function is called with (row, col) indices.\n    pub fn from_fn\u003cF\u003e(nrows: usize, ncols: usize, mut f: F) -\u003e Self\n    where\n        F: FnMut(usize, usize) -\u003e S,\n    {\n        let data = (0..nrows * ncols)\n            .map(|idx| f(idx / ncols, idx % ncols))\n            .collect();\n        Self { data, nrows, ncols }\n    }\n\n    /// Create a matrix from row-major scalar data.\n    ///\n    /// Each scalar is wrapped in the semiring type.\n    pub fn from_row_major(data: \u0026[S::Scalar], nrows: usize, ncols: usize) -\u003e Self\n    where\n        S::Scalar: Copy,\n    {\n        assert_eq!(\n            data.len(),\n            nrows * ncols,\n            \"data length {} != nrows {} * ncols {}\",\n            data.len(),\n            nrows,\n            ncols\n        );\n        let data = data.iter().map(|\u0026s| S::from_scalar(s)).collect();\n        Self { data, nrows, ncols }\n    }\n\n    /// Create a matrix from a vector of semiring values.\n    pub fn from_vec(data: Vec\u003cS\u003e, nrows: usize, ncols: usize) -\u003e Self {\n        assert_eq!(\n            data.len(),\n            nrows * ncols,\n            \"data length {} != nrows {} * ncols {}\",\n            data.len(),\n            nrows,\n            ncols\n        );\n        Self { data, nrows, ncols }\n    }\n\n    /// Number of rows.\n    #[inline]\n    pub fn nrows(\u0026self) -\u003e usize {\n        self.nrows\n    }\n\n    /// Number of columns.\n    #[inline]\n    pub fn ncols(\u0026self) -\u003e usize {\n        self.ncols\n    }\n\n    /// Get the underlying data as a slice.\n    #[inline]\n    pub fn as_slice(\u0026self) -\u003e \u0026[S] {\n        \u0026self.data\n    }\n\n    /// Get the underlying data as a mutable slice.\n    #[inline]\n    pub fn as_mut_slice(\u0026mut self) -\u003e \u0026mut [S] {\n        \u0026mut self.data\n    }\n\n    /// Get the scalar value at position (i, j).\n    ///\n    /// This is a convenience method that extracts the underlying scalar\n    /// without requiring a trait import.\n    ///\n    /// # Example\n    ///\n    /// ```\n    /// use tropical_gemm::{Mat, MaxPlus};\n    ///\n    /// let m = Mat::\u003cMaxPlus\u003cf64\u003e\u003e::from_row_major(\u0026[1.0, 2.0, 3.0, 4.0], 2, 2);\n    /// assert_eq!(m.get_value(0, 0), 1.0);\n    /// assert_eq!(m.get_value(1, 1), 4.0);\n    /// ```\n    #[inline]\n    pub fn get_value(\u0026self, i: usize, j: usize) -\u003e S::Scalar {\n        self[(i, j)].value()\n    }\n\n    /// Convert to an immutable matrix reference.\n    ///\n    /// The returned reference views the scalar values.\n    pub fn as_ref(\u0026self) -\u003e MatRef\u003c'_, S\u003e\n    where\n        S::Scalar: Copy,\n    {\n        // Extract scalars from semiring values\n        // This requires that the data is laid out such that we can get scalars\n        // For now, we create a view that extracts values on-the-fly\n        // This is a limitation - ideally we'd have a separate scalar buffer\n        MatRef::from_mat(self)\n    }\n\n    /// Get a mutable pointer to the data.\n    #[inline]\n    pub fn as_mut_ptr(\u0026mut self) -\u003e *mut S {\n        self.data.as_mut_ptr()\n    }\n}\n\nimpl\u003cS: TropicalSemiring\u003e Index\u003c(usize, usize)\u003e for Mat\u003cS\u003e {\n    type Output = S;\n\n    #[inline]\n    fn index(\u0026self, (i, j): (usize, usize)) -\u003e \u0026S {\n        debug_assert!(\n            i \u003c self.nrows,\n            \"row index {} out of bounds {}\",\n            i,\n            self.nrows\n        );\n        debug_assert!(\n            j \u003c self.ncols,\n            \"col index {} out of bounds {}\",\n            j,\n            self.ncols\n        );\n        \u0026self.data[i * self.ncols + j]\n    }\n}\n\nimpl\u003cS: TropicalSemiring\u003e IndexMut\u003c(usize, usize)\u003e for Mat\u003cS\u003e {\n    #[inline]\n    fn index_mut(\u0026mut self, (i, j): (usize, usize)) -\u003e \u0026mut S {\n        debug_assert!(\n            i \u003c self.nrows,\n            \"row index {} out of bounds {}\",\n            i,\n            self.nrows\n        );\n        debug_assert!(\n            j \u003c self.ncols,\n            \"col index {} out of bounds {}\",\n            j,\n            self.ncols\n        );\n        \u0026mut self.data[i * self.ncols + j]\n    }\n}\n\n// Matrix multiplication methods directly on Mat\nimpl\u003cS\u003e Mat\u003cS\u003e\nwhere\n    S: TropicalSemiring + KernelDispatch,\n    S::Scalar: Copy,\n{\n    /// Perform tropical matrix multiplication: C = A ⊗ B.\n    ///\n    /// Computes C[i,j] = ⊕_k (A[i,k] ⊗ B[k,j])\n    ///\n    /// # Panics\n    ///\n    /// Panics if dimensions don't match (self.ncols != b.nrows).\n    ///\n    /// # Example\n    ///\n    /// ```\n    /// use tropical_gemm::{Mat, MaxPlus, TropicalSemiring};\n    ///\n    /// let a = Mat::\u003cMaxPlus\u003cf64\u003e\u003e::from_row_major(\u0026[1.0, 2.0, 3.0, 4.0, 5.0, 6.0], 2, 3);\n    /// let b = Mat::\u003cMaxPlus\u003cf64\u003e\u003e::from_row_major(\u0026[1.0, 2.0, 3.0, 4.0, 5.0, 6.0], 3, 2);\n    ///\n    /// let c = a.matmul(\u0026b);\n    ///\n    /// // C[0,0] = max(1+1, 2+3, 3+5) = 8\n    /// assert_eq!(c[(0, 0)].value(), 8.0);\n    /// ```\n    pub fn matmul(\u0026self, b: \u0026Mat\u003cS\u003e) -\u003e Mat\u003cS\u003e {\n        assert_eq!(\n            self.ncols, b.nrows,\n            \"dimension mismatch: A is {}x{}, B is {}x{}\",\n            self.nrows, self.ncols, b.nrows, b.ncols\n        );\n\n        let a_ref = self.as_ref();\n        let b_ref = b.as_ref();\n\n        let mut c = Mat::\u003cS\u003e::zeros(self.nrows, b.ncols);\n\n        unsafe {\n            tropical_gemm_dispatch::\u003cS\u003e(\n                self.nrows,\n                b.ncols,\n                self.ncols,\n                a_ref.as_slice().as_ptr(),\n                self.ncols,\n                Transpose::NoTrans,\n                b_ref.as_slice().as_ptr(),\n                b.ncols,\n                Transpose::NoTrans,\n                c.data.as_mut_ptr(),\n                b.ncols,\n            );\n        }\n\n        c\n    }\n\n    /// Perform tropical matrix multiplication with a MatRef.\n    ///\n    /// This allows mixing owned and reference matrices.\n    pub fn matmul_ref(\u0026self, b: \u0026MatRef\u003cS\u003e) -\u003e Mat\u003cS\u003e {\n        assert_eq!(\n            self.ncols,\n            b.nrows(),\n            \"dimension mismatch: A is {}x{}, B is {}x{}\",\n            self.nrows,\n            self.ncols,\n            b.nrows(),\n            b.ncols()\n        );\n\n        let a_ref = self.as_ref();\n\n        let mut c = Mat::\u003cS\u003e::zeros(self.nrows, b.ncols());\n\n        unsafe {\n            tropical_gemm_dispatch::\u003cS\u003e(\n                self.nrows,\n                b.ncols(),\n                self.ncols,\n                a_ref.as_slice().as_ptr(),\n                self.ncols,\n                Transpose::NoTrans,\n                b.as_slice().as_ptr(),\n                b.ncols(),\n                Transpose::NoTrans,\n                c.data.as_mut_ptr(),\n                b.ncols(),\n            );\n        }\n\n        c\n    }\n}\n\n// Argmax methods on Mat\nimpl\u003cS\u003e Mat\u003cS\u003e\nwhere\n    S: TropicalWithArgmax\u003cIndex = u32\u003e + KernelDispatch,\n    S::Scalar: Copy,\n{\n    /// Perform tropical matrix multiplication with argmax tracking.\n    ///\n    /// Returns both the result matrix and the argmax indices indicating\n    /// which k-index produced each optimal value.\n    ///\n    /// # Example\n    ///\n    /// ```\n    /// use tropical_gemm::{Mat, MaxPlus, TropicalSemiring};\n    ///\n    /// let a = Mat::\u003cMaxPlus\u003cf64\u003e\u003e::from_row_major(\u0026[1.0, 2.0, 3.0, 4.0, 5.0, 6.0], 2, 3);\n    /// let b = Mat::\u003cMaxPlus\u003cf64\u003e\u003e::from_row_major(\u0026[1.0, 2.0, 3.0, 4.0, 5.0, 6.0], 3, 2);\n    ///\n    /// let result = a.matmul_argmax(\u0026b);\n    ///\n    /// assert_eq!(result.get(0, 0).value(), 8.0);\n    /// assert_eq!(result.get_argmax(0, 0), 2); // k=2 gave max\n    /// ```\n    pub fn matmul_argmax(\u0026self, b: \u0026Mat\u003cS\u003e) -\u003e MatWithArgmax\u003cS\u003e {\n        assert_eq!(\n            self.ncols, b.nrows,\n            \"dimension mismatch: A is {}x{}, B is {}x{}\",\n            self.nrows, self.ncols, b.nrows, b.ncols\n        );\n\n        let a_ref = self.as_ref();\n        let b_ref = b.as_ref();\n\n        let m = self.nrows;\n        let n = b.ncols;\n        let k = self.ncols;\n\n        let mut result = crate::core::GemmWithArgmax::\u003cS\u003e::new(m, n);\n\n        unsafe {\n            crate::core::tropical_gemm_with_argmax_portable::\u003cS\u003e(\n                m,\n                n,\n                k,\n                a_ref.as_slice().as_ptr(),\n                self.ncols,\n                Transpose::NoTrans,\n                b_ref.as_slice().as_ptr(),\n                b.ncols,\n                Transpose::NoTrans,\n                \u0026mut result,\n            );\n        }\n\n        MatWithArgmax {\n            values: Mat::from_vec(result.values, m, n),\n            argmax: result.argmax,\n        }\n    }\n}\n","traces":[{"line":37,"address":[],"length":0,"stats":{"Line":10}},{"line":39,"address":[],"length":0,"stats":{"Line":40}},{"line":49,"address":[],"length":0,"stats":{"Line":1}},{"line":50,"address":[],"length":0,"stats":{"Line":4}},{"line":51,"address":[],"length":0,"stats":{"Line":7}},{"line":52,"address":[],"length":0,"stats":{"Line":6}},{"line":54,"address":[],"length":0,"stats":{"Line":1}},{"line":60,"address":[],"length":0,"stats":{"Line":2}},{"line":64,"address":[],"length":0,"stats":{"Line":4}},{"line":65,"address":[],"length":0,"stats":{"Line":38}},{"line":73,"address":[],"length":0,"stats":{"Line":11}},{"line":77,"address":[],"length":0,"stats":{"Line":11}},{"line":78,"address":[],"length":0,"stats":{"Line":22}},{"line":79,"address":[],"length":0,"stats":{"Line":11}},{"line":80,"address":[],"length":0,"stats":{"Line":0}},{"line":81,"address":[],"length":0,"stats":{"Line":0}},{"line":82,"address":[],"length":0,"stats":{"Line":0}},{"line":83,"address":[],"length":0,"stats":{"Line":0}},{"line":85,"address":[],"length":0,"stats":{"Line":167}},{"line":90,"address":[],"length":0,"stats":{"Line":2}},{"line":91,"address":[],"length":0,"stats":{"Line":2}},{"line":92,"address":[],"length":0,"stats":{"Line":4}},{"line":93,"address":[],"length":0,"stats":{"Line":2}},{"line":94,"address":[],"length":0,"stats":{"Line":0}},{"line":95,"address":[],"length":0,"stats":{"Line":0}},{"line":96,"address":[],"length":0,"stats":{"Line":0}},{"line":97,"address":[],"length":0,"stats":{"Line":0}},{"line":104,"address":[],"length":0,"stats":{"Line":2}},{"line":105,"address":[],"length":0,"stats":{"Line":2}},{"line":110,"address":[],"length":0,"stats":{"Line":4}},{"line":111,"address":[],"length":0,"stats":{"Line":4}},{"line":116,"address":[],"length":0,"stats":{"Line":0}},{"line":117,"address":[],"length":0,"stats":{"Line":0}},{"line":122,"address":[],"length":0,"stats":{"Line":0}},{"line":123,"address":[],"length":0,"stats":{"Line":0}},{"line":141,"address":[],"length":0,"stats":{"Line":4}},{"line":142,"address":[],"length":0,"stats":{"Line":12}},{"line":148,"address":[],"length":0,"stats":{"Line":11}},{"line":156,"address":[],"length":0,"stats":{"Line":22}},{"line":161,"address":[],"length":0,"stats":{"Line":0}},{"line":162,"address":[],"length":0,"stats":{"Line":0}},{"line":170,"address":[],"length":0,"stats":{"Line":30}},{"line":171,"address":[],"length":0,"stats":{"Line":30}},{"line":172,"address":[],"length":0,"stats":{"Line":30}},{"line":173,"address":[],"length":0,"stats":{"Line":0}},{"line":174,"address":[],"length":0,"stats":{"Line":0}},{"line":175,"address":[],"length":0,"stats":{"Line":0}},{"line":177,"address":[],"length":0,"stats":{"Line":30}},{"line":178,"address":[],"length":0,"stats":{"Line":30}},{"line":179,"address":[],"length":0,"stats":{"Line":0}},{"line":180,"address":[],"length":0,"stats":{"Line":0}},{"line":181,"address":[],"length":0,"stats":{"Line":0}},{"line":183,"address":[],"length":0,"stats":{"Line":60}},{"line":189,"address":[],"length":0,"stats":{"Line":0}},{"line":190,"address":[],"length":0,"stats":{"Line":0}},{"line":191,"address":[],"length":0,"stats":{"Line":0}},{"line":192,"address":[],"length":0,"stats":{"Line":0}},{"line":193,"address":[],"length":0,"stats":{"Line":0}},{"line":194,"address":[],"length":0,"stats":{"Line":0}},{"line":196,"address":[],"length":0,"stats":{"Line":0}},{"line":197,"address":[],"length":0,"stats":{"Line":0}},{"line":198,"address":[],"length":0,"stats":{"Line":0}},{"line":199,"address":[],"length":0,"stats":{"Line":0}},{"line":200,"address":[],"length":0,"stats":{"Line":0}},{"line":202,"address":[],"length":0,"stats":{"Line":0}},{"line":233,"address":[],"length":0,"stats":{"Line":2}},{"line":234,"address":[],"length":0,"stats":{"Line":2}},{"line":235,"address":[],"length":0,"stats":{"Line":0}},{"line":236,"address":[],"length":0,"stats":{"Line":0}},{"line":237,"address":[],"length":0,"stats":{"Line":0}},{"line":240,"address":[],"length":0,"stats":{"Line":6}},{"line":241,"address":[],"length":0,"stats":{"Line":6}},{"line":243,"address":[],"length":0,"stats":{"Line":8}},{"line":247,"address":[],"length":0,"stats":{"Line":4}},{"line":248,"address":[],"length":0,"stats":{"Line":4}},{"line":249,"address":[],"length":0,"stats":{"Line":4}},{"line":250,"address":[],"length":0,"stats":{"Line":6}},{"line":251,"address":[],"length":0,"stats":{"Line":4}},{"line":252,"address":[],"length":0,"stats":{"Line":4}},{"line":253,"address":[],"length":0,"stats":{"Line":6}},{"line":254,"address":[],"length":0,"stats":{"Line":4}},{"line":255,"address":[],"length":0,"stats":{"Line":4}},{"line":256,"address":[],"length":0,"stats":{"Line":4}},{"line":257,"address":[],"length":0,"stats":{"Line":2}},{"line":261,"address":[],"length":0,"stats":{"Line":2}},{"line":267,"address":[],"length":0,"stats":{"Line":0}},{"line":268,"address":[],"length":0,"stats":{"Line":0}},{"line":269,"address":[],"length":0,"stats":{"Line":0}},{"line":270,"address":[],"length":0,"stats":{"Line":0}},{"line":271,"address":[],"length":0,"stats":{"Line":0}},{"line":272,"address":[],"length":0,"stats":{"Line":0}},{"line":273,"address":[],"length":0,"stats":{"Line":0}},{"line":274,"address":[],"length":0,"stats":{"Line":0}},{"line":275,"address":[],"length":0,"stats":{"Line":0}},{"line":278,"address":[],"length":0,"stats":{"Line":0}},{"line":280,"address":[],"length":0,"stats":{"Line":0}},{"line":284,"address":[],"length":0,"stats":{"Line":0}},{"line":285,"address":[],"length":0,"stats":{"Line":0}},{"line":286,"address":[],"length":0,"stats":{"Line":0}},{"line":287,"address":[],"length":0,"stats":{"Line":0}},{"line":288,"address":[],"length":0,"stats":{"Line":0}},{"line":289,"address":[],"length":0,"stats":{"Line":0}},{"line":290,"address":[],"length":0,"stats":{"Line":0}},{"line":291,"address":[],"length":0,"stats":{"Line":0}},{"line":292,"address":[],"length":0,"stats":{"Line":0}},{"line":293,"address":[],"length":0,"stats":{"Line":0}},{"line":294,"address":[],"length":0,"stats":{"Line":0}},{"line":298,"address":[],"length":0,"stats":{"Line":0}},{"line":326,"address":[],"length":0,"stats":{"Line":1}},{"line":327,"address":[],"length":0,"stats":{"Line":1}},{"line":328,"address":[],"length":0,"stats":{"Line":0}},{"line":329,"address":[],"length":0,"stats":{"Line":0}},{"line":330,"address":[],"length":0,"stats":{"Line":0}},{"line":333,"address":[],"length":0,"stats":{"Line":3}},{"line":334,"address":[],"length":0,"stats":{"Line":3}},{"line":336,"address":[],"length":0,"stats":{"Line":2}},{"line":337,"address":[],"length":0,"stats":{"Line":2}},{"line":338,"address":[],"length":0,"stats":{"Line":2}},{"line":340,"address":[],"length":0,"stats":{"Line":4}},{"line":344,"address":[],"length":0,"stats":{"Line":2}},{"line":345,"address":[],"length":0,"stats":{"Line":2}},{"line":346,"address":[],"length":0,"stats":{"Line":2}},{"line":347,"address":[],"length":0,"stats":{"Line":3}},{"line":348,"address":[],"length":0,"stats":{"Line":2}},{"line":349,"address":[],"length":0,"stats":{"Line":2}},{"line":350,"address":[],"length":0,"stats":{"Line":3}},{"line":351,"address":[],"length":0,"stats":{"Line":2}},{"line":352,"address":[],"length":0,"stats":{"Line":1}},{"line":353,"address":[],"length":0,"stats":{"Line":1}},{"line":358,"address":[],"length":0,"stats":{"Line":4}},{"line":359,"address":[],"length":0,"stats":{"Line":1}}],"covered":70,"coverable":131},{"path":["/","home","leo","rcode","cutropicalgemm","crates","tropical-gemm","src","mat","ref_.rs"],"content":"//! Immutable matrix reference type.\n\nuse std::marker::PhantomData;\n\nuse crate::core::Transpose;\nuse crate::simd::{tropical_gemm_dispatch, KernelDispatch};\nuse crate::types::{TropicalSemiring, TropicalWithArgmax};\n\nuse super::{Mat, MatWithArgmax};\n\n/// Immutable view over scalar data interpreted as a tropical matrix.\n///\n/// This is a lightweight view type that can be copied freely.\n/// It references scalar data and interprets operations using the\n/// specified semiring type.\n///\n/// ```\n/// use tropical_gemm::{MatRef, MaxPlus};\n///\n/// let data = [1.0f32, 2.0, 3.0, 4.0, 5.0, 6.0];\n/// let a = MatRef::\u003cMaxPlus\u003cf32\u003e\u003e::from_slice(\u0026data, 2, 3);\n///\n/// assert_eq!(a.nrows(), 2);\n/// assert_eq!(a.ncols(), 3);\n/// assert_eq!(a.get(0, 0), 1.0);\n/// ```\n#[derive(Debug)]\npub struct MatRef\u003c'a, S: TropicalSemiring\u003e {\n    data: \u0026'a [S::Scalar],\n    nrows: usize,\n    ncols: usize,\n    _phantom: PhantomData\u003cS\u003e,\n}\n\nimpl\u003c'a, S: TropicalSemiring\u003e Copy for MatRef\u003c'a, S\u003e {}\n\nimpl\u003c'a, S: TropicalSemiring\u003e Clone for MatRef\u003c'a, S\u003e {\n    fn clone(\u0026self) -\u003e Self {\n        *self\n    }\n}\n\nimpl\u003c'a, S: TropicalSemiring\u003e MatRef\u003c'a, S\u003e {\n    /// Create a matrix reference from a slice of scalars.\n    ///\n    /// The data must be in row-major order with length `nrows * ncols`.\n    pub fn from_slice(data: \u0026'a [S::Scalar], nrows: usize, ncols: usize) -\u003e Self {\n        assert_eq!(\n            data.len(),\n            nrows * ncols,\n            \"data length {} != nrows {} * ncols {}\",\n            data.len(),\n            nrows,\n            ncols\n        );\n        Self {\n            data,\n            nrows,\n            ncols,\n            _phantom: PhantomData,\n        }\n    }\n\n    /// Create a matrix reference from an owned Mat.\n    ///\n    /// This extracts the scalar values from the semiring wrapper.\n    pub(crate) fn from_mat(mat: \u0026'a Mat\u003cS\u003e) -\u003e Self\n    where\n        S::Scalar: Copy,\n    {\n        // We need to get scalars from the Mat\u003cS\u003e which stores S values\n        // Since S wraps Scalar, we can use value() to extract\n        // But MatRef needs \u0026[Scalar], not \u0026[S]\n        // This is a design tension - for now we'll use unsafe transmute\n        // since S is repr(transparent) over Scalar\n        //\n        // Safety: TropicalMaxPlus\u003cT\u003e, TropicalMinPlus\u003cT\u003e, etc. are all\n        // repr(transparent) newtype wrappers over T\n        let scalar_slice = unsafe {\n            std::slice::from_raw_parts(mat.data.as_ptr() as *const S::Scalar, mat.data.len())\n        };\n        Self {\n            data: scalar_slice,\n            nrows: mat.nrows,\n            ncols: mat.ncols,\n            _phantom: PhantomData,\n        }\n    }\n\n    /// Number of rows.\n    #[inline]\n    pub fn nrows(\u0026self) -\u003e usize {\n        self.nrows\n    }\n\n    /// Number of columns.\n    #[inline]\n    pub fn ncols(\u0026self) -\u003e usize {\n        self.ncols\n    }\n\n    /// Get the underlying scalar data.\n    #[inline]\n    pub fn as_slice(\u0026self) -\u003e \u0026[S::Scalar] {\n        self.data\n    }\n\n    /// Get the scalar value at position (i, j).\n    #[inline]\n    pub fn get(\u0026self, i: usize, j: usize) -\u003e S::Scalar\n    where\n        S::Scalar: Copy,\n    {\n        debug_assert!(\n            i \u003c self.nrows,\n            \"row index {} out of bounds {}\",\n            i,\n            self.nrows\n        );\n        debug_assert!(\n            j \u003c self.ncols,\n            \"col index {} out of bounds {}\",\n            j,\n            self.ncols\n        );\n        self.data[i * self.ncols + j]\n    }\n\n    /// Convert to an owned matrix.\n    pub fn to_owned(\u0026self) -\u003e Mat\u003cS\u003e\n    where\n        S::Scalar: Copy,\n    {\n        Mat::from_row_major(self.data, self.nrows, self.ncols)\n    }\n}\n\n// Matrix multiplication methods\nimpl\u003c'a, S: TropicalSemiring + KernelDispatch\u003e MatRef\u003c'a, S\u003e {\n    /// Perform tropical matrix multiplication: C = A ⊗ B.\n    ///\n    /// Computes C[i,j] = ⊕_k (A[i,k] ⊗ B[k,j])\n    ///\n    /// # Panics\n    ///\n    /// Panics if dimensions don't match (self.ncols != b.nrows).\n    pub fn matmul(\u0026self, b: \u0026MatRef\u003cS\u003e) -\u003e Mat\u003cS\u003e {\n        assert_eq!(\n            self.ncols, b.nrows,\n            \"dimension mismatch: A is {}x{}, B is {}x{}\",\n            self.nrows, self.ncols, b.nrows, b.ncols\n        );\n\n        let mut c = Mat::\u003cS\u003e::zeros(self.nrows, b.ncols);\n\n        unsafe {\n            tropical_gemm_dispatch::\u003cS\u003e(\n                self.nrows,\n                b.ncols,\n                self.ncols,\n                self.data.as_ptr(),\n                self.ncols,\n                Transpose::NoTrans,\n                b.data.as_ptr(),\n                b.ncols,\n                Transpose::NoTrans,\n                c.data.as_mut_ptr(),\n                b.ncols,\n            );\n        }\n\n        c\n    }\n}\n\n// Argmax methods (separate impl block for different trait bounds)\nimpl\u003c'a, S\u003e MatRef\u003c'a, S\u003e\nwhere\n    S: TropicalWithArgmax\u003cIndex = u32\u003e + KernelDispatch,\n{\n    /// Perform tropical matrix multiplication with argmax tracking.\n    ///\n    /// Returns both the result matrix and the argmax indices indicating\n    /// which k-index produced each optimal value.\n    ///\n    /// # Panics\n    ///\n    /// Panics if dimensions don't match (self.ncols != b.nrows).\n    pub fn matmul_argmax(\u0026self, b: \u0026MatRef\u003cS\u003e) -\u003e MatWithArgmax\u003cS\u003e {\n        assert_eq!(\n            self.ncols, b.nrows,\n            \"dimension mismatch: A is {}x{}, B is {}x{}\",\n            self.nrows, self.ncols, b.nrows, b.ncols\n        );\n\n        let m = self.nrows;\n        let n = b.ncols;\n        let k = self.ncols;\n\n        let mut result = crate::core::GemmWithArgmax::\u003cS\u003e::new(m, n);\n\n        unsafe {\n            crate::core::tropical_gemm_with_argmax_portable::\u003cS\u003e(\n                m,\n                n,\n                k,\n                self.data.as_ptr(),\n                self.ncols,\n                Transpose::NoTrans,\n                b.data.as_ptr(),\n                b.ncols,\n                Transpose::NoTrans,\n                \u0026mut result,\n            );\n        }\n\n        MatWithArgmax {\n            values: Mat::from_vec(result.values, m, n),\n            argmax: result.argmax,\n        }\n    }\n}\n","traces":[{"line":38,"address":[],"length":0,"stats":{"Line":0}},{"line":39,"address":[],"length":0,"stats":{"Line":0}},{"line":47,"address":[],"length":0,"stats":{"Line":11}},{"line":48,"address":[],"length":0,"stats":{"Line":11}},{"line":49,"address":[],"length":0,"stats":{"Line":22}},{"line":50,"address":[],"length":0,"stats":{"Line":11}},{"line":51,"address":[],"length":0,"stats":{"Line":0}},{"line":52,"address":[],"length":0,"stats":{"Line":0}},{"line":53,"address":[],"length":0,"stats":{"Line":0}},{"line":54,"address":[],"length":0,"stats":{"Line":0}},{"line":67,"address":[],"length":0,"stats":{"Line":11}},{"line":80,"address":[],"length":0,"stats":{"Line":55}},{"line":84,"address":[],"length":0,"stats":{"Line":22}},{"line":85,"address":[],"length":0,"stats":{"Line":11}},{"line":92,"address":[],"length":0,"stats":{"Line":2}},{"line":93,"address":[],"length":0,"stats":{"Line":2}},{"line":98,"address":[],"length":0,"stats":{"Line":2}},{"line":99,"address":[],"length":0,"stats":{"Line":2}},{"line":104,"address":[],"length":0,"stats":{"Line":6}},{"line":105,"address":[],"length":0,"stats":{"Line":6}},{"line":110,"address":[],"length":0,"stats":{"Line":4}},{"line":114,"address":[],"length":0,"stats":{"Line":4}},{"line":115,"address":[],"length":0,"stats":{"Line":4}},{"line":116,"address":[],"length":0,"stats":{"Line":0}},{"line":117,"address":[],"length":0,"stats":{"Line":0}},{"line":118,"address":[],"length":0,"stats":{"Line":0}},{"line":120,"address":[],"length":0,"stats":{"Line":4}},{"line":121,"address":[],"length":0,"stats":{"Line":4}},{"line":122,"address":[],"length":0,"stats":{"Line":0}},{"line":123,"address":[],"length":0,"stats":{"Line":0}},{"line":124,"address":[],"length":0,"stats":{"Line":0}},{"line":126,"address":[],"length":0,"stats":{"Line":4}},{"line":130,"address":[],"length":0,"stats":{"Line":0}},{"line":134,"address":[],"length":0,"stats":{"Line":0}},{"line":147,"address":[],"length":0,"stats":{"Line":6}},{"line":148,"address":[],"length":0,"stats":{"Line":6}},{"line":149,"address":[],"length":0,"stats":{"Line":0}},{"line":150,"address":[],"length":0,"stats":{"Line":0}},{"line":151,"address":[],"length":0,"stats":{"Line":0}},{"line":154,"address":[],"length":0,"stats":{"Line":24}},{"line":158,"address":[],"length":0,"stats":{"Line":12}},{"line":159,"address":[],"length":0,"stats":{"Line":12}},{"line":160,"address":[],"length":0,"stats":{"Line":12}},{"line":161,"address":[],"length":0,"stats":{"Line":18}},{"line":162,"address":[],"length":0,"stats":{"Line":12}},{"line":163,"address":[],"length":0,"stats":{"Line":12}},{"line":164,"address":[],"length":0,"stats":{"Line":18}},{"line":165,"address":[],"length":0,"stats":{"Line":12}},{"line":166,"address":[],"length":0,"stats":{"Line":12}},{"line":167,"address":[],"length":0,"stats":{"Line":12}},{"line":168,"address":[],"length":0,"stats":{"Line":6}},{"line":172,"address":[],"length":0,"stats":{"Line":6}},{"line":189,"address":[],"length":0,"stats":{"Line":1}},{"line":190,"address":[],"length":0,"stats":{"Line":1}},{"line":191,"address":[],"length":0,"stats":{"Line":0}},{"line":192,"address":[],"length":0,"stats":{"Line":0}},{"line":193,"address":[],"length":0,"stats":{"Line":0}},{"line":196,"address":[],"length":0,"stats":{"Line":2}},{"line":197,"address":[],"length":0,"stats":{"Line":2}},{"line":198,"address":[],"length":0,"stats":{"Line":2}},{"line":200,"address":[],"length":0,"stats":{"Line":4}},{"line":204,"address":[],"length":0,"stats":{"Line":2}},{"line":205,"address":[],"length":0,"stats":{"Line":2}},{"line":206,"address":[],"length":0,"stats":{"Line":2}},{"line":207,"address":[],"length":0,"stats":{"Line":3}},{"line":208,"address":[],"length":0,"stats":{"Line":2}},{"line":209,"address":[],"length":0,"stats":{"Line":2}},{"line":210,"address":[],"length":0,"stats":{"Line":3}},{"line":211,"address":[],"length":0,"stats":{"Line":2}},{"line":212,"address":[],"length":0,"stats":{"Line":1}},{"line":213,"address":[],"length":0,"stats":{"Line":1}},{"line":218,"address":[],"length":0,"stats":{"Line":4}},{"line":219,"address":[],"length":0,"stats":{"Line":1}}],"covered":53,"coverable":73},{"path":["/","home","leo","rcode","cutropicalgemm","crates","tropical-gemm","src","simd","kernels","avx2.rs"],"content":"use crate::core::Microkernel;\nuse crate::types::{TropicalMaxMul, TropicalMaxPlus, TropicalMinPlus};\nuse wide::{f32x8, f64x4};\n\n/// AVX2 microkernel for TropicalMaxPlus\u003cf32\u003e.\n///\n/// Uses 8x8 register blocking with f32x8 vectors.\n/// Total: 8 accumulators × 8 lanes = 64 elements in registers.\n#[derive(Default, Clone, Copy)]\npub struct Avx2MaxPlusF32Kernel;\n\nimpl Microkernel\u003cTropicalMaxPlus\u003cf32\u003e\u003e for Avx2MaxPlusF32Kernel {\n    const MR: usize = 8;\n    const NR: usize = 8;\n\n    #[target_feature(enable = \"avx2\")]\n    unsafe fn execute(\n        \u0026self,\n        mr: usize,\n        nr: usize,\n        k: usize,\n        a: *const f32,\n        b: *const f32,\n        c: *mut TropicalMaxPlus\u003cf32\u003e,\n        ldc: usize,\n    ) {\n        // Initialize accumulators with -inf\n        let neg_inf = f32x8::splat(f32::NEG_INFINITY);\n        let mut acc = [neg_inf; 8];\n\n        // Load existing C values into accumulators\n        for i in 0..mr {\n            let mut row_acc = [f32::NEG_INFINITY; 8];\n            for j in 0..nr {\n                row_acc[j] = (*c.add(i * ldc + j)).0;\n            }\n            acc[i] = f32x8::from(row_acc);\n        }\n\n        // Main computation loop\n        for p in 0..k {\n            // Load A column (mr elements, padded to 8)\n            let mut a_vals = [0.0f32; 8];\n            for i in 0..mr {\n                a_vals[i] = *a.add(p * Self::MR + i);\n            }\n\n            // Load B row (nr elements, padded to 8)\n            let mut b_vals = [0.0f32; 8];\n            for j in 0..nr {\n                b_vals[j] = *b.add(p * Self::NR + j);\n            }\n            let b_vec = f32x8::from(b_vals);\n\n            // For each row of A\n            for i in 0..mr {\n                // Tropical mul: a[i] + b[j] for all j\n                let a_broadcast = f32x8::splat(a_vals[i]);\n                let product = a_broadcast + b_vec;\n\n                // Tropical add: max(acc, product)\n                acc[i] = acc[i].max(product);\n            }\n        }\n\n        // Write back results\n        for i in 0..mr {\n            let row: [f32; 8] = acc[i].into();\n            for j in 0..nr {\n                *c.add(i * ldc + j) = TropicalMaxPlus(row[j]);\n            }\n        }\n    }\n}\n\n/// AVX2 microkernel for TropicalMaxPlus\u003cf64\u003e.\n#[derive(Default, Clone, Copy)]\npub struct Avx2MaxPlusF64Kernel;\n\nimpl Microkernel\u003cTropicalMaxPlus\u003cf64\u003e\u003e for Avx2MaxPlusF64Kernel {\n    const MR: usize = 4;\n    const NR: usize = 4;\n\n    #[target_feature(enable = \"avx2\")]\n    unsafe fn execute(\n        \u0026self,\n        mr: usize,\n        nr: usize,\n        k: usize,\n        a: *const f64,\n        b: *const f64,\n        c: *mut TropicalMaxPlus\u003cf64\u003e,\n        ldc: usize,\n    ) {\n        let neg_inf = f64x4::splat(f64::NEG_INFINITY);\n        let mut acc = [neg_inf; 4];\n\n        // Load existing C\n        for i in 0..mr {\n            let mut row_acc = [f64::NEG_INFINITY; 4];\n            for j in 0..nr {\n                row_acc[j] = (*c.add(i * ldc + j)).0;\n            }\n            acc[i] = f64x4::from(row_acc);\n        }\n\n        // Main loop\n        for p in 0..k {\n            let mut a_vals = [0.0f64; 4];\n            for i in 0..mr {\n                a_vals[i] = *a.add(p * Self::MR + i);\n            }\n\n            let mut b_vals = [0.0f64; 4];\n            for j in 0..nr {\n                b_vals[j] = *b.add(p * Self::NR + j);\n            }\n            let b_vec = f64x4::from(b_vals);\n\n            for i in 0..mr {\n                let a_broadcast = f64x4::splat(a_vals[i]);\n                let product = a_broadcast + b_vec;\n                acc[i] = acc[i].max(product);\n            }\n        }\n\n        // Write back\n        for i in 0..mr {\n            let row: [f64; 4] = acc[i].into();\n            for j in 0..nr {\n                *c.add(i * ldc + j) = TropicalMaxPlus(row[j]);\n            }\n        }\n    }\n}\n\n/// AVX2 microkernel for TropicalMinPlus\u003cf32\u003e.\n#[derive(Default, Clone, Copy)]\npub struct Avx2MinPlusF32Kernel;\n\nimpl Microkernel\u003cTropicalMinPlus\u003cf32\u003e\u003e for Avx2MinPlusF32Kernel {\n    const MR: usize = 8;\n    const NR: usize = 8;\n\n    #[target_feature(enable = \"avx2\")]\n    unsafe fn execute(\n        \u0026self,\n        mr: usize,\n        nr: usize,\n        k: usize,\n        a: *const f32,\n        b: *const f32,\n        c: *mut TropicalMinPlus\u003cf32\u003e,\n        ldc: usize,\n    ) {\n        let pos_inf = f32x8::splat(f32::INFINITY);\n        let mut acc = [pos_inf; 8];\n\n        // Load existing C\n        for i in 0..mr {\n            let mut row_acc = [f32::INFINITY; 8];\n            for j in 0..nr {\n                row_acc[j] = (*c.add(i * ldc + j)).0;\n            }\n            acc[i] = f32x8::from(row_acc);\n        }\n\n        // Main loop\n        for p in 0..k {\n            let mut a_vals = [0.0f32; 8];\n            for i in 0..mr {\n                a_vals[i] = *a.add(p * Self::MR + i);\n            }\n\n            let mut b_vals = [0.0f32; 8];\n            for j in 0..nr {\n                b_vals[j] = *b.add(p * Self::NR + j);\n            }\n            let b_vec = f32x8::from(b_vals);\n\n            for i in 0..mr {\n                let a_broadcast = f32x8::splat(a_vals[i]);\n                let product = a_broadcast + b_vec;\n                // MinPlus: tropical add = min\n                acc[i] = acc[i].min(product);\n            }\n        }\n\n        // Write back\n        for i in 0..mr {\n            let row: [f32; 8] = acc[i].into();\n            for j in 0..nr {\n                *c.add(i * ldc + j) = TropicalMinPlus(row[j]);\n            }\n        }\n    }\n}\n\n/// AVX2 microkernel for TropicalMaxMul\u003cf32\u003e.\n#[derive(Default, Clone, Copy)]\npub struct Avx2MaxMulF32Kernel;\n\nimpl Microkernel\u003cTropicalMaxMul\u003cf32\u003e\u003e for Avx2MaxMulF32Kernel {\n    const MR: usize = 8;\n    const NR: usize = 8;\n\n    #[target_feature(enable = \"avx2\")]\n    unsafe fn execute(\n        \u0026self,\n        mr: usize,\n        nr: usize,\n        k: usize,\n        a: *const f32,\n        b: *const f32,\n        c: *mut TropicalMaxMul\u003cf32\u003e,\n        ldc: usize,\n    ) {\n        let zero = f32x8::splat(0.0);\n        let mut acc = [zero; 8];\n\n        // Load existing C\n        for i in 0..mr {\n            let mut row_acc = [0.0f32; 8];\n            for j in 0..nr {\n                row_acc[j] = (*c.add(i * ldc + j)).0;\n            }\n            acc[i] = f32x8::from(row_acc);\n        }\n\n        // Main loop\n        for p in 0..k {\n            let mut a_vals = [0.0f32; 8];\n            for i in 0..mr {\n                a_vals[i] = *a.add(p * Self::MR + i);\n            }\n\n            let mut b_vals = [0.0f32; 8];\n            for j in 0..nr {\n                b_vals[j] = *b.add(p * Self::NR + j);\n            }\n            let b_vec = f32x8::from(b_vals);\n\n            for i in 0..mr {\n                let a_broadcast = f32x8::splat(a_vals[i]);\n                // MaxMul: tropical mul = standard mul\n                let product = a_broadcast * b_vec;\n                // tropical add = max\n                acc[i] = acc[i].max(product);\n            }\n        }\n\n        // Write back\n        for i in 0..mr {\n            let row: [f32; 8] = acc[i].into();\n            for j in 0..nr {\n                *c.add(i * ldc + j) = TropicalMaxMul(row[j]);\n            }\n        }\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use crate::types::TropicalSemiring;\n\n    #[test]\n    #[cfg(target_arch = \"x86_64\")]\n    fn test_avx2_max_plus_f32() {\n        if !is_x86_feature_detected!(\"avx2\") {\n            println!(\"AVX2 not available, skipping test\");\n            return;\n        }\n\n        let kernel = Avx2MaxPlusF32Kernel;\n        let mr = 2;\n        let nr = 2;\n        let k = 3;\n\n        // A: 2x3 packed\n        let a: [f32; 24] = [\n            1.0, 4.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, // col 0\n            2.0, 5.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, // col 1\n            3.0, 6.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, // col 2\n        ];\n\n        // B: 3x2 packed\n        let b: [f32; 24] = [\n            1.0, 2.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, // row 0\n            3.0, 4.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, // row 1\n            5.0, 6.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, // row 2\n        ];\n\n        let mut c = vec![TropicalMaxPlus::tropical_zero(); 4];\n        let ldc = 2;\n\n        unsafe {\n            kernel.execute(mr, nr, k, a.as_ptr(), b.as_ptr(), c.as_mut_ptr(), ldc);\n        }\n\n        // C[0,0] = max(1+1, 2+3, 3+5) = 8\n        assert!((c[0].0 - 8.0).abs() \u003c 1e-6);\n        // C[0,1] = max(1+2, 2+4, 3+6) = 9\n        assert!((c[1].0 - 9.0).abs() \u003c 1e-6);\n        // C[1,0] = max(4+1, 5+3, 6+5) = 11\n        assert!((c[2].0 - 11.0).abs() \u003c 1e-6);\n        // C[1,1] = max(4+2, 5+4, 6+6) = 12\n        assert!((c[3].0 - 12.0).abs() \u003c 1e-6);\n    }\n\n    #[test]\n    #[cfg(target_arch = \"x86_64\")]\n    fn test_avx2_min_plus_f32() {\n        if !is_x86_feature_detected!(\"avx2\") {\n            println!(\"AVX2 not available, skipping test\");\n            return;\n        }\n\n        let kernel = Avx2MinPlusF32Kernel;\n        let mr = 2;\n        let nr = 2;\n        let k = 3;\n\n        // A: 2x3 packed\n        let a: [f32; 24] = [\n            1.0, 4.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 2.0, 5.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 3.0,\n            6.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0,\n        ];\n\n        // B: 3x2 packed\n        let b: [f32; 24] = [\n            1.0, 2.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 3.0, 4.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 5.0,\n            6.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0,\n        ];\n\n        let mut c = vec![TropicalMinPlus::tropical_zero(); 4];\n        let ldc = 2;\n\n        unsafe {\n            kernel.execute(mr, nr, k, a.as_ptr(), b.as_ptr(), c.as_mut_ptr(), ldc);\n        }\n\n        // C[0,0] = min(1+1, 2+3, 3+5) = 2\n        assert!((c[0].0 - 2.0).abs() \u003c 1e-6);\n        // C[0,1] = min(1+2, 2+4, 3+6) = 3\n        assert!((c[1].0 - 3.0).abs() \u003c 1e-6);\n        // C[1,0] = min(4+1, 5+3, 6+5) = 5\n        assert!((c[2].0 - 5.0).abs() \u003c 1e-6);\n        // C[1,1] = min(4+2, 5+4, 6+6) = 6\n        assert!((c[3].0 - 6.0).abs() \u003c 1e-6);\n    }\n\n    #[test]\n    #[cfg(target_arch = \"x86_64\")]\n    fn test_avx2_max_mul_f32() {\n        if !is_x86_feature_detected!(\"avx2\") {\n            println!(\"AVX2 not available, skipping test\");\n            return;\n        }\n\n        let kernel = Avx2MaxMulF32Kernel;\n        let mr = 2;\n        let nr = 2;\n        let k = 2;\n\n        // A: 2x2 packed\n        let a: [f32; 16] = [\n            2.0, 3.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 4.0, 5.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0,\n        ];\n\n        // B: 2x2 packed\n        let b: [f32; 16] = [\n            1.0, 2.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 3.0, 4.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0,\n        ];\n\n        let mut c = vec![TropicalMaxMul::tropical_zero(); 4];\n        let ldc = 2;\n\n        unsafe {\n            kernel.execute(mr, nr, k, a.as_ptr(), b.as_ptr(), c.as_mut_ptr(), ldc);\n        }\n\n        // C[0,0] = max(2*1, 4*3) = max(2, 12) = 12\n        assert!((c[0].0 - 12.0).abs() \u003c 1e-6);\n        // C[0,1] = max(2*2, 4*4) = max(4, 16) = 16\n        assert!((c[1].0 - 16.0).abs() \u003c 1e-6);\n        // C[1,0] = max(3*1, 5*3) = max(3, 15) = 15\n        assert!((c[2].0 - 15.0).abs() \u003c 1e-6);\n        // C[1,1] = max(3*2, 5*4) = max(6, 20) = 20\n        assert!((c[3].0 - 20.0).abs() \u003c 1e-6);\n    }\n\n    #[test]\n    #[cfg(target_arch = \"x86_64\")]\n    fn test_avx2_max_plus_f64() {\n        if !is_x86_feature_detected!(\"avx2\") {\n            println!(\"AVX2 not available, skipping test\");\n            return;\n        }\n\n        let kernel = Avx2MaxPlusF64Kernel;\n        let mr = 2;\n        let nr = 2;\n        let k = 2;\n\n        // A: 2x2 packed (4 f64 per column for mr=4 padding)\n        let a: [f64; 8] = [\n            1.0, 2.0, 0.0, 0.0, // col 0\n            3.0, 4.0, 0.0, 0.0, // col 1\n        ];\n\n        // B: 2x2 packed (4 f64 per row for nr=4 padding)\n        let b: [f64; 8] = [\n            1.0, 2.0, 0.0, 0.0, // row 0\n            3.0, 4.0, 0.0, 0.0, // row 1\n        ];\n\n        let mut c = vec![TropicalMaxPlus::tropical_zero(); 4];\n        let ldc = 2;\n\n        unsafe {\n            kernel.execute(mr, nr, k, a.as_ptr(), b.as_ptr(), c.as_mut_ptr(), ldc);\n        }\n\n        // C[0,0] = max(1+1, 3+3) = 6\n        assert!((c[0].0 - 6.0).abs() \u003c 1e-10);\n        // C[0,1] = max(1+2, 3+4) = 7\n        assert!((c[1].0 - 7.0).abs() \u003c 1e-10);\n        // C[1,0] = max(2+1, 4+3) = 7\n        assert!((c[2].0 - 7.0).abs() \u003c 1e-10);\n        // C[1,1] = max(2+2, 4+4) = 8\n        assert!((c[3].0 - 8.0).abs() \u003c 1e-10);\n    }\n}\n","traces":[{"line":17,"address":[],"length":0,"stats":{"Line":10}},{"line":28,"address":[],"length":0,"stats":{"Line":20}},{"line":29,"address":[],"length":0,"stats":{"Line":20}},{"line":32,"address":[],"length":0,"stats":{"Line":54}},{"line":33,"address":[],"length":0,"stats":{"Line":88}},{"line":34,"address":[],"length":0,"stats":{"Line":604}},{"line":35,"address":[],"length":0,"stats":{"Line":1120}},{"line":37,"address":[],"length":0,"stats":{"Line":88}},{"line":41,"address":[],"length":0,"stats":{"Line":91}},{"line":43,"address":[],"length":0,"stats":{"Line":162}},{"line":44,"address":[],"length":0,"stats":{"Line":1173}},{"line":45,"address":[],"length":0,"stats":{"Line":2184}},{"line":49,"address":[],"length":0,"stats":{"Line":162}},{"line":50,"address":[],"length":0,"stats":{"Line":1173}},{"line":51,"address":[],"length":0,"stats":{"Line":2184}},{"line":53,"address":[],"length":0,"stats":{"Line":243}},{"line":56,"address":[],"length":0,"stats":{"Line":1173}},{"line":58,"address":[],"length":0,"stats":{"Line":2184}},{"line":59,"address":[],"length":0,"stats":{"Line":1638}},{"line":62,"address":[],"length":0,"stats":{"Line":1638}},{"line":67,"address":[],"length":0,"stats":{"Line":54}},{"line":68,"address":[],"length":0,"stats":{"Line":176}},{"line":69,"address":[],"length":0,"stats":{"Line":604}},{"line":70,"address":[],"length":0,"stats":{"Line":840}},{"line":85,"address":[],"length":0,"stats":{"Line":29}},{"line":95,"address":[],"length":0,"stats":{"Line":58}},{"line":96,"address":[],"length":0,"stats":{"Line":58}},{"line":99,"address":[],"length":0,"stats":{"Line":119}},{"line":100,"address":[],"length":0,"stats":{"Line":180}},{"line":101,"address":[],"length":0,"stats":{"Line":716}},{"line":102,"address":[],"length":0,"stats":{"Line":1252}},{"line":104,"address":[],"length":0,"stats":{"Line":180}},{"line":108,"address":[],"length":0,"stats":{"Line":315}},{"line":109,"address":[],"length":0,"stats":{"Line":572}},{"line":110,"address":[],"length":0,"stats":{"Line":2456}},{"line":111,"address":[],"length":0,"stats":{"Line":4340}},{"line":114,"address":[],"length":0,"stats":{"Line":572}},{"line":115,"address":[],"length":0,"stats":{"Line":2460}},{"line":116,"address":[],"length":0,"stats":{"Line":4348}},{"line":118,"address":[],"length":0,"stats":{"Line":858}},{"line":120,"address":[],"length":0,"stats":{"Line":2456}},{"line":121,"address":[],"length":0,"stats":{"Line":4340}},{"line":122,"address":[],"length":0,"stats":{"Line":3255}},{"line":123,"address":[],"length":0,"stats":{"Line":3255}},{"line":128,"address":[],"length":0,"stats":{"Line":119}},{"line":129,"address":[],"length":0,"stats":{"Line":360}},{"line":130,"address":[],"length":0,"stats":{"Line":716}},{"line":131,"address":[],"length":0,"stats":{"Line":939}},{"line":146,"address":[],"length":0,"stats":{"Line":2}},{"line":156,"address":[],"length":0,"stats":{"Line":4}},{"line":157,"address":[],"length":0,"stats":{"Line":4}},{"line":160,"address":[],"length":0,"stats":{"Line":6}},{"line":161,"address":[],"length":0,"stats":{"Line":8}},{"line":162,"address":[],"length":0,"stats":{"Line":20}},{"line":163,"address":[],"length":0,"stats":{"Line":32}},{"line":165,"address":[],"length":0,"stats":{"Line":8}},{"line":169,"address":[],"length":0,"stats":{"Line":7}},{"line":170,"address":[],"length":0,"stats":{"Line":10}},{"line":171,"address":[],"length":0,"stats":{"Line":25}},{"line":172,"address":[],"length":0,"stats":{"Line":40}},{"line":175,"address":[],"length":0,"stats":{"Line":10}},{"line":176,"address":[],"length":0,"stats":{"Line":25}},{"line":177,"address":[],"length":0,"stats":{"Line":40}},{"line":179,"address":[],"length":0,"stats":{"Line":15}},{"line":181,"address":[],"length":0,"stats":{"Line":25}},{"line":182,"address":[],"length":0,"stats":{"Line":40}},{"line":183,"address":[],"length":0,"stats":{"Line":30}},{"line":185,"address":[],"length":0,"stats":{"Line":30}},{"line":190,"address":[],"length":0,"stats":{"Line":6}},{"line":191,"address":[],"length":0,"stats":{"Line":16}},{"line":192,"address":[],"length":0,"stats":{"Line":20}},{"line":193,"address":[],"length":0,"stats":{"Line":24}},{"line":208,"address":[],"length":0,"stats":{"Line":2}},{"line":218,"address":[],"length":0,"stats":{"Line":4}},{"line":219,"address":[],"length":0,"stats":{"Line":4}},{"line":222,"address":[],"length":0,"stats":{"Line":6}},{"line":223,"address":[],"length":0,"stats":{"Line":8}},{"line":224,"address":[],"length":0,"stats":{"Line":20}},{"line":225,"address":[],"length":0,"stats":{"Line":32}},{"line":227,"address":[],"length":0,"stats":{"Line":8}},{"line":231,"address":[],"length":0,"stats":{"Line":6}},{"line":232,"address":[],"length":0,"stats":{"Line":8}},{"line":233,"address":[],"length":0,"stats":{"Line":20}},{"line":234,"address":[],"length":0,"stats":{"Line":32}},{"line":237,"address":[],"length":0,"stats":{"Line":8}},{"line":238,"address":[],"length":0,"stats":{"Line":20}},{"line":239,"address":[],"length":0,"stats":{"Line":32}},{"line":241,"address":[],"length":0,"stats":{"Line":12}},{"line":243,"address":[],"length":0,"stats":{"Line":20}},{"line":244,"address":[],"length":0,"stats":{"Line":32}},{"line":246,"address":[],"length":0,"stats":{"Line":24}},{"line":248,"address":[],"length":0,"stats":{"Line":24}},{"line":253,"address":[],"length":0,"stats":{"Line":6}},{"line":254,"address":[],"length":0,"stats":{"Line":16}},{"line":255,"address":[],"length":0,"stats":{"Line":20}},{"line":256,"address":[],"length":0,"stats":{"Line":24}}],"covered":96,"coverable":96},{"path":["/","home","leo","rcode","cutropicalgemm","crates","tropical-gemm","src","simd","kernels","mod.rs"],"content":"//! SIMD microkernel implementations.\n\n#[cfg(any(target_arch = \"x86\", target_arch = \"x86_64\"))]\npub mod avx2;\n#[cfg(target_arch = \"aarch64\")]\npub mod neon;\npub mod portable;\n\n#[cfg(any(target_arch = \"x86\", target_arch = \"x86_64\"))]\npub use avx2::{\n    Avx2MaxMulF32Kernel, Avx2MaxPlusF32Kernel, Avx2MaxPlusF64Kernel, Avx2MinPlusF32Kernel,\n};\n#[cfg(target_arch = \"aarch64\")]\npub use neon::{NeonMaxPlusF32Kernel, NeonMaxPlusF64Kernel, NeonMinPlusF32Kernel};\npub use portable::PortableKernel;\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","leo","rcode","cutropicalgemm","crates","tropical-gemm","src","simd","kernels","neon.rs"],"content":"use crate::core::Microkernel;\nuse crate::types::{TropicalMaxPlus, TropicalMinPlus};\nuse wide::{f32x4, f64x2};\n\n/// ARM NEON microkernel for TropicalMaxPlus\u003cf32\u003e.\n///\n/// Uses 4x4 register blocking with f32x4 vectors.\n#[derive(Default, Clone, Copy)]\npub struct NeonMaxPlusF32Kernel;\n\nimpl Microkernel\u003cTropicalMaxPlus\u003cf32\u003e\u003e for NeonMaxPlusF32Kernel {\n    const MR: usize = 4;\n    const NR: usize = 4;\n\n    unsafe fn execute(\n        \u0026self,\n        mr: usize,\n        nr: usize,\n        k: usize,\n        a: *const f32,\n        b: *const f32,\n        c: *mut TropicalMaxPlus\u003cf32\u003e,\n        ldc: usize,\n    ) {\n        let neg_inf = f32x4::splat(f32::NEG_INFINITY);\n        let mut acc = [neg_inf; 4];\n\n        // Load existing C\n        for i in 0..mr {\n            let mut row_acc = [f32::NEG_INFINITY; 4];\n            for j in 0..nr {\n                row_acc[j] = (*c.add(i * ldc + j)).0;\n            }\n            acc[i] = f32x4::from(row_acc);\n        }\n\n        // Main loop\n        for p in 0..k {\n            let mut a_vals = [0.0f32; 4];\n            for i in 0..mr {\n                a_vals[i] = *a.add(p * Self::MR + i);\n            }\n\n            let mut b_vals = [0.0f32; 4];\n            for j in 0..nr {\n                b_vals[j] = *b.add(p * Self::NR + j);\n            }\n            let b_vec = f32x4::from(b_vals);\n\n            for i in 0..mr {\n                let a_broadcast = f32x4::splat(a_vals[i]);\n                let product = a_broadcast + b_vec;\n                acc[i] = acc[i].max(product);\n            }\n        }\n\n        // Write back\n        for i in 0..mr {\n            let row: [f32; 4] = acc[i].into();\n            for j in 0..nr {\n                *c.add(i * ldc + j) = TropicalMaxPlus(row[j]);\n            }\n        }\n    }\n}\n\n/// ARM NEON microkernel for TropicalMaxPlus\u003cf64\u003e.\n#[derive(Default, Clone, Copy)]\npub struct NeonMaxPlusF64Kernel;\n\nimpl Microkernel\u003cTropicalMaxPlus\u003cf64\u003e\u003e for NeonMaxPlusF64Kernel {\n    const MR: usize = 2;\n    const NR: usize = 2;\n\n    unsafe fn execute(\n        \u0026self,\n        mr: usize,\n        nr: usize,\n        k: usize,\n        a: *const f64,\n        b: *const f64,\n        c: *mut TropicalMaxPlus\u003cf64\u003e,\n        ldc: usize,\n    ) {\n        let neg_inf = f64x2::splat(f64::NEG_INFINITY);\n        let mut acc = [neg_inf; 2];\n\n        // Load existing C\n        for i in 0..mr {\n            let mut row_acc = [f64::NEG_INFINITY; 2];\n            for j in 0..nr {\n                row_acc[j] = (*c.add(i * ldc + j)).0;\n            }\n            acc[i] = f64x2::from(row_acc);\n        }\n\n        // Main loop\n        for p in 0..k {\n            let mut a_vals = [0.0f64; 2];\n            for i in 0..mr {\n                a_vals[i] = *a.add(p * Self::MR + i);\n            }\n\n            let mut b_vals = [0.0f64; 2];\n            for j in 0..nr {\n                b_vals[j] = *b.add(p * Self::NR + j);\n            }\n            let b_vec = f64x2::from(b_vals);\n\n            for i in 0..mr {\n                let a_broadcast = f64x2::splat(a_vals[i]);\n                let product = a_broadcast + b_vec;\n                acc[i] = acc[i].max(product);\n            }\n        }\n\n        // Write back\n        for i in 0..mr {\n            let row: [f64; 2] = acc[i].into();\n            for j in 0..nr {\n                *c.add(i * ldc + j) = TropicalMaxPlus(row[j]);\n            }\n        }\n    }\n}\n\n/// ARM NEON microkernel for TropicalMinPlus\u003cf32\u003e.\n#[derive(Default, Clone, Copy)]\npub struct NeonMinPlusF32Kernel;\n\nimpl Microkernel\u003cTropicalMinPlus\u003cf32\u003e\u003e for NeonMinPlusF32Kernel {\n    const MR: usize = 4;\n    const NR: usize = 4;\n\n    unsafe fn execute(\n        \u0026self,\n        mr: usize,\n        nr: usize,\n        k: usize,\n        a: *const f32,\n        b: *const f32,\n        c: *mut TropicalMinPlus\u003cf32\u003e,\n        ldc: usize,\n    ) {\n        let pos_inf = f32x4::splat(f32::INFINITY);\n        let mut acc = [pos_inf; 4];\n\n        for i in 0..mr {\n            let mut row_acc = [f32::INFINITY; 4];\n            for j in 0..nr {\n                row_acc[j] = (*c.add(i * ldc + j)).0;\n            }\n            acc[i] = f32x4::from(row_acc);\n        }\n\n        for p in 0..k {\n            let mut a_vals = [0.0f32; 4];\n            for i in 0..mr {\n                a_vals[i] = *a.add(p * Self::MR + i);\n            }\n\n            let mut b_vals = [0.0f32; 4];\n            for j in 0..nr {\n                b_vals[j] = *b.add(p * Self::NR + j);\n            }\n            let b_vec = f32x4::from(b_vals);\n\n            for i in 0..mr {\n                let a_broadcast = f32x4::splat(a_vals[i]);\n                let product = a_broadcast + b_vec;\n                acc[i] = acc[i].min(product);\n            }\n        }\n\n        for i in 0..mr {\n            let row: [f32; 4] = acc[i].into();\n            for j in 0..nr {\n                *c.add(i * ldc + j) = TropicalMinPlus(row[j]);\n            }\n        }\n    }\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","leo","rcode","cutropicalgemm","crates","tropical-gemm","src","simd","kernels","portable.rs"],"content":"use crate::core::{Microkernel, MicrokernelWithArgmax};\nuse crate::types::{TropicalSemiring, TropicalWithArgmax};\n\n/// Portable (non-SIMD) microkernel using the `wide` crate.\n///\n/// This provides a fallback when no SIMD instructions are available,\n/// but uses `wide` types which may still auto-vectorize.\n#[derive(Default, Clone, Copy)]\npub struct PortableKernel;\n\nimpl\u003cT: TropicalSemiring\u003e Microkernel\u003cT\u003e for PortableKernel {\n    const MR: usize = 4;\n    const NR: usize = 4;\n\n    unsafe fn execute(\n        \u0026self,\n        mr: usize,\n        nr: usize,\n        k: usize,\n        a: *const T::Scalar,\n        b: *const T::Scalar,\n        c: *mut T,\n        ldc: usize,\n    ) {\n        // Delegate to the core portable implementation\n        let core_kernel = crate::core::PortableMicrokernel;\n        core_kernel.execute(mr, nr, k, a, b, c, ldc);\n    }\n}\n\nimpl\u003cT: TropicalWithArgmax\u003cIndex = u32\u003e\u003e MicrokernelWithArgmax\u003cT\u003e for PortableKernel {\n    unsafe fn execute_with_argmax(\n        \u0026self,\n        mr: usize,\n        nr: usize,\n        k: usize,\n        k_offset: usize,\n        a: *const T::Scalar,\n        b: *const T::Scalar,\n        c: *mut T,\n        argmax: *mut u32,\n        ldc: usize,\n    ) {\n        let core_kernel = crate::core::PortableMicrokernel;\n        core_kernel.execute_with_argmax(mr, nr, k, k_offset, a, b, c, argmax, ldc);\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use crate::types::TropicalMaxPlus;\n\n    #[test]\n    fn test_portable_kernel_execute() {\n        let kernel = PortableKernel;\n        let mr = 2;\n        let nr = 2;\n        let k = 2;\n\n        let a: [f64; 8] = [1.0, 2.0, 0.0, 0.0, 3.0, 4.0, 0.0, 0.0];\n        let b: [f64; 8] = [1.0, 2.0, 0.0, 0.0, 3.0, 4.0, 0.0, 0.0];\n        let mut c = [TropicalMaxPlus::tropical_zero(); 4];\n        let ldc = 2;\n\n        unsafe {\n            kernel.execute(mr, nr, k, a.as_ptr(), b.as_ptr(), c.as_mut_ptr(), ldc);\n        }\n\n        // C[0,0] = max(1+1, 3+3) = 6\n        assert_eq!(c[0].0, 6.0);\n    }\n\n    #[test]\n    fn test_portable_kernel_execute_with_argmax() {\n        let kernel = PortableKernel;\n        let mr = 2;\n        let nr = 2;\n        let k = 2;\n\n        let a: [f64; 8] = [1.0, 2.0, 0.0, 0.0, 10.0, 20.0, 0.0, 0.0];\n        let b: [f64; 8] = [1.0, 1.0, 0.0, 0.0, 1.0, 1.0, 0.0, 0.0];\n        let mut c = [TropicalMaxPlus::tropical_zero(); 4];\n        let mut argmax = [0u32; 4];\n        let ldc = 2;\n        let k_offset = 0;\n\n        unsafe {\n            kernel.execute_with_argmax(\n                mr,\n                nr,\n                k,\n                k_offset,\n                a.as_ptr(),\n                b.as_ptr(),\n                c.as_mut_ptr(),\n                argmax.as_mut_ptr(),\n                ldc,\n            );\n        }\n\n        // C[0,0] = max(1+1, 10+1) = 11 at k=1\n        assert_eq!(c[0].0, 11.0);\n        assert_eq!(argmax[0], 1);\n    }\n\n    #[test]\n    fn test_portable_kernel_default() {\n        let kernel = PortableKernel::default();\n        // Just verify it can be created and constants are accessible\n        assert_eq!(\u003cPortableKernel as Microkernel\u003cTropicalMaxPlus\u003cf64\u003e\u003e\u003e::MR, 4);\n        assert_eq!(\u003cPortableKernel as Microkernel\u003cTropicalMaxPlus\u003cf64\u003e\u003e\u003e::NR, 4);\n        let _ = kernel;\n    }\n}\n","traces":[{"line":15,"address":[],"length":0,"stats":{"Line":16}},{"line":26,"address":[],"length":0,"stats":{"Line":32}},{"line":27,"address":[],"length":0,"stats":{"Line":144}},{"line":32,"address":[],"length":0,"stats":{"Line":1}},{"line":44,"address":[],"length":0,"stats":{"Line":2}},{"line":45,"address":[],"length":0,"stats":{"Line":11}}],"covered":6,"coverable":6},{"path":["/","home","leo","rcode","cutropicalgemm","crates","tropical-gemm","src","simd","mod.rs"],"content":"//! SIMD-optimized microkernels for tropical GEMM.\n//!\n//! This module provides architecture-specific SIMD implementations\n//! of the microkernel for tropical matrix multiplication.\n\nmod detect;\npub mod dispatch;\npub mod kernels;\n\npub use detect::{simd_level, SimdLevel};\npub use dispatch::{tropical_gemm_dispatch, KernelDispatch};\npub use kernels::*;\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","leo","rcode","cutropicalgemm","crates","tropical-gemm","src","types","and_or.rs"],"content":"use super::traits::{SimdTropical, TropicalSemiring, TropicalWithArgmax};\nuse std::fmt;\nuse std::ops::{Add, Mul};\n\n/// TropicalAndOr semiring: ({true, false}, OR, AND)\n///\n/// - Addition (⊕) = OR (logical disjunction)\n/// - Multiplication (⊗) = AND (logical conjunction)\n/// - Zero = false\n/// - One = true\n///\n/// This is used for:\n/// - Boolean matrix multiplication (transitive closure)\n/// - Graph reachability\n/// - SAT-related computations\n#[derive(Copy, Clone, PartialEq, Eq)]\n#[repr(transparent)]\npub struct TropicalAndOr(pub bool);\n\nimpl TropicalAndOr {\n    /// Create a new TropicalAndOr value.\n    #[inline(always)]\n    pub fn new(value: bool) -\u003e Self {\n        Self(value)\n    }\n}\n\nimpl TropicalSemiring for TropicalAndOr {\n    type Scalar = bool;\n\n    #[inline(always)]\n    fn tropical_zero() -\u003e Self {\n        Self(false)\n    }\n\n    #[inline(always)]\n    fn tropical_one() -\u003e Self {\n        Self(true)\n    }\n\n    #[inline(always)]\n    fn tropical_add(self, rhs: Self) -\u003e Self {\n        Self(self.0 || rhs.0)\n    }\n\n    #[inline(always)]\n    fn tropical_mul(self, rhs: Self) -\u003e Self {\n        Self(self.0 \u0026\u0026 rhs.0)\n    }\n\n    #[inline(always)]\n    fn value(\u0026self) -\u003e bool {\n        self.0\n    }\n\n    #[inline(always)]\n    fn from_scalar(s: bool) -\u003e Self {\n        Self(s)\n    }\n}\n\nimpl TropicalWithArgmax for TropicalAndOr {\n    type Index = u32;\n\n    #[inline(always)]\n    fn tropical_add_argmax(self, self_idx: u32, rhs: Self, rhs_idx: u32) -\u003e (Self, u32) {\n        // For OR, return index of first true (or last if both false)\n        if self.0 {\n            (self, self_idx)\n        } else if rhs.0 {\n            (rhs, rhs_idx)\n        } else {\n            (self, self_idx)\n        }\n    }\n}\n\nimpl SimdTropical for TropicalAndOr {\n    // Bool operations can be SIMD'd via bitmasks\n    const SIMD_AVAILABLE: bool = true;\n    const SIMD_WIDTH: usize = 256; // 256 bits = 256 bools for AVX2\n}\n\nimpl Add for TropicalAndOr {\n    type Output = Self;\n\n    #[inline(always)]\n    fn add(self, rhs: Self) -\u003e Self::Output {\n        self.tropical_add(rhs)\n    }\n}\n\nimpl Mul for TropicalAndOr {\n    type Output = Self;\n\n    #[inline(always)]\n    fn mul(self, rhs: Self) -\u003e Self::Output {\n        self.tropical_mul(rhs)\n    }\n}\n\nimpl Default for TropicalAndOr {\n    #[inline(always)]\n    fn default() -\u003e Self {\n        Self::tropical_zero()\n    }\n}\n\nimpl fmt::Debug for TropicalAndOr {\n    fn fmt(\u0026self, f: \u0026mut fmt::Formatter\u003c'_\u003e) -\u003e fmt::Result {\n        write!(f, \"TropicalAndOr({})\", self.0)\n    }\n}\n\nimpl fmt::Display for TropicalAndOr {\n    fn fmt(\u0026self, f: \u0026mut fmt::Formatter\u003c'_\u003e) -\u003e fmt::Result {\n        write!(f, \"{}\", self.0)\n    }\n}\n\nimpl From\u003cbool\u003e for TropicalAndOr {\n    #[inline(always)]\n    fn from(value: bool) -\u003e Self {\n        Self(value)\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_semiring_identity() {\n        let a = TropicalAndOr::new(true);\n        let zero = TropicalAndOr::tropical_zero();\n        let one = TropicalAndOr::tropical_one();\n\n        // a ⊕ 0 = a\n        assert_eq!(a.tropical_add(zero), a);\n        // a ⊗ 1 = a\n        assert_eq!(a.tropical_mul(one), a);\n\n        // Test with false value too\n        let f = TropicalAndOr::new(false);\n        assert_eq!(f.tropical_add(zero), f);\n        assert_eq!(f.tropical_mul(one), f);\n    }\n\n    #[test]\n    fn test_operations() {\n        let t = TropicalAndOr::new(true);\n        let f = TropicalAndOr::new(false);\n\n        // OR operations\n        assert!(t.tropical_add(f).0);\n        assert!(!f.tropical_add(f).0);\n        assert!(t.tropical_add(t).0);\n\n        // AND operations\n        assert!(!t.tropical_mul(f).0);\n        assert!(t.tropical_mul(t).0);\n        assert!(!f.tropical_mul(f).0);\n    }\n\n    #[test]\n    fn test_absorbing_zero() {\n        let a = TropicalAndOr::new(true);\n        let zero = TropicalAndOr::tropical_zero();\n\n        // a ⊗ 0 = 0\n        assert_eq!(a.tropical_mul(zero), zero);\n    }\n\n    #[test]\n    fn test_reachability_example() {\n        // Graph adjacency: can we reach node j from node i?\n        // A[0,1] = true (0-\u003e1), A[1,2] = true (1-\u003e2)\n        // (A*A)[0,2] = A[0,0]*A[0,2] OR A[0,1]*A[1,2] = false OR true = true\n        let a01 = TropicalAndOr::new(true);\n        let a12 = TropicalAndOr::new(true);\n        let a00 = TropicalAndOr::new(false);\n        let a02 = TropicalAndOr::new(false);\n\n        let result = a00.tropical_mul(a02).tropical_add(a01.tropical_mul(a12));\n        assert!(result.0);\n    }\n\n    #[test]\n    fn test_operator_overloads() {\n        let t = TropicalAndOr::new(true);\n        let f = TropicalAndOr::new(false);\n\n        // Add operator (OR)\n        assert!((t + f).0);\n        assert!((f + t).0);\n        assert!(!(f + f).0);\n        assert!((t + t).0);\n\n        // Mul operator (AND)\n        assert!(!(t * f).0);\n        assert!(!(f * t).0);\n        assert!(!(f * f).0);\n        assert!((t * t).0);\n    }\n\n    #[test]\n    fn test_default() {\n        let d = TropicalAndOr::default();\n        assert!(!d.0); // Default is zero (false)\n        assert_eq!(d, TropicalAndOr::tropical_zero());\n    }\n\n    #[test]\n    fn test_display_debug() {\n        let t = TropicalAndOr::new(true);\n        let f = TropicalAndOr::new(false);\n\n        assert_eq!(format!(\"{}\", t), \"true\");\n        assert_eq!(format!(\"{}\", f), \"false\");\n        assert_eq!(format!(\"{:?}\", t), \"TropicalAndOr(true)\");\n        assert_eq!(format!(\"{:?}\", f), \"TropicalAndOr(false)\");\n    }\n\n    #[test]\n    fn test_from() {\n        let t: TropicalAndOr = true.into();\n        let f: TropicalAndOr = false.into();\n\n        assert!(t.0);\n        assert!(!f.0);\n\n        // Using From trait directly\n        let t2 = TropicalAndOr::from(true);\n        let f2 = TropicalAndOr::from(false);\n        assert!(t2.0);\n        assert!(!f2.0);\n    }\n\n    #[test]\n    fn test_value_and_from_scalar() {\n        let t = TropicalAndOr::new(true);\n        let f = TropicalAndOr::new(false);\n\n        assert!(t.value());\n        assert!(!f.value());\n\n        let t2 = TropicalAndOr::from_scalar(true);\n        let f2 = TropicalAndOr::from_scalar(false);\n        assert!(t2.value());\n        assert!(!f2.value());\n    }\n\n    #[test]\n    fn test_argmax_self_true() {\n        // If self is true, return self\n        let t = TropicalAndOr::new(true);\n        let f = TropicalAndOr::new(false);\n\n        let (result, idx) = t.tropical_add_argmax(1, f, 2);\n        assert!(result.0);\n        assert_eq!(idx, 1);\n\n        let (result, idx) = t.tropical_add_argmax(5, t, 10);\n        assert!(result.0);\n        assert_eq!(idx, 5);\n    }\n\n    #[test]\n    fn test_argmax_rhs_true() {\n        // If self is false but rhs is true, return rhs\n        let t = TropicalAndOr::new(true);\n        let f = TropicalAndOr::new(false);\n\n        let (result, idx) = f.tropical_add_argmax(1, t, 2);\n        assert!(result.0);\n        assert_eq!(idx, 2);\n    }\n\n    #[test]\n    fn test_argmax_both_false() {\n        // If both are false, return self (first one)\n        let f1 = TropicalAndOr::new(false);\n        let f2 = TropicalAndOr::new(false);\n\n        let (result, idx) = f1.tropical_add_argmax(10, f2, 20);\n        assert!(!result.0);\n        assert_eq!(idx, 10);\n    }\n\n    #[test]\n    fn test_argmax_chain() {\n        // Simulate accumulating through k iterations - find first true\n        let mut acc = TropicalAndOr::tropical_zero();\n        let mut idx = 0u32;\n\n        let values = [false, false, true, false]; // First true at index 2\n        for (k, \u0026val) in values.iter().enumerate() {\n            let candidate = TropicalAndOr::new(val);\n            (acc, idx) = acc.tropical_add_argmax(idx, candidate, k as u32);\n        }\n\n        assert!(acc.0);\n        assert_eq!(idx, 2); // Index where first true occurred\n    }\n\n    #[test]\n    fn test_simd_tropical() {\n        assert!(TropicalAndOr::SIMD_AVAILABLE);\n        assert_eq!(TropicalAndOr::SIMD_WIDTH, 256);\n    }\n\n    #[test]\n    fn test_clone_copy() {\n        let t = TropicalAndOr::new(true);\n        let t_copy = t; // Copy\n        let t_clone = t.clone(); // Clone\n\n        assert_eq!(t, t_copy);\n        assert_eq!(t, t_clone);\n    }\n\n    #[test]\n    fn test_eq() {\n        let t1 = TropicalAndOr::new(true);\n        let t2 = TropicalAndOr::new(true);\n        let f1 = TropicalAndOr::new(false);\n        let f2 = TropicalAndOr::new(false);\n\n        assert_eq!(t1, t2);\n        assert_eq!(f1, f2);\n        assert_ne!(t1, f1);\n    }\n}\n","traces":[{"line":23,"address":[],"length":0,"stats":{"Line":30}},{"line":24,"address":[],"length":0,"stats":{"Line":30}},{"line":32,"address":[],"length":0,"stats":{"Line":5}},{"line":33,"address":[],"length":0,"stats":{"Line":5}},{"line":37,"address":[],"length":0,"stats":{"Line":1}},{"line":38,"address":[],"length":0,"stats":{"Line":1}},{"line":42,"address":[],"length":0,"stats":{"Line":10}},{"line":43,"address":[],"length":0,"stats":{"Line":15}},{"line":47,"address":[],"length":0,"stats":{"Line":12}},{"line":48,"address":[],"length":0,"stats":{"Line":19}},{"line":52,"address":[],"length":0,"stats":{"Line":4}},{"line":53,"address":[],"length":0,"stats":{"Line":4}},{"line":57,"address":[],"length":0,"stats":{"Line":2}},{"line":58,"address":[],"length":0,"stats":{"Line":2}},{"line":66,"address":[],"length":0,"stats":{"Line":8}},{"line":68,"address":[],"length":0,"stats":{"Line":8}},{"line":69,"address":[],"length":0,"stats":{"Line":3}},{"line":70,"address":[],"length":0,"stats":{"Line":5}},{"line":71,"address":[],"length":0,"stats":{"Line":2}},{"line":73,"address":[],"length":0,"stats":{"Line":3}},{"line":88,"address":[],"length":0,"stats":{"Line":4}},{"line":89,"address":[],"length":0,"stats":{"Line":12}},{"line":97,"address":[],"length":0,"stats":{"Line":4}},{"line":98,"address":[],"length":0,"stats":{"Line":12}},{"line":104,"address":[],"length":0,"stats":{"Line":1}},{"line":105,"address":[],"length":0,"stats":{"Line":1}},{"line":110,"address":[],"length":0,"stats":{"Line":2}},{"line":111,"address":[],"length":0,"stats":{"Line":6}},{"line":116,"address":[],"length":0,"stats":{"Line":2}},{"line":117,"address":[],"length":0,"stats":{"Line":6}},{"line":123,"address":[],"length":0,"stats":{"Line":2}},{"line":124,"address":[],"length":0,"stats":{"Line":2}}],"covered":32,"coverable":32},{"path":["/","home","leo","rcode","cutropicalgemm","crates","tropical-gemm","src","types","counting.rs"],"content":"use super::scalar::TropicalScalar;\nuse super::traits::{SimdTropical, TropicalSemiring, TropicalWithArgmax};\nuse std::fmt;\nuse std::ops::{Add, Mul};\n\n/// CountingTropical semiring: tracks both the tropical value and the count of optimal paths.\n///\n/// For TropicalMaxPlus semantics:\n/// - Multiplication: (n₁, c₁) ⊗ (n₂, c₂) = (n₁ + n₂, c₁ × c₂)\n/// - Addition: (n₁, c₁) ⊕ (n₂, c₂) =\n///   - if n₁ \u003e n₂: (n₁, c₁)\n///   - if n₁ \u003c n₂: (n₂, c₂)\n///   - if n₁ = n₂: (n₁, c₁ + c₂)\n///\n/// This is used for:\n/// - Counting optimal paths in dynamic programming\n/// - Computing partition functions\n/// - Gradient computations in certain neural network architectures\n#[derive(Copy, Clone, PartialEq)]\n#[repr(C)]\npub struct CountingTropical\u003cT: TropicalScalar, C: TropicalScalar = T\u003e {\n    /// The tropical value (using MaxPlus semantics).\n    pub value: T,\n    /// The count of paths achieving this value.\n    pub count: C,\n}\n\nimpl\u003cT: TropicalScalar, C: TropicalScalar\u003e CountingTropical\u003cT, C\u003e {\n    /// Create a new CountingTropical value.\n    #[inline(always)]\n    pub fn new(value: T, count: C) -\u003e Self {\n        Self { value, count }\n    }\n\n    /// Create a CountingTropical from a single value with count 1.\n    #[inline(always)]\n    pub fn from_value(value: T) -\u003e Self {\n        Self {\n            value,\n            count: C::scalar_one(),\n        }\n    }\n}\n\nimpl\u003cT: TropicalScalar, C: TropicalScalar\u003e TropicalSemiring for CountingTropical\u003cT, C\u003e {\n    type Scalar = T;\n\n    #[inline(always)]\n    fn tropical_zero() -\u003e Self {\n        Self {\n            value: T::neg_infinity(),\n            count: C::scalar_zero(),\n        }\n    }\n\n    #[inline(always)]\n    fn tropical_one() -\u003e Self {\n        Self {\n            value: T::scalar_zero(),\n            count: C::scalar_one(),\n        }\n    }\n\n    #[inline(always)]\n    fn tropical_add(self, rhs: Self) -\u003e Self {\n        if self.value \u003e rhs.value {\n            self\n        } else if self.value \u003c rhs.value {\n            rhs\n        } else {\n            // Equal values: add counts\n            Self {\n                value: self.value,\n                count: self.count.scalar_add(rhs.count),\n            }\n        }\n    }\n\n    #[inline(always)]\n    fn tropical_mul(self, rhs: Self) -\u003e Self {\n        Self {\n            value: self.value.scalar_add(rhs.value),\n            count: self.count.scalar_mul(rhs.count),\n        }\n    }\n\n    #[inline(always)]\n    fn value(\u0026self) -\u003e T {\n        self.value\n    }\n\n    #[inline(always)]\n    fn from_scalar(s: T) -\u003e Self {\n        Self::from_value(s)\n    }\n}\n\nimpl\u003cT: TropicalScalar, C: TropicalScalar\u003e TropicalWithArgmax for CountingTropical\u003cT, C\u003e {\n    type Index = u32;\n\n    #[inline(always)]\n    fn tropical_add_argmax(self, self_idx: u32, rhs: Self, rhs_idx: u32) -\u003e (Self, u32) {\n        if self.value \u003e rhs.value {\n            (self, self_idx)\n        } else if self.value \u003c rhs.value {\n            (rhs, rhs_idx)\n        } else {\n            // Equal values: add counts, keep first index\n            (\n                Self {\n                    value: self.value,\n                    count: self.count.scalar_add(rhs.count),\n                },\n                self_idx,\n            )\n        }\n    }\n}\n\nimpl\u003cT: TropicalScalar, C: TropicalScalar\u003e SimdTropical for CountingTropical\u003cT, C\u003e {\n    // SIMD for CountingTropical requires SOA layout\n    const SIMD_AVAILABLE: bool = true;\n    const SIMD_WIDTH: usize = 8;\n}\n\nimpl\u003cT: TropicalScalar, C: TropicalScalar\u003e Add for CountingTropical\u003cT, C\u003e {\n    type Output = Self;\n\n    #[inline(always)]\n    fn add(self, rhs: Self) -\u003e Self::Output {\n        self.tropical_add(rhs)\n    }\n}\n\nimpl\u003cT: TropicalScalar, C: TropicalScalar\u003e Mul for CountingTropical\u003cT, C\u003e {\n    type Output = Self;\n\n    #[inline(always)]\n    fn mul(self, rhs: Self) -\u003e Self::Output {\n        self.tropical_mul(rhs)\n    }\n}\n\nimpl\u003cT: TropicalScalar, C: TropicalScalar\u003e Default for CountingTropical\u003cT, C\u003e {\n    #[inline(always)]\n    fn default() -\u003e Self {\n        Self::tropical_zero()\n    }\n}\n\nimpl\u003cT: TropicalScalar, C: TropicalScalar\u003e fmt::Debug for CountingTropical\u003cT, C\u003e {\n    fn fmt(\u0026self, f: \u0026mut fmt::Formatter\u003c'_\u003e) -\u003e fmt::Result {\n        write!(f, \"CountingTropical({}, {})\", self.value, self.count)\n    }\n}\n\nimpl\u003cT: TropicalScalar, C: TropicalScalar\u003e fmt::Display for CountingTropical\u003cT, C\u003e {\n    fn fmt(\u0026self, f: \u0026mut fmt::Formatter\u003c'_\u003e) -\u003e fmt::Result {\n        write!(f, \"({}, {})\", self.value, self.count)\n    }\n}\n\nimpl\u003cT: TropicalScalar, C: TropicalScalar\u003e From\u003cT\u003e for CountingTropical\u003cT, C\u003e {\n    #[inline(always)]\n    fn from(value: T) -\u003e Self {\n        Self::from_value(value)\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_semiring_identity() {\n        let a = CountingTropical::\u003cf64\u003e::new(5.0, 2.0);\n        let zero = CountingTropical::tropical_zero();\n        let one = CountingTropical::tropical_one();\n\n        // a ⊕ 0 = a\n        let result = a.tropical_add(zero);\n        assert_eq!(result.value, a.value);\n        assert_eq!(result.count, a.count);\n\n        // a ⊗ 1 = a\n        let result = a.tropical_mul(one);\n        assert_eq!(result.value, a.value);\n        assert_eq!(result.count, a.count);\n    }\n\n    #[test]\n    fn test_multiplication() {\n        let a = CountingTropical::\u003cf64\u003e::new(3.0, 2.0);\n        let b = CountingTropical::\u003cf64\u003e::new(5.0, 3.0);\n\n        let result = a.tropical_mul(b);\n        // value = 3 + 5 = 8\n        assert_eq!(result.value, 8.0);\n        // count = 2 * 3 = 6\n        assert_eq!(result.count, 6.0);\n    }\n\n    #[test]\n    fn test_addition_different_values() {\n        let a = CountingTropical::\u003cf64\u003e::new(3.0, 2.0);\n        let b = CountingTropical::\u003cf64\u003e::new(5.0, 3.0);\n\n        let result = a.tropical_add(b);\n        // max(3, 5) = 5, keep count of winner\n        assert_eq!(result.value, 5.0);\n        assert_eq!(result.count, 3.0);\n    }\n\n    #[test]\n    fn test_addition_equal_values() {\n        let a = CountingTropical::\u003cf64\u003e::new(5.0, 2.0);\n        let b = CountingTropical::\u003cf64\u003e::new(5.0, 3.0);\n\n        let result = a.tropical_add(b);\n        // same value, add counts\n        assert_eq!(result.value, 5.0);\n        assert_eq!(result.count, 5.0);\n    }\n\n    #[test]\n    fn test_addition_self_wins() {\n        let a = CountingTropical::\u003cf64\u003e::new(7.0, 1.0);\n        let b = CountingTropical::\u003cf64\u003e::new(5.0, 3.0);\n\n        let result = a.tropical_add(b);\n        // max(7, 5) = 7, keep count of winner\n        assert_eq!(result.value, 7.0);\n        assert_eq!(result.count, 1.0);\n    }\n\n    #[test]\n    fn test_path_counting_example() {\n        // Example: counting paths in a graph\n        // Path A-\u003eB has value 3, count 1 (one path)\n        // Path A-\u003eC-\u003eB has value 3, count 2 (two equivalent paths)\n        // Total paths A-\u003eB with optimal value: 1 + 2 = 3\n\n        let path1 = CountingTropical::\u003cf64\u003e::new(3.0, 1.0);\n        let path2 = CountingTropical::\u003cf64\u003e::new(3.0, 2.0);\n\n        let result = path1.tropical_add(path2);\n        assert_eq!(result.value, 3.0);\n        assert_eq!(result.count, 3.0);\n    }\n\n    #[test]\n    fn test_operator_overloads() {\n        let a = CountingTropical::\u003cf64\u003e::new(3.0, 2.0);\n        let b = CountingTropical::\u003cf64\u003e::new(5.0, 3.0);\n\n        // Add operator\n        let result = a + b;\n        assert_eq!(result.value, 5.0);\n        assert_eq!(result.count, 3.0);\n\n        // Mul operator\n        let result = a * b;\n        assert_eq!(result.value, 8.0);\n        assert_eq!(result.count, 6.0);\n    }\n\n    #[test]\n    fn test_default() {\n        let d = CountingTropical::\u003cf64\u003e::default();\n        assert!(d.value.is_infinite() \u0026\u0026 d.value \u003c 0.0); // -inf\n        assert_eq!(d.count, 0.0);\n    }\n\n    #[test]\n    fn test_display_debug() {\n        let a = CountingTropical::\u003cf64\u003e::new(3.0, 2.0);\n\n        assert_eq!(format!(\"{}\", a), \"(3, 2)\");\n        assert_eq!(format!(\"{:?}\", a), \"CountingTropical(3, 2)\");\n    }\n\n    #[test]\n    fn test_from() {\n        let a: CountingTropical\u003cf64\u003e = 5.0.into();\n        assert_eq!(a.value, 5.0);\n        assert_eq!(a.count, 1.0); // Default count is 1\n\n        let b = CountingTropical::\u003cf64\u003e::from(3.0);\n        assert_eq!(b.value, 3.0);\n        assert_eq!(b.count, 1.0);\n    }\n\n    #[test]\n    fn test_from_value() {\n        let a = CountingTropical::\u003cf64\u003e::from_value(7.0);\n        assert_eq!(a.value, 7.0);\n        assert_eq!(a.count, 1.0);\n    }\n\n    #[test]\n    fn test_value_and_from_scalar() {\n        let a = CountingTropical::\u003cf64\u003e::new(5.0, 2.0);\n        assert_eq!(a.value(), 5.0);\n\n        let b = CountingTropical::\u003cf64\u003e::from_scalar(3.0);\n        assert_eq!(b.value(), 3.0);\n        assert_eq!(b.count, 1.0);\n    }\n\n    #[test]\n    fn test_argmax_self_wins() {\n        let a = CountingTropical::\u003cf64\u003e::new(7.0, 2.0);\n        let b = CountingTropical::\u003cf64\u003e::new(3.0, 1.0);\n\n        let (result, idx) = a.tropical_add_argmax(1, b, 2);\n        assert_eq!(result.value, 7.0);\n        assert_eq!(result.count, 2.0);\n        assert_eq!(idx, 1);\n    }\n\n    #[test]\n    fn test_argmax_rhs_wins() {\n        let a = CountingTropical::\u003cf64\u003e::new(3.0, 1.0);\n        let b = CountingTropical::\u003cf64\u003e::new(7.0, 2.0);\n\n        let (result, idx) = a.tropical_add_argmax(1, b, 2);\n        assert_eq!(result.value, 7.0);\n        assert_eq!(result.count, 2.0);\n        assert_eq!(idx, 2);\n    }\n\n    #[test]\n    fn test_argmax_equal_counts_added() {\n        // Equal values: counts are added, first index is kept\n        let a = CountingTropical::\u003cf64\u003e::new(5.0, 2.0);\n        let b = CountingTropical::\u003cf64\u003e::new(5.0, 3.0);\n\n        let (result, idx) = a.tropical_add_argmax(1, b, 2);\n        assert_eq!(result.value, 5.0);\n        assert_eq!(result.count, 5.0); // 2 + 3\n        assert_eq!(idx, 1); // First index is kept\n    }\n\n    #[test]\n    fn test_argmax_chain() {\n        let mut acc = CountingTropical::\u003cf64\u003e::tropical_zero();\n        let mut idx = 0u32;\n\n        // Values with different counts\n        let values = [(3.0, 1.0), (7.0, 2.0), (7.0, 3.0), (5.0, 1.0)];\n        for (k, \u0026(val, count)) in values.iter().enumerate() {\n            let candidate = CountingTropical::new(val, count);\n            (acc, idx) = acc.tropical_add_argmax(idx, candidate, k as u32);\n        }\n\n        // Max value is 7.0, first encountered at k=1\n        // Counts: 2 + 3 = 5 (both k=1 and k=2 have value 7.0)\n        assert_eq!(acc.value, 7.0);\n        assert_eq!(acc.count, 5.0);\n        assert_eq!(idx, 1); // First index where max occurred\n    }\n\n    #[test]\n    fn test_simd_tropical() {\n        assert!(CountingTropical::\u003cf64\u003e::SIMD_AVAILABLE);\n        assert_eq!(CountingTropical::\u003cf64\u003e::SIMD_WIDTH, 8);\n    }\n\n    #[test]\n    fn test_clone_copy() {\n        let a = CountingTropical::\u003cf64\u003e::new(5.0, 2.0);\n        let a_copy = a;\n        let a_clone = a.clone();\n\n        assert_eq!(a.value, a_copy.value);\n        assert_eq!(a.count, a_copy.count);\n        assert_eq!(a.value, a_clone.value);\n        assert_eq!(a.count, a_clone.count);\n    }\n\n    #[test]\n    fn test_eq() {\n        let a1 = CountingTropical::\u003cf64\u003e::new(5.0, 2.0);\n        let a2 = CountingTropical::\u003cf64\u003e::new(5.0, 2.0);\n        let b = CountingTropical::\u003cf64\u003e::new(5.0, 3.0);\n\n        assert_eq!(a1, a2);\n        assert_ne!(a1, b);\n    }\n\n    #[test]\n    fn test_f32() {\n        let a = CountingTropical::\u003cf32\u003e::new(3.0, 2.0);\n        let b = CountingTropical::\u003cf32\u003e::new(5.0, 3.0);\n\n        let result = a.tropical_mul(b);\n        assert!((result.value - 8.0).abs() \u003c 1e-6);\n        assert!((result.count - 6.0).abs() \u003c 1e-6);\n    }\n\n    #[test]\n    fn test_different_count_type() {\n        // Use different types for value and count\n        let a = CountingTropical::\u003cf64, f32\u003e::new(3.0, 2.0);\n        let b = CountingTropical::\u003cf64, f32\u003e::new(5.0, 3.0);\n\n        let result = a.tropical_mul(b);\n        assert_eq!(result.value, 8.0);\n        assert!((result.count - 6.0).abs() \u003c 1e-6);\n    }\n}\n","traces":[{"line":31,"address":[],"length":0,"stats":{"Line":33}},{"line":37,"address":[],"length":0,"stats":{"Line":1}},{"line":40,"address":[],"length":0,"stats":{"Line":1}},{"line":49,"address":[],"length":0,"stats":{"Line":3}},{"line":51,"address":[],"length":0,"stats":{"Line":3}},{"line":52,"address":[],"length":0,"stats":{"Line":3}},{"line":57,"address":[],"length":0,"stats":{"Line":1}},{"line":59,"address":[],"length":0,"stats":{"Line":1}},{"line":60,"address":[],"length":0,"stats":{"Line":1}},{"line":65,"address":[],"length":0,"stats":{"Line":6}},{"line":66,"address":[],"length":0,"stats":{"Line":6}},{"line":67,"address":[],"length":0,"stats":{"Line":2}},{"line":68,"address":[],"length":0,"stats":{"Line":4}},{"line":69,"address":[],"length":0,"stats":{"Line":2}},{"line":73,"address":[],"length":0,"stats":{"Line":4}},{"line":74,"address":[],"length":0,"stats":{"Line":4}},{"line":80,"address":[],"length":0,"stats":{"Line":5}},{"line":82,"address":[],"length":0,"stats":{"Line":20}},{"line":83,"address":[],"length":0,"stats":{"Line":10}},{"line":88,"address":[],"length":0,"stats":{"Line":2}},{"line":89,"address":[],"length":0,"stats":{"Line":2}},{"line":93,"address":[],"length":0,"stats":{"Line":1}},{"line":94,"address":[],"length":0,"stats":{"Line":2}},{"line":102,"address":[],"length":0,"stats":{"Line":7}},{"line":103,"address":[],"length":0,"stats":{"Line":7}},{"line":104,"address":[],"length":0,"stats":{"Line":2}},{"line":105,"address":[],"length":0,"stats":{"Line":5}},{"line":106,"address":[],"length":0,"stats":{"Line":3}},{"line":110,"address":[],"length":0,"stats":{"Line":2}},{"line":111,"address":[],"length":0,"stats":{"Line":4}},{"line":112,"address":[],"length":0,"stats":{"Line":4}},{"line":114,"address":[],"length":0,"stats":{"Line":2}},{"line":130,"address":[],"length":0,"stats":{"Line":1}},{"line":131,"address":[],"length":0,"stats":{"Line":3}},{"line":139,"address":[],"length":0,"stats":{"Line":1}},{"line":140,"address":[],"length":0,"stats":{"Line":3}},{"line":146,"address":[],"length":0,"stats":{"Line":1}},{"line":147,"address":[],"length":0,"stats":{"Line":1}},{"line":152,"address":[],"length":0,"stats":{"Line":1}},{"line":153,"address":[],"length":0,"stats":{"Line":3}},{"line":158,"address":[],"length":0,"stats":{"Line":1}},{"line":159,"address":[],"length":0,"stats":{"Line":3}},{"line":165,"address":[],"length":0,"stats":{"Line":1}},{"line":166,"address":[],"length":0,"stats":{"Line":2}}],"covered":44,"coverable":44},{"path":["/","home","leo","rcode","cutropicalgemm","crates","tropical-gemm","src","types","max_mul.rs"],"content":"use super::scalar::TropicalScalar;\nuse super::traits::{SimdTropical, TropicalSemiring, TropicalWithArgmax};\nuse std::fmt;\nuse std::ops::{Add, Mul};\n\n/// TropicalMaxMul semiring: (ℝ⁺, max, ×)\n///\n/// - Addition (⊕) = max\n/// - Multiplication (⊗) = ×\n/// - Zero = 0\n/// - One = 1\n///\n/// This is used for:\n/// - Probability computations (non-log space)\n/// - Fuzzy logic with product t-norm\n#[derive(Copy, Clone, PartialEq)]\n#[repr(transparent)]\npub struct TropicalMaxMul\u003cT: TropicalScalar\u003e(pub T);\n\nimpl\u003cT: TropicalScalar\u003e TropicalMaxMul\u003cT\u003e {\n    /// Create a new TropicalMaxMul value.\n    #[inline(always)]\n    pub fn new(value: T) -\u003e Self {\n        Self(value)\n    }\n}\n\nimpl\u003cT: TropicalScalar\u003e TropicalSemiring for TropicalMaxMul\u003cT\u003e {\n    type Scalar = T;\n\n    #[inline(always)]\n    fn tropical_zero() -\u003e Self {\n        Self(T::scalar_zero())\n    }\n\n    #[inline(always)]\n    fn tropical_one() -\u003e Self {\n        Self(T::scalar_one())\n    }\n\n    #[inline(always)]\n    fn tropical_add(self, rhs: Self) -\u003e Self {\n        Self(self.0.scalar_max(rhs.0))\n    }\n\n    #[inline(always)]\n    fn tropical_mul(self, rhs: Self) -\u003e Self {\n        Self(self.0.scalar_mul(rhs.0))\n    }\n\n    #[inline(always)]\n    fn value(\u0026self) -\u003e T {\n        self.0\n    }\n\n    #[inline(always)]\n    fn from_scalar(s: T) -\u003e Self {\n        Self(s)\n    }\n}\n\nimpl\u003cT: TropicalScalar\u003e TropicalWithArgmax for TropicalMaxMul\u003cT\u003e {\n    type Index = u32;\n\n    #[inline(always)]\n    fn tropical_add_argmax(self, self_idx: u32, rhs: Self, rhs_idx: u32) -\u003e (Self, u32) {\n        if self.0 \u003e= rhs.0 {\n            (self, self_idx)\n        } else {\n            (rhs, rhs_idx)\n        }\n    }\n}\n\nimpl\u003cT: TropicalScalar\u003e SimdTropical for TropicalMaxMul\u003cT\u003e {\n    const SIMD_AVAILABLE: bool = true;\n    const SIMD_WIDTH: usize = 8;\n}\n\nimpl\u003cT: TropicalScalar\u003e Add for TropicalMaxMul\u003cT\u003e {\n    type Output = Self;\n\n    #[inline(always)]\n    fn add(self, rhs: Self) -\u003e Self::Output {\n        self.tropical_add(rhs)\n    }\n}\n\nimpl\u003cT: TropicalScalar\u003e Mul for TropicalMaxMul\u003cT\u003e {\n    type Output = Self;\n\n    #[inline(always)]\n    fn mul(self, rhs: Self) -\u003e Self::Output {\n        self.tropical_mul(rhs)\n    }\n}\n\nimpl\u003cT: TropicalScalar\u003e Default for TropicalMaxMul\u003cT\u003e {\n    #[inline(always)]\n    fn default() -\u003e Self {\n        Self::tropical_zero()\n    }\n}\n\nimpl\u003cT: TropicalScalar\u003e fmt::Debug for TropicalMaxMul\u003cT\u003e {\n    fn fmt(\u0026self, f: \u0026mut fmt::Formatter\u003c'_\u003e) -\u003e fmt::Result {\n        write!(f, \"TropicalMaxMul({})\", self.0)\n    }\n}\n\nimpl\u003cT: TropicalScalar\u003e fmt::Display for TropicalMaxMul\u003cT\u003e {\n    fn fmt(\u0026self, f: \u0026mut fmt::Formatter\u003c'_\u003e) -\u003e fmt::Result {\n        write!(f, \"{}\", self.0)\n    }\n}\n\nimpl\u003cT: TropicalScalar\u003e From\u003cT\u003e for TropicalMaxMul\u003cT\u003e {\n    #[inline(always)]\n    fn from(value: T) -\u003e Self {\n        Self(value)\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_semiring_identity() {\n        let a = TropicalMaxMul::new(5.0f64);\n        let zero = TropicalMaxMul::tropical_zero();\n        let one = TropicalMaxMul::tropical_one();\n\n        // a ⊕ 0 = a\n        assert_eq!(a.tropical_add(zero), a);\n        // a ⊗ 1 = a\n        assert_eq!(a.tropical_mul(one), a);\n    }\n\n    #[test]\n    fn test_operations() {\n        let a = TropicalMaxMul::new(3.0f64);\n        let b = TropicalMaxMul::new(5.0f64);\n\n        // max(3, 5) = 5\n        assert_eq!(a.tropical_add(b).0, 5.0);\n        // 3 * 5 = 15\n        assert_eq!(a.tropical_mul(b).0, 15.0);\n    }\n\n    #[test]\n    fn test_absorbing_zero() {\n        let a = TropicalMaxMul::new(5.0f64);\n        let zero = TropicalMaxMul::tropical_zero();\n\n        // a ⊗ 0 = 0\n        assert_eq!(a.tropical_mul(zero), zero);\n    }\n\n    #[test]\n    fn test_operator_overloads() {\n        let a = TropicalMaxMul::new(3.0f64);\n        let b = TropicalMaxMul::new(5.0f64);\n\n        // Add operator (max)\n        assert_eq!((a + b).0, 5.0);\n        assert_eq!((b + a).0, 5.0);\n\n        // Mul operator (product)\n        assert_eq!((a * b).0, 15.0);\n        assert_eq!((b * a).0, 15.0);\n    }\n\n    #[test]\n    fn test_default() {\n        let d = TropicalMaxMul::\u003cf64\u003e::default();\n        assert_eq!(d.0, 0.0); // Zero is 0 for MaxMul\n        assert_eq!(d, TropicalMaxMul::tropical_zero());\n    }\n\n    #[test]\n    fn test_display_debug() {\n        let a = TropicalMaxMul::new(5.0f64);\n\n        assert_eq!(format!(\"{}\", a), \"5\");\n        assert_eq!(format!(\"{:?}\", a), \"TropicalMaxMul(5)\");\n    }\n\n    #[test]\n    fn test_from() {\n        let a: TropicalMaxMul\u003cf64\u003e = 5.0.into();\n        assert_eq!(a.0, 5.0);\n\n        let b = TropicalMaxMul::\u003cf64\u003e::from(3.0);\n        assert_eq!(b.0, 3.0);\n    }\n\n    #[test]\n    fn test_value_and_from_scalar() {\n        let a = TropicalMaxMul::new(5.0f64);\n        assert_eq!(a.value(), 5.0);\n\n        let b = TropicalMaxMul::\u003cf64\u003e::from_scalar(3.0);\n        assert_eq!(b.value(), 3.0);\n    }\n\n    #[test]\n    fn test_argmax_self_wins() {\n        let a = TropicalMaxMul::new(7.0f64);\n        let b = TropicalMaxMul::new(3.0f64);\n\n        let (result, idx) = a.tropical_add_argmax(1, b, 2);\n        assert_eq!(result.0, 7.0);\n        assert_eq!(idx, 1);\n    }\n\n    #[test]\n    fn test_argmax_rhs_wins() {\n        let a = TropicalMaxMul::new(3.0f64);\n        let b = TropicalMaxMul::new(7.0f64);\n\n        let (result, idx) = a.tropical_add_argmax(1, b, 2);\n        assert_eq!(result.0, 7.0);\n        assert_eq!(idx, 2);\n    }\n\n    #[test]\n    fn test_argmax_equal_self_wins() {\n        // When equal, self wins (\u003e= comparison)\n        let a = TropicalMaxMul::new(5.0f64);\n        let b = TropicalMaxMul::new(5.0f64);\n\n        let (result, idx) = a.tropical_add_argmax(1, b, 2);\n        assert_eq!(result.0, 5.0);\n        assert_eq!(idx, 1);\n    }\n\n    #[test]\n    fn test_argmax_chain() {\n        let mut acc = TropicalMaxMul::tropical_zero();\n        let mut idx = 0u32;\n\n        let values = [3.0, 7.0, 2.0, 5.0]; // Max at index 1\n        for (k, \u0026val) in values.iter().enumerate() {\n            let candidate = TropicalMaxMul::new(val);\n            (acc, idx) = acc.tropical_add_argmax(idx, candidate, k as u32);\n        }\n\n        assert_eq!(acc.0, 7.0);\n        assert_eq!(idx, 1);\n    }\n\n    #[test]\n    fn test_simd_tropical() {\n        assert!(TropicalMaxMul::\u003cf64\u003e::SIMD_AVAILABLE);\n        assert_eq!(TropicalMaxMul::\u003cf64\u003e::SIMD_WIDTH, 8);\n    }\n\n    #[test]\n    fn test_clone_copy() {\n        let a = TropicalMaxMul::new(5.0f64);\n        let a_copy = a;\n        let a_clone = a.clone();\n\n        assert_eq!(a, a_copy);\n        assert_eq!(a, a_clone);\n    }\n\n    #[test]\n    fn test_eq() {\n        let a1 = TropicalMaxMul::new(5.0f64);\n        let a2 = TropicalMaxMul::new(5.0f64);\n        let b = TropicalMaxMul::new(3.0f64);\n\n        assert_eq!(a1, a2);\n        assert_ne!(a1, b);\n    }\n\n    #[test]\n    fn test_f32() {\n        let a = TropicalMaxMul::new(3.0f32);\n        let b = TropicalMaxMul::new(5.0f32);\n\n        assert!((a.tropical_add(b).0 - 5.0).abs() \u003c 1e-6);\n        assert!((a.tropical_mul(b).0 - 15.0).abs() \u003c 1e-6);\n    }\n\n    #[test]\n    fn test_fuzzy_logic_example() {\n        // Fuzzy AND (product) and OR (max)\n        let high = TropicalMaxMul::new(0.9f64);\n        let medium = TropicalMaxMul::new(0.5f64);\n        let low = TropicalMaxMul::new(0.2f64);\n\n        // Fuzzy OR of high and low\n        let or_result = high.tropical_add(low);\n        assert_eq!(or_result.0, 0.9);\n\n        // Fuzzy AND of high and medium (product t-norm)\n        let and_result = high.tropical_mul(medium);\n        assert!((and_result.0 - 0.45).abs() \u003c 1e-10);\n    }\n}\n","traces":[{"line":23,"address":[],"length":0,"stats":{"Line":27}},{"line":24,"address":[],"length":0,"stats":{"Line":27}},{"line":32,"address":[],"length":0,"stats":{"Line":4}},{"line":33,"address":[],"length":0,"stats":{"Line":4}},{"line":37,"address":[],"length":0,"stats":{"Line":1}},{"line":38,"address":[],"length":0,"stats":{"Line":1}},{"line":42,"address":[],"length":0,"stats":{"Line":40}},{"line":43,"address":[],"length":0,"stats":{"Line":80}},{"line":47,"address":[],"length":0,"stats":{"Line":48}},{"line":48,"address":[],"length":0,"stats":{"Line":96}},{"line":52,"address":[],"length":0,"stats":{"Line":2}},{"line":53,"address":[],"length":0,"stats":{"Line":2}},{"line":57,"address":[],"length":0,"stats":{"Line":72}},{"line":58,"address":[],"length":0,"stats":{"Line":72}},{"line":66,"address":[],"length":0,"stats":{"Line":8}},{"line":67,"address":[],"length":0,"stats":{"Line":8}},{"line":68,"address":[],"length":0,"stats":{"Line":0}},{"line":70,"address":[],"length":0,"stats":{"Line":8}},{"line":84,"address":[],"length":0,"stats":{"Line":2}},{"line":85,"address":[],"length":0,"stats":{"Line":6}},{"line":93,"address":[],"length":0,"stats":{"Line":2}},{"line":94,"address":[],"length":0,"stats":{"Line":6}},{"line":100,"address":[],"length":0,"stats":{"Line":1}},{"line":101,"address":[],"length":0,"stats":{"Line":1}},{"line":106,"address":[],"length":0,"stats":{"Line":1}},{"line":107,"address":[],"length":0,"stats":{"Line":3}},{"line":112,"address":[],"length":0,"stats":{"Line":1}},{"line":113,"address":[],"length":0,"stats":{"Line":3}},{"line":119,"address":[],"length":0,"stats":{"Line":1}},{"line":120,"address":[],"length":0,"stats":{"Line":1}}],"covered":29,"coverable":30},{"path":["/","home","leo","rcode","cutropicalgemm","crates","tropical-gemm","src","types","max_plus.rs"],"content":"use super::scalar::TropicalScalar;\nuse super::traits::{SimdTropical, TropicalSemiring, TropicalWithArgmax};\nuse std::fmt;\nuse std::ops::{Add, Mul};\n\n/// TropicalMaxPlus semiring: (ℝ ∪ {-∞}, max, +)\n///\n/// - Addition (⊕) = max\n/// - Multiplication (⊗) = +\n/// - Zero = -∞\n/// - One = 0\n///\n/// This is the classic tropical semiring used in:\n/// - Viterbi algorithm\n/// - Shortest path algorithms (with negated weights)\n/// - Log-space probability computations\n#[derive(Copy, Clone, PartialEq)]\n#[repr(transparent)]\npub struct TropicalMaxPlus\u003cT: TropicalScalar\u003e(pub T);\n\nimpl\u003cT: TropicalScalar\u003e TropicalMaxPlus\u003cT\u003e {\n    /// Create a new TropicalMaxPlus value.\n    #[inline(always)]\n    pub fn new(value: T) -\u003e Self {\n        Self(value)\n    }\n}\n\nimpl\u003cT: TropicalScalar\u003e TropicalSemiring for TropicalMaxPlus\u003cT\u003e {\n    type Scalar = T;\n\n    #[inline(always)]\n    fn tropical_zero() -\u003e Self {\n        Self(T::neg_infinity())\n    }\n\n    #[inline(always)]\n    fn tropical_one() -\u003e Self {\n        Self(T::scalar_zero())\n    }\n\n    #[inline(always)]\n    fn tropical_add(self, rhs: Self) -\u003e Self {\n        Self(self.0.scalar_max(rhs.0))\n    }\n\n    #[inline(always)]\n    fn tropical_mul(self, rhs: Self) -\u003e Self {\n        Self(self.0.scalar_add(rhs.0))\n    }\n\n    #[inline(always)]\n    fn value(\u0026self) -\u003e T {\n        self.0\n    }\n\n    #[inline(always)]\n    fn from_scalar(s: T) -\u003e Self {\n        Self(s)\n    }\n}\n\nimpl\u003cT: TropicalScalar\u003e TropicalWithArgmax for TropicalMaxPlus\u003cT\u003e {\n    type Index = u32;\n\n    #[inline(always)]\n    fn tropical_add_argmax(self, self_idx: u32, rhs: Self, rhs_idx: u32) -\u003e (Self, u32) {\n        if self.0 \u003e= rhs.0 {\n            (self, self_idx)\n        } else {\n            (rhs, rhs_idx)\n        }\n    }\n}\n\nimpl\u003cT: TropicalScalar\u003e SimdTropical for TropicalMaxPlus\u003cT\u003e {\n    const SIMD_AVAILABLE: bool = true;\n    const SIMD_WIDTH: usize = 8; // f32x8 for AVX2\n}\n\nimpl\u003cT: TropicalScalar\u003e Add for TropicalMaxPlus\u003cT\u003e {\n    type Output = Self;\n\n    #[inline(always)]\n    fn add(self, rhs: Self) -\u003e Self::Output {\n        self.tropical_add(rhs)\n    }\n}\n\nimpl\u003cT: TropicalScalar\u003e Mul for TropicalMaxPlus\u003cT\u003e {\n    type Output = Self;\n\n    #[inline(always)]\n    fn mul(self, rhs: Self) -\u003e Self::Output {\n        self.tropical_mul(rhs)\n    }\n}\n\nimpl\u003cT: TropicalScalar\u003e Default for TropicalMaxPlus\u003cT\u003e {\n    #[inline(always)]\n    fn default() -\u003e Self {\n        Self::tropical_zero()\n    }\n}\n\nimpl\u003cT: TropicalScalar\u003e fmt::Debug for TropicalMaxPlus\u003cT\u003e {\n    fn fmt(\u0026self, f: \u0026mut fmt::Formatter\u003c'_\u003e) -\u003e fmt::Result {\n        write!(f, \"TropicalMaxPlus({})\", self.0)\n    }\n}\n\nimpl\u003cT: TropicalScalar\u003e fmt::Display for TropicalMaxPlus\u003cT\u003e {\n    fn fmt(\u0026self, f: \u0026mut fmt::Formatter\u003c'_\u003e) -\u003e fmt::Result {\n        write!(f, \"{}\", self.0)\n    }\n}\n\nimpl\u003cT: TropicalScalar\u003e From\u003cT\u003e for TropicalMaxPlus\u003cT\u003e {\n    #[inline(always)]\n    fn from(value: T) -\u003e Self {\n        Self(value)\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_semiring_identity() {\n        let a = TropicalMaxPlus::new(5.0f64);\n        let zero = TropicalMaxPlus::tropical_zero();\n        let one = TropicalMaxPlus::tropical_one();\n\n        // a ⊕ 0 = a\n        assert_eq!(a.tropical_add(zero), a);\n        // a ⊗ 1 = a\n        assert_eq!(a.tropical_mul(one), a);\n    }\n\n    #[test]\n    fn test_operations() {\n        let a = TropicalMaxPlus::new(3.0f64);\n        let b = TropicalMaxPlus::new(5.0f64);\n\n        // max(3, 5) = 5\n        assert_eq!(a.tropical_add(b).0, 5.0);\n        // 3 + 5 = 8\n        assert_eq!(a.tropical_mul(b).0, 8.0);\n    }\n\n    #[test]\n    fn test_argmax() {\n        let a = TropicalMaxPlus::new(3.0f64);\n        let b = TropicalMaxPlus::new(5.0f64);\n\n        let (result, idx) = a.tropical_add_argmax(0, b, 1);\n        assert_eq!(result.0, 5.0);\n        assert_eq!(idx, 1);\n    }\n\n    #[test]\n    fn test_argmax_left_wins() {\n        let a = TropicalMaxPlus::new(7.0f64);\n        let b = TropicalMaxPlus::new(3.0f64);\n\n        let (result, idx) = a.tropical_add_argmax(10, b, 20);\n        assert_eq!(result.0, 7.0);\n        assert_eq!(idx, 10); // Left wins, keep left index\n    }\n\n    #[test]\n    fn test_argmax_equal_values() {\n        // When values are equal, left (self) wins (\u003e= comparison)\n        let a = TropicalMaxPlus::new(5.0f64);\n        let b = TropicalMaxPlus::new(5.0f64);\n\n        let (result, idx) = a.tropical_add_argmax(1, b, 2);\n        assert_eq!(result.0, 5.0);\n        assert_eq!(idx, 1); // Equal, so left (self) wins\n    }\n\n    #[test]\n    fn test_argmax_chain() {\n        // Simulate accumulating through k iterations\n        let mut acc = TropicalMaxPlus::tropical_zero();\n        let mut idx = 0u32;\n\n        let values = [3.0, 7.0, 2.0, 5.0]; // Max is at index 1\n        for (k, \u0026val) in values.iter().enumerate() {\n            let candidate = TropicalMaxPlus::new(val);\n            (acc, idx) = acc.tropical_add_argmax(idx, candidate, k as u32);\n        }\n\n        assert_eq!(acc.0, 7.0);\n        assert_eq!(idx, 1); // Index where max occurred\n    }\n\n    #[test]\n    fn test_argmax_neg_infinity() {\n        let a = TropicalMaxPlus::tropical_zero(); // -inf\n        let b = TropicalMaxPlus::new(-100.0f64);\n\n        let (result, idx) = a.tropical_add_argmax(0, b, 1);\n        assert_eq!(result.0, -100.0);\n        assert_eq!(idx, 1); // -100 \u003e -inf\n    }\n\n    #[test]\n    fn test_absorbing_zero() {\n        let a = TropicalMaxPlus::new(5.0f64);\n        let zero = TropicalMaxPlus::tropical_zero();\n\n        // a ⊗ 0 = a + (-inf) = -inf\n        // In tropical max-plus, multiplying by zero (adding -inf) gives -inf\n        let result = a.tropical_mul(zero);\n        assert!(result.0.is_infinite() \u0026\u0026 result.0 \u003c 0.0);\n    }\n\n    #[test]\n    fn test_operator_overloads() {\n        let a = TropicalMaxPlus::new(3.0f64);\n        let b = TropicalMaxPlus::new(5.0f64);\n\n        // Add operator (max)\n        assert_eq!((a + b).0, 5.0);\n        assert_eq!((b + a).0, 5.0);\n\n        // Mul operator (add)\n        assert_eq!((a * b).0, 8.0);\n        assert_eq!((b * a).0, 8.0);\n    }\n\n    #[test]\n    fn test_default() {\n        let d = TropicalMaxPlus::\u003cf64\u003e::default();\n        assert!(d.0.is_infinite() \u0026\u0026 d.0 \u003c 0.0); // -inf\n        assert_eq!(d, TropicalMaxPlus::tropical_zero());\n    }\n\n    #[test]\n    fn test_display_debug() {\n        let a = TropicalMaxPlus::new(5.0f64);\n\n        assert_eq!(format!(\"{}\", a), \"5\");\n        assert_eq!(format!(\"{:?}\", a), \"TropicalMaxPlus(5)\");\n    }\n\n    #[test]\n    fn test_from() {\n        let a: TropicalMaxPlus\u003cf64\u003e = 5.0.into();\n        assert_eq!(a.0, 5.0);\n\n        let b = TropicalMaxPlus::\u003cf64\u003e::from(3.0);\n        assert_eq!(b.0, 3.0);\n    }\n\n    #[test]\n    fn test_value_and_from_scalar() {\n        let a = TropicalMaxPlus::new(5.0f64);\n        assert_eq!(a.value(), 5.0);\n\n        let b = TropicalMaxPlus::\u003cf64\u003e::from_scalar(3.0);\n        assert_eq!(b.value(), 3.0);\n    }\n\n    #[test]\n    fn test_simd_tropical() {\n        assert!(TropicalMaxPlus::\u003cf64\u003e::SIMD_AVAILABLE);\n        assert_eq!(TropicalMaxPlus::\u003cf64\u003e::SIMD_WIDTH, 8);\n    }\n\n    #[test]\n    fn test_clone_copy() {\n        let a = TropicalMaxPlus::new(5.0f64);\n        let a_copy = a;\n        let a_clone = a.clone();\n\n        assert_eq!(a, a_copy);\n        assert_eq!(a, a_clone);\n    }\n\n    #[test]\n    fn test_eq() {\n        let a1 = TropicalMaxPlus::new(5.0f64);\n        let a2 = TropicalMaxPlus::new(5.0f64);\n        let b = TropicalMaxPlus::new(3.0f64);\n\n        assert_eq!(a1, a2);\n        assert_ne!(a1, b);\n    }\n\n    #[test]\n    fn test_f32() {\n        let a = TropicalMaxPlus::new(3.0f32);\n        let b = TropicalMaxPlus::new(5.0f32);\n\n        assert!((a.tropical_add(b).0 - 5.0).abs() \u003c 1e-6);\n        assert!((a.tropical_mul(b).0 - 8.0).abs() \u003c 1e-6);\n    }\n}\n","traces":[{"line":24,"address":[],"length":0,"stats":{"Line":25}},{"line":25,"address":[],"length":0,"stats":{"Line":25}},{"line":33,"address":[],"length":0,"stats":{"Line":5}},{"line":34,"address":[],"length":0,"stats":{"Line":5}},{"line":38,"address":[],"length":0,"stats":{"Line":1}},{"line":39,"address":[],"length":0,"stats":{"Line":1}},{"line":43,"address":[],"length":0,"stats":{"Line":45}},{"line":44,"address":[],"length":0,"stats":{"Line":90}},{"line":48,"address":[],"length":0,"stats":{"Line":46}},{"line":49,"address":[],"length":0,"stats":{"Line":92}},{"line":53,"address":[],"length":0,"stats":{"Line":2}},{"line":54,"address":[],"length":0,"stats":{"Line":2}},{"line":58,"address":[],"length":0,"stats":{"Line":73}},{"line":59,"address":[],"length":0,"stats":{"Line":73}},{"line":67,"address":[],"length":0,"stats":{"Line":8}},{"line":68,"address":[],"length":0,"stats":{"Line":8}},{"line":69,"address":[],"length":0,"stats":{"Line":4}},{"line":71,"address":[],"length":0,"stats":{"Line":4}},{"line":85,"address":[],"length":0,"stats":{"Line":2}},{"line":86,"address":[],"length":0,"stats":{"Line":6}},{"line":94,"address":[],"length":0,"stats":{"Line":2}},{"line":95,"address":[],"length":0,"stats":{"Line":6}},{"line":101,"address":[],"length":0,"stats":{"Line":1}},{"line":102,"address":[],"length":0,"stats":{"Line":1}},{"line":107,"address":[],"length":0,"stats":{"Line":1}},{"line":108,"address":[],"length":0,"stats":{"Line":3}},{"line":113,"address":[],"length":0,"stats":{"Line":1}},{"line":114,"address":[],"length":0,"stats":{"Line":3}},{"line":120,"address":[],"length":0,"stats":{"Line":1}},{"line":121,"address":[],"length":0,"stats":{"Line":1}}],"covered":30,"coverable":30},{"path":["/","home","leo","rcode","cutropicalgemm","crates","tropical-gemm","src","types","min_plus.rs"],"content":"use super::scalar::TropicalScalar;\nuse super::traits::{SimdTropical, TropicalSemiring, TropicalWithArgmax};\nuse std::fmt;\nuse std::ops::{Add, Mul};\n\n/// TropicalMinPlus semiring: (ℝ ∪ {+∞}, min, +)\n///\n/// - Addition (⊕) = min\n/// - Multiplication (⊗) = +\n/// - Zero = +∞\n/// - One = 0\n///\n/// This is used for:\n/// - Shortest path algorithms (Dijkstra, Floyd-Warshall)\n/// - Dynamic programming with minimum cost\n#[derive(Copy, Clone, PartialEq)]\n#[repr(transparent)]\npub struct TropicalMinPlus\u003cT: TropicalScalar\u003e(pub T);\n\nimpl\u003cT: TropicalScalar\u003e TropicalMinPlus\u003cT\u003e {\n    /// Create a new TropicalMinPlus value.\n    #[inline(always)]\n    pub fn new(value: T) -\u003e Self {\n        Self(value)\n    }\n}\n\nimpl\u003cT: TropicalScalar\u003e TropicalSemiring for TropicalMinPlus\u003cT\u003e {\n    type Scalar = T;\n\n    #[inline(always)]\n    fn tropical_zero() -\u003e Self {\n        Self(T::pos_infinity())\n    }\n\n    #[inline(always)]\n    fn tropical_one() -\u003e Self {\n        Self(T::scalar_zero())\n    }\n\n    #[inline(always)]\n    fn tropical_add(self, rhs: Self) -\u003e Self {\n        Self(self.0.scalar_min(rhs.0))\n    }\n\n    #[inline(always)]\n    fn tropical_mul(self, rhs: Self) -\u003e Self {\n        Self(self.0.scalar_add(rhs.0))\n    }\n\n    #[inline(always)]\n    fn value(\u0026self) -\u003e T {\n        self.0\n    }\n\n    #[inline(always)]\n    fn from_scalar(s: T) -\u003e Self {\n        Self(s)\n    }\n}\n\nimpl\u003cT: TropicalScalar\u003e TropicalWithArgmax for TropicalMinPlus\u003cT\u003e {\n    type Index = u32;\n\n    #[inline(always)]\n    fn tropical_add_argmax(self, self_idx: u32, rhs: Self, rhs_idx: u32) -\u003e (Self, u32) {\n        // For min, we track argmin\n        if self.0 \u003c= rhs.0 {\n            (self, self_idx)\n        } else {\n            (rhs, rhs_idx)\n        }\n    }\n}\n\nimpl\u003cT: TropicalScalar\u003e SimdTropical for TropicalMinPlus\u003cT\u003e {\n    const SIMD_AVAILABLE: bool = true;\n    const SIMD_WIDTH: usize = 8;\n}\n\nimpl\u003cT: TropicalScalar\u003e Add for TropicalMinPlus\u003cT\u003e {\n    type Output = Self;\n\n    #[inline(always)]\n    fn add(self, rhs: Self) -\u003e Self::Output {\n        self.tropical_add(rhs)\n    }\n}\n\nimpl\u003cT: TropicalScalar\u003e Mul for TropicalMinPlus\u003cT\u003e {\n    type Output = Self;\n\n    #[inline(always)]\n    fn mul(self, rhs: Self) -\u003e Self::Output {\n        self.tropical_mul(rhs)\n    }\n}\n\nimpl\u003cT: TropicalScalar\u003e Default for TropicalMinPlus\u003cT\u003e {\n    #[inline(always)]\n    fn default() -\u003e Self {\n        Self::tropical_zero()\n    }\n}\n\nimpl\u003cT: TropicalScalar\u003e fmt::Debug for TropicalMinPlus\u003cT\u003e {\n    fn fmt(\u0026self, f: \u0026mut fmt::Formatter\u003c'_\u003e) -\u003e fmt::Result {\n        write!(f, \"TropicalMinPlus({})\", self.0)\n    }\n}\n\nimpl\u003cT: TropicalScalar\u003e fmt::Display for TropicalMinPlus\u003cT\u003e {\n    fn fmt(\u0026self, f: \u0026mut fmt::Formatter\u003c'_\u003e) -\u003e fmt::Result {\n        write!(f, \"{}\", self.0)\n    }\n}\n\nimpl\u003cT: TropicalScalar\u003e From\u003cT\u003e for TropicalMinPlus\u003cT\u003e {\n    #[inline(always)]\n    fn from(value: T) -\u003e Self {\n        Self(value)\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_semiring_identity() {\n        let a = TropicalMinPlus::new(5.0f64);\n        let zero = TropicalMinPlus::tropical_zero();\n        let one = TropicalMinPlus::tropical_one();\n\n        // a ⊕ 0 = a\n        assert_eq!(a.tropical_add(zero), a);\n        // a ⊗ 1 = a\n        assert_eq!(a.tropical_mul(one), a);\n    }\n\n    #[test]\n    fn test_operations() {\n        let a = TropicalMinPlus::new(3.0f64);\n        let b = TropicalMinPlus::new(5.0f64);\n\n        // min(3, 5) = 3\n        assert_eq!(a.tropical_add(b).0, 3.0);\n        // 3 + 5 = 8\n        assert_eq!(a.tropical_mul(b).0, 8.0);\n    }\n\n    #[test]\n    fn test_shortest_path_scenario() {\n        // Simulating: path cost a=10, path cost b=5, combine = min(10,5) = 5\n        let a = TropicalMinPlus::new(10.0f64);\n        let b = TropicalMinPlus::new(5.0f64);\n        assert_eq!(a.tropical_add(b).0, 5.0);\n\n        // Extending a path: cost=5, edge=3, total = 5+3 = 8\n        let path = TropicalMinPlus::new(5.0f64);\n        let edge = TropicalMinPlus::new(3.0f64);\n        assert_eq!(path.tropical_mul(edge).0, 8.0);\n    }\n\n    #[test]\n    fn test_argmin_right_wins() {\n        // For MinPlus, argmax actually tracks argmin\n        let a = TropicalMinPlus::new(5.0f64);\n        let b = TropicalMinPlus::new(3.0f64);\n\n        let (result, idx) = a.tropical_add_argmax(0, b, 1);\n        assert_eq!(result.0, 3.0);\n        assert_eq!(idx, 1); // Right has smaller value\n    }\n\n    #[test]\n    fn test_argmin_left_wins() {\n        let a = TropicalMinPlus::new(2.0f64);\n        let b = TropicalMinPlus::new(7.0f64);\n\n        let (result, idx) = a.tropical_add_argmax(10, b, 20);\n        assert_eq!(result.0, 2.0);\n        assert_eq!(idx, 10); // Left has smaller value\n    }\n\n    #[test]\n    fn test_argmin_equal_values() {\n        // When values are equal, left (self) wins (\u003c= comparison)\n        let a = TropicalMinPlus::new(5.0f64);\n        let b = TropicalMinPlus::new(5.0f64);\n\n        let (result, idx) = a.tropical_add_argmax(1, b, 2);\n        assert_eq!(result.0, 5.0);\n        assert_eq!(idx, 1); // Equal, so left (self) wins\n    }\n\n    #[test]\n    fn test_argmin_chain() {\n        // Simulate accumulating through k iterations - find minimum\n        let mut acc = TropicalMinPlus::tropical_zero(); // +inf\n        let mut idx = 0u32;\n\n        let values = [8.0, 3.0, 9.0, 5.0]; // Min is at index 1\n        for (k, \u0026val) in values.iter().enumerate() {\n            let candidate = TropicalMinPlus::new(val);\n            (acc, idx) = acc.tropical_add_argmax(idx, candidate, k as u32);\n        }\n\n        assert_eq!(acc.0, 3.0);\n        assert_eq!(idx, 1); // Index where min occurred\n    }\n\n    #[test]\n    fn test_argmin_pos_infinity() {\n        let a = TropicalMinPlus::tropical_zero(); // +inf\n        let b = TropicalMinPlus::new(100.0f64);\n\n        let (result, idx) = a.tropical_add_argmax(0, b, 1);\n        assert_eq!(result.0, 100.0);\n        assert_eq!(idx, 1); // 100 \u003c +inf\n    }\n\n    #[test]\n    fn test_absorbing_zero() {\n        let a = TropicalMinPlus::new(5.0f64);\n        let zero = TropicalMinPlus::tropical_zero();\n\n        // a ⊗ 0 = a + (+inf) = +inf\n        let result = a.tropical_mul(zero);\n        assert!(result.0.is_infinite() \u0026\u0026 result.0 \u003e 0.0);\n    }\n\n    #[test]\n    fn test_operator_overloads() {\n        let a = TropicalMinPlus::new(3.0f64);\n        let b = TropicalMinPlus::new(5.0f64);\n\n        // Add operator (min)\n        assert_eq!((a + b).0, 3.0);\n        assert_eq!((b + a).0, 3.0);\n\n        // Mul operator (add)\n        assert_eq!((a * b).0, 8.0);\n        assert_eq!((b * a).0, 8.0);\n    }\n\n    #[test]\n    fn test_default() {\n        let d = TropicalMinPlus::\u003cf64\u003e::default();\n        assert!(d.0.is_infinite() \u0026\u0026 d.0 \u003e 0.0); // +inf\n        assert_eq!(d, TropicalMinPlus::tropical_zero());\n    }\n\n    #[test]\n    fn test_display_debug() {\n        let a = TropicalMinPlus::new(5.0f64);\n\n        assert_eq!(format!(\"{}\", a), \"5\");\n        assert_eq!(format!(\"{:?}\", a), \"TropicalMinPlus(5)\");\n    }\n\n    #[test]\n    fn test_from() {\n        let a: TropicalMinPlus\u003cf64\u003e = 5.0.into();\n        assert_eq!(a.0, 5.0);\n\n        let b = TropicalMinPlus::\u003cf64\u003e::from(3.0);\n        assert_eq!(b.0, 3.0);\n    }\n\n    #[test]\n    fn test_value_and_from_scalar() {\n        let a = TropicalMinPlus::new(5.0f64);\n        assert_eq!(a.value(), 5.0);\n\n        let b = TropicalMinPlus::\u003cf64\u003e::from_scalar(3.0);\n        assert_eq!(b.value(), 3.0);\n    }\n\n    #[test]\n    fn test_simd_tropical() {\n        assert!(TropicalMinPlus::\u003cf64\u003e::SIMD_AVAILABLE);\n        assert_eq!(TropicalMinPlus::\u003cf64\u003e::SIMD_WIDTH, 8);\n    }\n\n    #[test]\n    fn test_clone_copy() {\n        let a = TropicalMinPlus::new(5.0f64);\n        let a_copy = a;\n        let a_clone = a.clone();\n\n        assert_eq!(a, a_copy);\n        assert_eq!(a, a_clone);\n    }\n\n    #[test]\n    fn test_eq() {\n        let a1 = TropicalMinPlus::new(5.0f64);\n        let a2 = TropicalMinPlus::new(5.0f64);\n        let b = TropicalMinPlus::new(3.0f64);\n\n        assert_eq!(a1, a2);\n        assert_ne!(a1, b);\n    }\n\n    #[test]\n    fn test_f32() {\n        let a = TropicalMinPlus::new(3.0f32);\n        let b = TropicalMinPlus::new(5.0f32);\n\n        assert!((a.tropical_add(b).0 - 3.0).abs() \u003c 1e-6);\n        assert!((a.tropical_mul(b).0 - 8.0).abs() \u003c 1e-6);\n    }\n}\n","traces":[{"line":23,"address":[],"length":0,"stats":{"Line":29}},{"line":24,"address":[],"length":0,"stats":{"Line":29}},{"line":32,"address":[],"length":0,"stats":{"Line":4}},{"line":33,"address":[],"length":0,"stats":{"Line":4}},{"line":37,"address":[],"length":0,"stats":{"Line":1}},{"line":38,"address":[],"length":0,"stats":{"Line":1}},{"line":42,"address":[],"length":0,"stats":{"Line":84}},{"line":43,"address":[],"length":0,"stats":{"Line":168}},{"line":47,"address":[],"length":0,"stats":{"Line":108}},{"line":48,"address":[],"length":0,"stats":{"Line":216}},{"line":52,"address":[],"length":0,"stats":{"Line":2}},{"line":53,"address":[],"length":0,"stats":{"Line":2}},{"line":57,"address":[],"length":0,"stats":{"Line":162}},{"line":58,"address":[],"length":0,"stats":{"Line":162}},{"line":66,"address":[],"length":0,"stats":{"Line":24}},{"line":68,"address":[],"length":0,"stats":{"Line":24}},{"line":69,"address":[],"length":0,"stats":{"Line":16}},{"line":71,"address":[],"length":0,"stats":{"Line":8}},{"line":85,"address":[],"length":0,"stats":{"Line":2}},{"line":86,"address":[],"length":0,"stats":{"Line":6}},{"line":94,"address":[],"length":0,"stats":{"Line":2}},{"line":95,"address":[],"length":0,"stats":{"Line":6}},{"line":101,"address":[],"length":0,"stats":{"Line":1}},{"line":102,"address":[],"length":0,"stats":{"Line":1}},{"line":107,"address":[],"length":0,"stats":{"Line":1}},{"line":108,"address":[],"length":0,"stats":{"Line":3}},{"line":113,"address":[],"length":0,"stats":{"Line":1}},{"line":114,"address":[],"length":0,"stats":{"Line":3}},{"line":120,"address":[],"length":0,"stats":{"Line":1}},{"line":121,"address":[],"length":0,"stats":{"Line":1}}],"covered":30,"coverable":30},{"path":["/","home","leo","rcode","cutropicalgemm","crates","tropical-gemm","src","types","mod.rs"],"content":"//! Tropical number types and semiring traits.\n//!\n//! This module provides the core type system for tropical algebra operations.\n\nmod and_or;\nmod counting;\nmod max_mul;\nmod max_plus;\nmod min_plus;\nmod scalar;\nmod traits;\n\npub use and_or::TropicalAndOr;\npub use counting::CountingTropical;\npub use max_mul::TropicalMaxMul;\npub use max_plus::TropicalMaxPlus;\npub use min_plus::TropicalMinPlus;\npub use scalar::TropicalScalar;\npub use traits::{SimdTropical, TropicalSemiring, TropicalWithArgmax};\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","leo","rcode","cutropicalgemm","crates","tropical-gemm","src","types","scalar.rs"],"content":"use std::fmt::{Debug, Display};\n\n/// Trait for scalar types that can be used as underlying values in tropical numbers.\npub trait TropicalScalar:\n    Copy + Clone + Send + Sync + Debug + Display + PartialOrd + 'static + Sized\n{\n    /// The additive identity (standard arithmetic).\n    fn scalar_zero() -\u003e Self;\n\n    /// The multiplicative identity (standard arithmetic).\n    fn scalar_one() -\u003e Self;\n\n    /// Standard arithmetic addition.\n    fn scalar_add(self, rhs: Self) -\u003e Self;\n\n    /// Standard arithmetic multiplication.\n    fn scalar_mul(self, rhs: Self) -\u003e Self;\n\n    /// Positive infinity (for MinPlus zero).\n    fn pos_infinity() -\u003e Self;\n\n    /// Negative infinity (for MaxPlus zero).\n    fn neg_infinity() -\u003e Self;\n\n    /// Maximum of two values.\n    fn scalar_max(self, rhs: Self) -\u003e Self;\n\n    /// Minimum of two values.\n    fn scalar_min(self, rhs: Self) -\u003e Self;\n}\n\nmacro_rules! impl_tropical_scalar_float {\n    ($($t:ty),*) =\u003e {\n        $(\n            impl TropicalScalar for $t {\n                #[inline(always)]\n                fn scalar_zero() -\u003e Self {\n                    0.0\n                }\n\n                #[inline(always)]\n                fn scalar_one() -\u003e Self {\n                    1.0\n                }\n\n                #[inline(always)]\n                fn scalar_add(self, rhs: Self) -\u003e Self {\n                    self + rhs\n                }\n\n                #[inline(always)]\n                fn scalar_mul(self, rhs: Self) -\u003e Self {\n                    self * rhs\n                }\n\n                #[inline(always)]\n                fn pos_infinity() -\u003e Self {\n                    \u003c$t\u003e::INFINITY\n                }\n\n                #[inline(always)]\n                fn neg_infinity() -\u003e Self {\n                    \u003c$t\u003e::NEG_INFINITY\n                }\n\n                #[inline(always)]\n                fn scalar_max(self, rhs: Self) -\u003e Self {\n                    if self \u003e= rhs { self } else { rhs }\n                }\n\n                #[inline(always)]\n                fn scalar_min(self, rhs: Self) -\u003e Self {\n                    if self \u003c= rhs { self } else { rhs }\n                }\n            }\n        )*\n    };\n}\n\nmacro_rules! impl_tropical_scalar_int {\n    ($($t:ty),*) =\u003e {\n        $(\n            impl TropicalScalar for $t {\n                #[inline(always)]\n                fn scalar_zero() -\u003e Self {\n                    0\n                }\n\n                #[inline(always)]\n                fn scalar_one() -\u003e Self {\n                    1\n                }\n\n                #[inline(always)]\n                fn scalar_add(self, rhs: Self) -\u003e Self {\n                    self + rhs\n                }\n\n                #[inline(always)]\n                fn scalar_mul(self, rhs: Self) -\u003e Self {\n                    self * rhs\n                }\n\n                #[inline(always)]\n                fn pos_infinity() -\u003e Self {\n                    \u003c$t\u003e::MAX\n                }\n\n                #[inline(always)]\n                fn neg_infinity() -\u003e Self {\n                    \u003c$t\u003e::MIN\n                }\n\n                #[inline(always)]\n                fn scalar_max(self, rhs: Self) -\u003e Self {\n                    if self \u003e= rhs { self } else { rhs }\n                }\n\n                #[inline(always)]\n                fn scalar_min(self, rhs: Self) -\u003e Self {\n                    if self \u003c= rhs { self } else { rhs }\n                }\n            }\n        )*\n    };\n}\n\nimpl_tropical_scalar_float!(f32, f64);\nimpl_tropical_scalar_int!(i32, i64, i8, i16, u8, u16, u32, u64);\n\nimpl TropicalScalar for bool {\n    #[inline(always)]\n    fn scalar_zero() -\u003e Self {\n        false\n    }\n\n    #[inline(always)]\n    fn scalar_one() -\u003e Self {\n        true\n    }\n\n    #[inline(always)]\n    fn scalar_add(self, rhs: Self) -\u003e Self {\n        self || rhs\n    }\n\n    #[inline(always)]\n    fn scalar_mul(self, rhs: Self) -\u003e Self {\n        self \u0026\u0026 rhs\n    }\n\n    #[inline(always)]\n    fn pos_infinity() -\u003e Self {\n        true\n    }\n\n    #[inline(always)]\n    fn neg_infinity() -\u003e Self {\n        false\n    }\n\n    #[inline(always)]\n    fn scalar_max(self, rhs: Self) -\u003e Self {\n        self || rhs\n    }\n\n    #[inline(always)]\n    fn scalar_min(self, rhs: Self) -\u003e Self {\n        self \u0026\u0026 rhs\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_f64_scalar() {\n        assert_eq!(f64::scalar_zero(), 0.0);\n        assert_eq!(f64::scalar_one(), 1.0);\n        assert_eq!(3.0f64.scalar_add(5.0), 8.0);\n        assert_eq!(3.0f64.scalar_mul(5.0), 15.0);\n        assert!(f64::pos_infinity().is_infinite() \u0026\u0026 f64::pos_infinity() \u003e 0.0);\n        assert!(f64::neg_infinity().is_infinite() \u0026\u0026 f64::neg_infinity() \u003c 0.0);\n        assert_eq!(3.0f64.scalar_max(5.0), 5.0);\n        assert_eq!(3.0f64.scalar_min(5.0), 3.0);\n    }\n\n    #[test]\n    fn test_f32_scalar() {\n        assert_eq!(f32::scalar_zero(), 0.0);\n        assert_eq!(f32::scalar_one(), 1.0);\n        assert!((3.0f32.scalar_add(5.0) - 8.0).abs() \u003c 1e-6);\n        assert!((3.0f32.scalar_mul(5.0) - 15.0).abs() \u003c 1e-6);\n        assert!(f32::pos_infinity().is_infinite() \u0026\u0026 f32::pos_infinity() \u003e 0.0);\n        assert!(f32::neg_infinity().is_infinite() \u0026\u0026 f32::neg_infinity() \u003c 0.0);\n        assert!((3.0f32.scalar_max(5.0) - 5.0).abs() \u003c 1e-6);\n        assert!((3.0f32.scalar_min(5.0) - 3.0).abs() \u003c 1e-6);\n    }\n\n    #[test]\n    fn test_i32_scalar() {\n        assert_eq!(i32::scalar_zero(), 0);\n        assert_eq!(i32::scalar_one(), 1);\n        assert_eq!(3i32.scalar_add(5), 8);\n        assert_eq!(3i32.scalar_mul(5), 15);\n        assert_eq!(i32::pos_infinity(), i32::MAX);\n        assert_eq!(i32::neg_infinity(), i32::MIN);\n        assert_eq!(3i32.scalar_max(5), 5);\n        assert_eq!(3i32.scalar_min(5), 3);\n    }\n\n    #[test]\n    fn test_i64_scalar() {\n        assert_eq!(i64::scalar_zero(), 0);\n        assert_eq!(i64::scalar_one(), 1);\n        assert_eq!(3i64.scalar_add(5), 8);\n        assert_eq!(3i64.scalar_mul(5), 15);\n        assert_eq!(i64::pos_infinity(), i64::MAX);\n        assert_eq!(i64::neg_infinity(), i64::MIN);\n        assert_eq!(3i64.scalar_max(5), 5);\n        assert_eq!(3i64.scalar_min(5), 3);\n    }\n\n    #[test]\n    fn test_i8_scalar() {\n        assert_eq!(i8::scalar_zero(), 0);\n        assert_eq!(i8::scalar_one(), 1);\n        assert_eq!(3i8.scalar_add(5), 8);\n        assert_eq!(3i8.scalar_mul(5), 15);\n        assert_eq!(i8::pos_infinity(), i8::MAX);\n        assert_eq!(i8::neg_infinity(), i8::MIN);\n        assert_eq!(3i8.scalar_max(5), 5);\n        assert_eq!(3i8.scalar_min(5), 3);\n    }\n\n    #[test]\n    fn test_i16_scalar() {\n        assert_eq!(i16::scalar_zero(), 0);\n        assert_eq!(i16::scalar_one(), 1);\n        assert_eq!(3i16.scalar_add(5), 8);\n        assert_eq!(3i16.scalar_mul(5), 15);\n        assert_eq!(i16::pos_infinity(), i16::MAX);\n        assert_eq!(i16::neg_infinity(), i16::MIN);\n        assert_eq!(3i16.scalar_max(5), 5);\n        assert_eq!(3i16.scalar_min(5), 3);\n    }\n\n    #[test]\n    fn test_u8_scalar() {\n        assert_eq!(u8::scalar_zero(), 0);\n        assert_eq!(u8::scalar_one(), 1);\n        assert_eq!(3u8.scalar_add(5), 8);\n        assert_eq!(3u8.scalar_mul(5), 15);\n        assert_eq!(u8::pos_infinity(), u8::MAX);\n        assert_eq!(u8::neg_infinity(), u8::MIN);\n        assert_eq!(3u8.scalar_max(5), 5);\n        assert_eq!(3u8.scalar_min(5), 3);\n    }\n\n    #[test]\n    fn test_u16_scalar() {\n        assert_eq!(u16::scalar_zero(), 0);\n        assert_eq!(u16::scalar_one(), 1);\n        assert_eq!(3u16.scalar_add(5), 8);\n        assert_eq!(3u16.scalar_mul(5), 15);\n        assert_eq!(u16::pos_infinity(), u16::MAX);\n        assert_eq!(u16::neg_infinity(), u16::MIN);\n        assert_eq!(3u16.scalar_max(5), 5);\n        assert_eq!(3u16.scalar_min(5), 3);\n    }\n\n    #[test]\n    fn test_u32_scalar() {\n        assert_eq!(u32::scalar_zero(), 0);\n        assert_eq!(u32::scalar_one(), 1);\n        assert_eq!(3u32.scalar_add(5), 8);\n        assert_eq!(3u32.scalar_mul(5), 15);\n        assert_eq!(u32::pos_infinity(), u32::MAX);\n        assert_eq!(u32::neg_infinity(), u32::MIN);\n        assert_eq!(3u32.scalar_max(5), 5);\n        assert_eq!(3u32.scalar_min(5), 3);\n    }\n\n    #[test]\n    fn test_u64_scalar() {\n        assert_eq!(u64::scalar_zero(), 0);\n        assert_eq!(u64::scalar_one(), 1);\n        assert_eq!(3u64.scalar_add(5), 8);\n        assert_eq!(3u64.scalar_mul(5), 15);\n        assert_eq!(u64::pos_infinity(), u64::MAX);\n        assert_eq!(u64::neg_infinity(), u64::MIN);\n        assert_eq!(3u64.scalar_max(5), 5);\n        assert_eq!(3u64.scalar_min(5), 3);\n    }\n\n    #[test]\n    fn test_bool_scalar() {\n        assert!(!bool::scalar_zero());\n        assert!(bool::scalar_one());\n        // scalar_add is OR\n        assert!(true.scalar_add(false));\n        assert!(false.scalar_add(true));\n        assert!(!false.scalar_add(false));\n        assert!(true.scalar_add(true));\n        // scalar_mul is AND\n        assert!(!true.scalar_mul(false));\n        assert!(!false.scalar_mul(true));\n        assert!(!false.scalar_mul(false));\n        assert!(true.scalar_mul(true));\n        // pos_infinity is true, neg_infinity is false\n        assert!(bool::pos_infinity());\n        assert!(!bool::neg_infinity());\n        // scalar_max is OR\n        assert!(true.scalar_max(false));\n        assert!(!false.scalar_max(false));\n        // scalar_min is AND\n        assert!(!true.scalar_min(false));\n        assert!(true.scalar_min(true));\n    }\n\n    #[test]\n    fn test_float_edge_cases() {\n        // Test max/min with equal values\n        assert_eq!(5.0f64.scalar_max(5.0), 5.0);\n        assert_eq!(5.0f64.scalar_min(5.0), 5.0);\n        assert_eq!(5.0f32.scalar_max(5.0), 5.0);\n        assert_eq!(5.0f32.scalar_min(5.0), 5.0);\n    }\n\n    #[test]\n    fn test_int_edge_cases() {\n        // Test max/min with equal values\n        assert_eq!(5i32.scalar_max(5), 5);\n        assert_eq!(5i32.scalar_min(5), 5);\n        // Test with negative numbers\n        assert_eq!((-3i32).scalar_max(-5), -3);\n        assert_eq!((-3i32).scalar_min(-5), -5);\n    }\n}\n","traces":[{"line":37,"address":[],"length":0,"stats":{"Line":2}},{"line":38,"address":[],"length":0,"stats":{"Line":2}},{"line":42,"address":[],"length":0,"stats":{"Line":2}},{"line":43,"address":[],"length":0,"stats":{"Line":2}},{"line":47,"address":[],"length":0,"stats":{"Line":6}},{"line":48,"address":[],"length":0,"stats":{"Line":6}},{"line":52,"address":[],"length":0,"stats":{"Line":32}},{"line":53,"address":[],"length":0,"stats":{"Line":32}},{"line":57,"address":[],"length":0,"stats":{"Line":2}},{"line":58,"address":[],"length":0,"stats":{"Line":2}},{"line":62,"address":[],"length":0,"stats":{"Line":3}},{"line":63,"address":[],"length":0,"stats":{"Line":3}},{"line":67,"address":[],"length":0,"stats":{"Line":5}},{"line":68,"address":[],"length":0,"stats":{"Line":10}},{"line":72,"address":[],"length":0,"stats":{"Line":56}},{"line":73,"address":[],"length":0,"stats":{"Line":112}},{"line":85,"address":[],"length":0,"stats":{"Line":8}},{"line":86,"address":[],"length":0,"stats":{"Line":8}},{"line":90,"address":[],"length":0,"stats":{"Line":8}},{"line":91,"address":[],"length":0,"stats":{"Line":8}},{"line":95,"address":[],"length":0,"stats":{"Line":74}},{"line":96,"address":[],"length":0,"stats":{"Line":74}},{"line":100,"address":[],"length":0,"stats":{"Line":22}},{"line":101,"address":[],"length":0,"stats":{"Line":22}},{"line":105,"address":[],"length":0,"stats":{"Line":8}},{"line":106,"address":[],"length":0,"stats":{"Line":8}},{"line":110,"address":[],"length":0,"stats":{"Line":8}},{"line":111,"address":[],"length":0,"stats":{"Line":8}},{"line":115,"address":[],"length":0,"stats":{"Line":62}},{"line":116,"address":[],"length":0,"stats":{"Line":124}},{"line":120,"address":[],"length":0,"stats":{"Line":34}},{"line":121,"address":[],"length":0,"stats":{"Line":68}},{"line":133,"address":[],"length":0,"stats":{"Line":1}},{"line":134,"address":[],"length":0,"stats":{"Line":1}},{"line":138,"address":[],"length":0,"stats":{"Line":1}},{"line":139,"address":[],"length":0,"stats":{"Line":1}},{"line":143,"address":[],"length":0,"stats":{"Line":4}},{"line":144,"address":[],"length":0,"stats":{"Line":6}},{"line":148,"address":[],"length":0,"stats":{"Line":4}},{"line":149,"address":[],"length":0,"stats":{"Line":6}},{"line":153,"address":[],"length":0,"stats":{"Line":1}},{"line":154,"address":[],"length":0,"stats":{"Line":1}},{"line":158,"address":[],"length":0,"stats":{"Line":1}},{"line":159,"address":[],"length":0,"stats":{"Line":1}},{"line":163,"address":[],"length":0,"stats":{"Line":2}},{"line":164,"address":[],"length":0,"stats":{"Line":3}},{"line":168,"address":[],"length":0,"stats":{"Line":2}},{"line":169,"address":[],"length":0,"stats":{"Line":4}}],"covered":48,"coverable":48},{"path":["/","home","leo","rcode","cutropicalgemm","crates","tropical-gemm","src","types","traits.rs"],"content":"use super::scalar::TropicalScalar;\nuse std::fmt::Debug;\n\n/// Core trait for tropical semiring operations.\n///\n/// A semiring (S, ⊕, ⊗) satisfies:\n/// - (S, ⊕) is a commutative monoid with identity `tropical_zero`\n/// - (S, ⊗) is a monoid with identity `tropical_one`\n/// - ⊗ distributes over ⊕\n/// - `tropical_zero` is absorbing: a ⊗ 0 = 0 ⊗ a = 0\npub trait TropicalSemiring: Copy + Clone + Send + Sync + Debug + PartialEq + 'static {\n    /// The underlying scalar type.\n    type Scalar: TropicalScalar;\n\n    /// Returns the additive identity (zero element for ⊕).\n    fn tropical_zero() -\u003e Self;\n\n    /// Returns the multiplicative identity (one element for ⊗).\n    fn tropical_one() -\u003e Self;\n\n    /// Tropical addition (⊕).\n    fn tropical_add(self, rhs: Self) -\u003e Self;\n\n    /// Tropical multiplication (⊗).\n    fn tropical_mul(self, rhs: Self) -\u003e Self;\n\n    /// Get the underlying scalar value.\n    fn value(\u0026self) -\u003e Self::Scalar;\n\n    /// Create from a scalar value.\n    fn from_scalar(s: Self::Scalar) -\u003e Self;\n}\n\n/// Extension trait for tropical types that support argmax tracking.\n///\n/// This is used for backpropagation: during matrix multiplication,\n/// we track which k index produced the optimal value for each C[i,j].\npub trait TropicalWithArgmax: TropicalSemiring {\n    /// The index type used for argmax tracking.\n    type Index: Copy + Default + Debug + Send + Sync + 'static;\n\n    /// Tropical addition with argmax tracking.\n    ///\n    /// Returns the result of `tropical_add` along with the index\n    /// corresponding to which operand \"won\" (produced the result).\n    fn tropical_add_argmax(\n        self,\n        self_idx: Self::Index,\n        rhs: Self,\n        rhs_idx: Self::Index,\n    ) -\u003e (Self, Self::Index);\n}\n\n/// Marker trait for tropical types that support SIMD acceleration.\npub trait SimdTropical: TropicalSemiring {\n    /// Whether SIMD operations are available for this type.\n    const SIMD_AVAILABLE: bool;\n\n    /// The SIMD width in elements.\n    const SIMD_WIDTH: usize;\n}\n","traces":[],"covered":0,"coverable":0}]};
        var previousData = {"files":[{"path":["/","home","leo","rcode","cutropicalgemm","crates","tropical-gemm","benches","gemm_bench.rs"],"content":"use criterion::{black_box, criterion_group, criterion_main, BenchmarkId, Criterion, Throughput};\nuse tropical_gemm::prelude::*;\n\nfn bench_tropical_gemm_f32(c: \u0026mut Criterion) {\n    let mut group = c.benchmark_group(\"TropicalGemm_f32\");\n    group.sample_size(20);\n\n    // Matrix sizes to benchmark (matching Julia comparison)\n    for size in [128, 256, 512, 1024, 2048, 4096].iter() {\n        let n = *size;\n        let elements = (n * n) as u64;\n\n        // Create test matrices\n        let a: Vec\u003cf32\u003e = (0..n * n).map(|i| ((i % 1000) as f32) * 0.01).collect();\n        let b: Vec\u003cf32\u003e = (0..n * n)\n            .map(|i| (((i + 500) % 1000) as f32) * 0.01)\n            .collect();\n\n        group.throughput(Throughput::Elements(elements * 2)); // 2 matrices read\n\n        group.bench_with_input(BenchmarkId::new(\"MaxPlus\", n), \u0026n, |bench, \u0026n| {\n            bench.iter(|| black_box(tropical_matmul::\u003cTropicalMaxPlus\u003cf32\u003e\u003e(\u0026a, n, n, \u0026b, n)));\n        });\n\n        group.bench_with_input(BenchmarkId::new(\"MinPlus\", n), \u0026n, |bench, \u0026n| {\n            bench.iter(|| black_box(tropical_matmul::\u003cTropicalMinPlus\u003cf32\u003e\u003e(\u0026a, n, n, \u0026b, n)));\n        });\n\n        group.bench_with_input(BenchmarkId::new(\"MaxMul\", n), \u0026n, |bench, \u0026n| {\n            bench.iter(|| black_box(tropical_matmul::\u003cTropicalMaxMul\u003cf32\u003e\u003e(\u0026a, n, n, \u0026b, n)));\n        });\n    }\n\n    group.finish();\n}\n\nfn bench_tropical_gemm_f64(c: \u0026mut Criterion) {\n    let mut group = c.benchmark_group(\"TropicalGemm_f64\");\n    group.sample_size(20);\n\n    for size in [128, 256, 512, 1024, 2048].iter() {\n        let n = *size;\n        let elements = (n * n) as u64;\n\n        let a: Vec\u003cf64\u003e = (0..n * n).map(|i| ((i % 1000) as f64) * 0.01).collect();\n        let b: Vec\u003cf64\u003e = (0..n * n)\n            .map(|i| (((i + 500) % 1000) as f64) * 0.01)\n            .collect();\n\n        group.throughput(Throughput::Elements(elements * 2));\n\n        group.bench_with_input(BenchmarkId::new(\"MaxPlus\", n), \u0026n, |bench, \u0026n| {\n            bench.iter(|| black_box(tropical_matmul::\u003cTropicalMaxPlus\u003cf64\u003e\u003e(\u0026a, n, n, \u0026b, n)));\n        });\n    }\n\n    group.finish();\n}\n\nfn bench_with_argmax(c: \u0026mut Criterion) {\n    let mut group = c.benchmark_group(\"TropicalGemm_Argmax\");\n    group.sample_size(20);\n\n    for size in [128, 256, 512, 1024].iter() {\n        let n = *size;\n        let a: Vec\u003cf64\u003e = (0..n * n).map(|i| ((i % 100) as f64) * 0.1).collect();\n        let b: Vec\u003cf64\u003e = (0..n * n)\n            .map(|i| (((i + 50) % 100) as f64) * 0.1)\n            .collect();\n\n        group.bench_with_input(\n            BenchmarkId::new(\"MaxPlus_with_argmax\", n),\n            \u0026n,\n            |bench, \u0026n| {\n                bench.iter(|| {\n                    black_box(tropical_matmul_with_argmax::\u003cTropicalMaxPlus\u003cf64\u003e\u003e(\n                        \u0026a, n, n, \u0026b, n,\n                    ))\n                });\n            },\n        );\n    }\n\n    group.finish();\n}\n\n/// Quick benchmark for command-line timing comparison\nfn bench_quick(c: \u0026mut Criterion) {\n    let mut group = c.benchmark_group(\"Quick\");\n    group.sample_size(10);\n\n    // Standard comparison sizes\n    for size in [1024, 2048, 4096].iter() {\n        let n = *size;\n        let a: Vec\u003cf32\u003e = (0..n * n).map(|i| ((i % 1000) as f32) * 0.01).collect();\n        let b: Vec\u003cf32\u003e = (0..n * n)\n            .map(|i| (((i + 500) % 1000) as f32) * 0.01)\n            .collect();\n\n        group.bench_with_input(BenchmarkId::new(\"MaxPlus_f32\", n), \u0026n, |bench, \u0026n| {\n            bench.iter(|| black_box(tropical_matmul::\u003cTropicalMaxPlus\u003cf32\u003e\u003e(\u0026a, n, n, \u0026b, n)));\n        });\n    }\n\n    group.finish();\n}\n\ncriterion_group!(\n    benches,\n    bench_tropical_gemm_f32,\n    bench_tropical_gemm_f64,\n    bench_with_argmax,\n    bench_quick\n);\ncriterion_main!(benches);\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","leo","rcode","cutropicalgemm","crates","tropical-gemm","examples","basic.rs"],"content":"//! Basic example of tropical matrix multiplication.\n\nuse tropical_gemm::prelude::*;\n\nfn main() {\n    println!(\"Tropical GEMM - Basic Example\\n\");\n    println!(\"{}\\n\", tropical_gemm::version_info());\n\n    // Create two 3x3 matrices\n    // A represents edge weights in a graph (rows = from, cols = to)\n    // We'll use TropicalMaxPlus for longest path computation\n    let a = vec![\n        0.0f64, 1.0, 3.0, // from node 0\n        2.0, 0.0, 1.0, // from node 1\n        1.0, 2.0, 0.0, // from node 2\n    ];\n\n    let b = vec![\n        0.0f64, 2.0, 1.0, // from node 0\n        1.0, 0.0, 3.0, // from node 1\n        2.0, 1.0, 0.0, // from node 2\n    ];\n\n    println!(\"Matrix A (3x3):\");\n    print_matrix(\u0026a, 3, 3);\n\n    println!(\"\\nMatrix B (3x3):\");\n    print_matrix(\u0026b, 3, 3);\n\n    // Compute C = A ⊗ B using TropicalMaxPlus\n    // C[i,j] = max_k(A[i,k] + B[k,j])\n    // This gives the maximum 2-hop path weight from i to j\n    let c = tropical_matmul::\u003cTropicalMaxPlus\u003cf64\u003e\u003e(\u0026a, 3, 3, \u0026b, 3);\n\n    println!(\"\\nResult C = A ⊗ B (TropicalMaxPlus - longest 2-hop paths):\");\n    let c_values: Vec\u003cf64\u003e = c.iter().map(|x| x.value()).collect();\n    print_matrix(\u0026c_values, 3, 3);\n\n    // Now with argmax tracking\n    println!(\"\\n--- With Argmax Tracking ---\\n\");\n\n    let result = tropical_matmul_with_argmax::\u003cTropicalMaxPlus\u003cf64\u003e\u003e(\u0026a, 3, 3, \u0026b, 3);\n\n    println!(\"Longest 2-hop path analysis:\");\n    for i in 0..3 {\n        for j in 0..3 {\n            let value = result.get(i, j).value();\n            let via = result.get_argmax(i, j);\n            println!(\"  {} -\u003e {} via {}: total weight = {:.1}\", i, j, via, value);\n        }\n    }\n\n    // MinPlus example for shortest paths\n    println!(\"\\n--- Shortest Paths (TropicalMinPlus) ---\\n\");\n\n    // Use large values instead of infinity for cleaner output\n    let dist = vec![\n        0.0f64, 1.0, 5.0, // distances from node 0\n        2.0, 0.0, 1.0, // distances from node 1\n        4.0, 3.0, 0.0, // distances from node 2\n    ];\n\n    println!(\"Distance matrix:\");\n    print_matrix(\u0026dist, 3, 3);\n\n    let shortest = tropical_matmul::\u003cTropicalMinPlus\u003cf64\u003e\u003e(\u0026dist, 3, 3, \u0026dist, 3);\n    let shortest_values: Vec\u003cf64\u003e = shortest.iter().map(|x| x.value()).collect();\n\n    println!(\"\\nShortest 2-hop distances:\");\n    print_matrix(\u0026shortest_values, 3, 3);\n\n    // AndOr example for reachability\n    println!(\"\\n--- Graph Reachability (TropicalAndOr) ---\\n\");\n\n    let adj = [\n        false, true, false, // node 0 connects to 1\n        false, false, true, // node 1 connects to 2\n        true, false, false, // node 2 connects to 0\n    ];\n\n    println!(\"Adjacency matrix:\");\n    for i in 0..3 {\n        print!(\"  \");\n        for j in 0..3 {\n            print!(\"{} \", if adj[i * 3 + j] { \"1\" } else { \"0\" });\n        }\n        println!();\n    }\n\n    let adj_tropical: Vec\u003cTropicalAndOr\u003e = adj.iter().map(|\u0026b| TropicalAndOr::new(b)).collect();\n    let mut reach = adj_tropical.clone();\n\n    // Manual 2-hop reachability (since AndOr doesn't implement KernelDispatch for matmul)\n    // This is a simplified example\n    for i in 0..3 {\n        for j in 0..3 {\n            let mut can_reach = adj_tropical[i * 3 + j];\n            for k in 0..3 {\n                can_reach = can_reach\n                    .tropical_add(adj_tropical[i * 3 + k].tropical_mul(adj_tropical[k * 3 + j]));\n            }\n            reach[i * 3 + j] = can_reach;\n        }\n    }\n\n    println!(\"\\n2-hop reachability:\");\n    for i in 0..3 {\n        print!(\"  \");\n        for j in 0..3 {\n            print!(\"{} \", if reach[i * 3 + j].value() { \"1\" } else { \"0\" });\n        }\n        println!();\n    }\n\n    println!(\"\\nDone!\");\n}\n\nfn print_matrix(data: \u0026[f64], rows: usize, cols: usize) {\n    for i in 0..rows {\n        print!(\"  \");\n        for j in 0..cols {\n            print!(\"{:6.1} \", data[i * cols + j]);\n        }\n        println!();\n    }\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","leo","rcode","cutropicalgemm","crates","tropical-gemm","examples","bench_rust.rs"],"content":"//! Quick benchmark for comparison with Julia/CUDA\n//!\n//! Run with: cargo run --release --example bench_rust\n\nuse std::time::Instant;\nuse tropical_gemm::prelude::*;\n\nconst SIZES: \u0026[usize] = \u0026[128, 256, 512, 1024, 2048, 4096];\nconst WARMUP_ITERS: usize = 3;\nconst BENCH_ITERS: usize = 10;\n\nfn bench_maxplus_f32(n: usize) -\u003e (f64, f64) {\n    let a: Vec\u003cf32\u003e = (0..n * n).map(|i| ((i % 1000) as f32) * 0.01).collect();\n    let b: Vec\u003cf32\u003e = (0..n * n)\n        .map(|i| (((i + 500) % 1000) as f32) * 0.01)\n        .collect();\n\n    // Warmup\n    for _ in 0..WARMUP_ITERS {\n        let _ = tropical_matmul::\u003cTropicalMaxPlus\u003cf32\u003e\u003e(\u0026a, n, n, \u0026b, n);\n    }\n\n    // Benchmark\n    let mut times = Vec::with_capacity(BENCH_ITERS);\n    for _ in 0..BENCH_ITERS {\n        let start = Instant::now();\n        let _ = tropical_matmul::\u003cTropicalMaxPlus\u003cf32\u003e\u003e(\u0026a, n, n, \u0026b, n);\n        times.push(start.elapsed().as_secs_f64());\n    }\n\n    times.sort_by(|a, b| a.partial_cmp(b).unwrap());\n    (times[times.len() / 2], times[0])\n}\n\nfn bench_maxplus_f64(n: usize) -\u003e (f64, f64) {\n    let a: Vec\u003cf64\u003e = (0..n * n).map(|i| ((i % 1000) as f64) * 0.01).collect();\n    let b: Vec\u003cf64\u003e = (0..n * n)\n        .map(|i| (((i + 500) % 1000) as f64) * 0.01)\n        .collect();\n\n    for _ in 0..WARMUP_ITERS {\n        let _ = tropical_matmul::\u003cTropicalMaxPlus\u003cf64\u003e\u003e(\u0026a, n, n, \u0026b, n);\n    }\n\n    let mut times = Vec::with_capacity(BENCH_ITERS);\n    for _ in 0..BENCH_ITERS {\n        let start = Instant::now();\n        let _ = tropical_matmul::\u003cTropicalMaxPlus\u003cf64\u003e\u003e(\u0026a, n, n, \u0026b, n);\n        times.push(start.elapsed().as_secs_f64());\n    }\n\n    times.sort_by(|a, b| a.partial_cmp(b).unwrap());\n    (times[times.len() / 2], times[0])\n}\n\nfn bench_minplus_f32(n: usize) -\u003e (f64, f64) {\n    let a: Vec\u003cf32\u003e = (0..n * n).map(|i| ((i % 1000) as f32) * 0.01).collect();\n    let b: Vec\u003cf32\u003e = (0..n * n)\n        .map(|i| (((i + 500) % 1000) as f32) * 0.01)\n        .collect();\n\n    for _ in 0..WARMUP_ITERS {\n        let _ = tropical_matmul::\u003cTropicalMinPlus\u003cf32\u003e\u003e(\u0026a, n, n, \u0026b, n);\n    }\n\n    let mut times = Vec::with_capacity(BENCH_ITERS);\n    for _ in 0..BENCH_ITERS {\n        let start = Instant::now();\n        let _ = tropical_matmul::\u003cTropicalMinPlus\u003cf32\u003e\u003e(\u0026a, n, n, \u0026b, n);\n        times.push(start.elapsed().as_secs_f64());\n    }\n\n    times.sort_by(|a, b| a.partial_cmp(b).unwrap());\n    (times[times.len() / 2], times[0])\n}\n\nfn bench_maxmul_f32(n: usize) -\u003e (f64, f64) {\n    let a: Vec\u003cf32\u003e = (0..n * n).map(|i| ((i % 1000) as f32) * 0.01).collect();\n    let b: Vec\u003cf32\u003e = (0..n * n)\n        .map(|i| (((i + 500) % 1000) as f32) * 0.01)\n        .collect();\n\n    for _ in 0..WARMUP_ITERS {\n        let _ = tropical_matmul::\u003cTropicalMaxMul\u003cf32\u003e\u003e(\u0026a, n, n, \u0026b, n);\n    }\n\n    let mut times = Vec::with_capacity(BENCH_ITERS);\n    for _ in 0..BENCH_ITERS {\n        let start = Instant::now();\n        let _ = tropical_matmul::\u003cTropicalMaxMul\u003cf32\u003e\u003e(\u0026a, n, n, \u0026b, n);\n        times.push(start.elapsed().as_secs_f64());\n    }\n\n    times.sort_by(|a, b| a.partial_cmp(b).unwrap());\n    (times[times.len() / 2], times[0])\n}\n\nfn main() {\n    println!(\"{}\", \"=\".repeat(70));\n    println!(\"Tropical GEMM Rust CPU Benchmark\");\n    println!(\"{}\", \"=\".repeat(70));\n    println!();\n    println!(\"Backend: {}\", Backend::description());\n    println!();\n\n    let mut results: Vec\u003c(\u0026str, Vec\u003c(usize, f64, f64)\u003e)\u003e = Vec::new();\n\n    // Benchmark TropicalMaxPlus\u003cf32\u003e\n    {\n        println!(\"{}\", \"-\".repeat(70));\n        println!(\"Benchmarking: TropicalMaxPlus\u003cf32\u003e\");\n        println!(\"{}\", \"-\".repeat(70));\n        println!(\n            \"{:\u003c8}  {:\u003e12}  {:\u003e12}  {:\u003e12}\",\n            \"Size\", \"Median (ms)\", \"Min (ms)\", \"GFLOPS equiv\"\n        );\n\n        let mut data = Vec::new();\n        for \u0026n in SIZES {\n            let (median, min) = bench_maxplus_f32(n);\n            let gflops = 2.0 * (n as f64).powi(3) / min / 1e9;\n            println!(\n                \"{:\u003c8}  {:\u003e12.3}  {:\u003e12.3}  {:\u003e12.2}\",\n                n,\n                median * 1000.0,\n                min * 1000.0,\n                gflops\n            );\n            data.push((n, median, min));\n        }\n        results.push((\"TropicalMaxPlus\u003cf32\u003e\", data));\n        println!();\n    }\n\n    // Benchmark TropicalMaxPlus\u003cf64\u003e\n    {\n        println!(\"{}\", \"-\".repeat(70));\n        println!(\"Benchmarking: TropicalMaxPlus\u003cf64\u003e\");\n        println!(\"{}\", \"-\".repeat(70));\n        println!(\n            \"{:\u003c8}  {:\u003e12}  {:\u003e12}  {:\u003e12}\",\n            \"Size\", \"Median (ms)\", \"Min (ms)\", \"GFLOPS equiv\"\n        );\n\n        let mut data = Vec::new();\n        for \u0026n in \u0026SIZES[..5] {\n            let (median, min) = bench_maxplus_f64(n);\n            let gflops = 2.0 * (n as f64).powi(3) / min / 1e9;\n            println!(\n                \"{:\u003c8}  {:\u003e12.3}  {:\u003e12.3}  {:\u003e12.2}\",\n                n,\n                median * 1000.0,\n                min * 1000.0,\n                gflops\n            );\n            data.push((n, median, min));\n        }\n        results.push((\"TropicalMaxPlus\u003cf64\u003e\", data));\n        println!();\n    }\n\n    // Benchmark TropicalMinPlus\u003cf32\u003e\n    {\n        println!(\"{}\", \"-\".repeat(70));\n        println!(\"Benchmarking: TropicalMinPlus\u003cf32\u003e\");\n        println!(\"{}\", \"-\".repeat(70));\n        println!(\n            \"{:\u003c8}  {:\u003e12}  {:\u003e12}  {:\u003e12}\",\n            \"Size\", \"Median (ms)\", \"Min (ms)\", \"GFLOPS equiv\"\n        );\n\n        let mut data = Vec::new();\n        for \u0026n in SIZES {\n            let (median, min) = bench_minplus_f32(n);\n            let gflops = 2.0 * (n as f64).powi(3) / min / 1e9;\n            println!(\n                \"{:\u003c8}  {:\u003e12.3}  {:\u003e12.3}  {:\u003e12.2}\",\n                n,\n                median * 1000.0,\n                min * 1000.0,\n                gflops\n            );\n            data.push((n, median, min));\n        }\n        results.push((\"TropicalMinPlus\u003cf32\u003e\", data));\n        println!();\n    }\n\n    // Benchmark TropicalMaxMul\u003cf32\u003e\n    {\n        println!(\"{}\", \"-\".repeat(70));\n        println!(\"Benchmarking: TropicalMaxMul\u003cf32\u003e\");\n        println!(\"{}\", \"-\".repeat(70));\n        println!(\n            \"{:\u003c8}  {:\u003e12}  {:\u003e12}  {:\u003e12}\",\n            \"Size\", \"Median (ms)\", \"Min (ms)\", \"GFLOPS equiv\"\n        );\n\n        let mut data = Vec::new();\n        for \u0026n in SIZES {\n            let (median, min) = bench_maxmul_f32(n);\n            let gflops = 2.0 * (n as f64).powi(3) / min / 1e9;\n            println!(\n                \"{:\u003c8}  {:\u003e12.3}  {:\u003e12.3}  {:\u003e12.2}\",\n                n,\n                median * 1000.0,\n                min * 1000.0,\n                gflops\n            );\n            data.push((n, median, min));\n        }\n        results.push((\"TropicalMaxMul\u003cf32\u003e\", data));\n        println!();\n    }\n\n    // Print summary\n    println!(\"{}\", \"=\".repeat(70));\n    println!(\"Summary (min times in milliseconds) - for comparison with Julia/CUDA\");\n    println!(\"{}\", \"=\".repeat(70));\n    print!(\"{:\u003c8}\", \"Size\");\n    for (name, _) in \u0026results {\n        print!(\"  {:\u003e18}\", name);\n    }\n    println!();\n\n    for (i, \u0026n) in SIZES.iter().enumerate() {\n        print!(\"{:\u003c8}\", n);\n        for (_, data) in \u0026results {\n            if i \u003c data.len() {\n                print!(\"  {:\u003e18.3}\", data[i].2 * 1000.0);\n            } else {\n                print!(\"  {:\u003e18}\", \"N/A\");\n            }\n        }\n        println!();\n    }\n\n    println!();\n    println!(\"Benchmark complete!\");\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","leo","rcode","cutropicalgemm","crates","tropical-gemm","examples","shortest_path.rs"],"content":"//! Shortest path computation using tropical matrix multiplication.\n//!\n//! This example demonstrates how to compute all-pairs shortest paths\n//! using TropicalMinPlus matrix multiplication.\n\nuse tropical_gemm::prelude::*;\n\nfn main() {\n    println!(\"All-Pairs Shortest Path using Tropical GEMM\\n\");\n\n    // Create a weighted directed graph with 5 nodes\n    // Using f64::INFINITY for no direct edge\n    let inf = f64::INFINITY;\n\n    // Distance matrix: dist[i][j] = direct edge weight from i to j\n    #[rustfmt::skip]\n    let dist = vec![\n        0.0, 3.0, inf, 7.0, inf,   // from node 0\n        inf, 0.0, 2.0, inf, inf,   // from node 1\n        inf, inf, 0.0, 1.0, 5.0,   // from node 2\n        inf, inf, inf, 0.0, 2.0,   // from node 3\n        inf, inf, inf, inf, 0.0,   // from node 4\n    ];\n\n    println!(\"Initial distance matrix (direct edges):\");\n    print_matrix(\u0026dist, 5);\n\n    // Compute powers of the distance matrix to find shortest paths\n    // D^2 gives shortest 2-hop paths\n    // D^4 = D^2 * D^2 gives shortest 4-hop paths\n    // For a graph with n nodes, D^(n-1) gives all shortest paths\n\n    let n = 5;\n\n    // D^2\n    let d2 = tropical_matmul::\u003cTropicalMinPlus\u003cf64\u003e\u003e(\u0026dist, n, n, \u0026dist, n);\n    let d2_values: Vec\u003cf64\u003e = d2.iter().map(|x| x.value()).collect();\n\n    println!(\"\\nD^2 (shortest paths up to 2 hops):\");\n    print_matrix(\u0026d2_values, 5);\n\n    // D^4 = D^2 * D^2\n    let d4 = tropical_matmul::\u003cTropicalMinPlus\u003cf64\u003e\u003e(\u0026d2_values, n, n, \u0026d2_values, n);\n    let d4_values: Vec\u003cf64\u003e = d4.iter().map(|x| x.value()).collect();\n\n    println!(\"\\nD^4 (all shortest paths, n-1=4 iterations sufficient):\");\n    print_matrix(\u0026d4_values, 5);\n\n    // Verify some paths\n    println!(\"\\nShortest path distances:\");\n    println!(\"  0 -\u003e 4: {} (path: 0-\u003e3-\u003e4 = 7+2 = 9)\", d4_values[4]);\n    println!(\"  0 -\u003e 2: {} (path: 0-\u003e1-\u003e2 = 3+2 = 5)\", d4_values[2]);\n    println!(\n        \"  1 -\u003e 4: {} (path: 1-\u003e2-\u003e3-\u003e4 = 2+1+2 = 5)\",\n        d4_values[n + 4]\n    );\n\n    // With argmax tracking to find the intermediate nodes\n    println!(\"\\n--- Path Reconstruction with Argmax ---\\n\");\n\n    let result =\n        tropical_matmul_with_argmax::\u003cTropicalMinPlus\u003cf64\u003e\u003e(\u0026d2_values, n, n, \u0026d2_values, n);\n\n    println!(\"For D^4, the argmax indicates which intermediate 2-hop point was used:\");\n    for i in 0..n {\n        for j in 0..n {\n            if i != j {\n                let dist = result.get(i, j).value();\n                let via = result.get_argmax(i, j);\n                if dist \u003c inf {\n                    println!(\"  {} -\u003e {}: distance = {:.1}, via node {}\", i, j, dist, via);\n                }\n            }\n        }\n    }\n}\n\nfn print_matrix(data: \u0026[f64], n: usize) {\n    print!(\"     \");\n    for j in 0..n {\n        print!(\"{:5} \", j);\n    }\n    println!();\n    println!(\"   {}\", \"-\".repeat(n * 6 + 1));\n\n    for i in 0..n {\n        print!(\"{:2} | \", i);\n        for j in 0..n {\n            let val = data[i * n + j];\n            if val == f64::INFINITY {\n                print!(\"  inf \");\n            } else {\n                print!(\"{:5.1} \", val);\n            }\n        }\n        println!();\n    }\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","leo","rcode","cutropicalgemm","crates","tropical-gemm","src","api.rs"],"content":"use crate::core::{GemmWithArgmax, Transpose};\nuse crate::simd::{tropical_gemm_dispatch, KernelDispatch};\nuse crate::types::{TropicalSemiring, TropicalWithArgmax};\n\n/// Simple tropical matrix multiplication: C = A ⊗ B\n///\n/// Computes C[i,j] = ⊕_k (A[i,k] ⊗ B[k,j])\n///\n/// # Arguments\n/// - `a`: Matrix A data in row-major order\n/// - `m`: Number of rows in A\n/// - `k`: Number of columns in A / rows in B\n/// - `b`: Matrix B data in row-major order\n/// - `n`: Number of columns in B\n///\n/// # Returns\n/// Result matrix C of size m×n in row-major order\n///\n/// # Example\n///\n/// ```\n/// use tropical_gemm::{tropical_matmul, TropicalMaxPlus};\n///\n/// let a = vec![1.0f32, 2.0, 3.0, 4.0, 5.0, 6.0]; // 2x3\n/// let b = vec![1.0f32, 2.0, 3.0, 4.0, 5.0, 6.0]; // 3x2\n///\n/// let c = tropical_matmul::\u003cTropicalMaxPlus\u003cf32\u003e\u003e(\u0026a, 2, 3, \u0026b, 2);\n/// assert_eq!(c.len(), 4); // 2x2 result\n/// ```\npub fn tropical_matmul\u003cT: TropicalSemiring + KernelDispatch\u003e(\n    a: \u0026[T::Scalar],\n    m: usize,\n    k: usize,\n    b: \u0026[T::Scalar],\n    n: usize,\n) -\u003e Vec\u003cT\u003e {\n    assert_eq!(a.len(), m * k, \"A dimensions mismatch\");\n    assert_eq!(b.len(), k * n, \"B dimensions mismatch\");\n\n    let mut c = vec![T::tropical_zero(); m * n];\n\n    unsafe {\n        tropical_gemm_dispatch::\u003cT\u003e(\n            m,\n            n,\n            k,\n            a.as_ptr(),\n            k,\n            Transpose::NoTrans,\n            b.as_ptr(),\n            n,\n            Transpose::NoTrans,\n            c.as_mut_ptr(),\n            n,\n        );\n    }\n\n    c\n}\n\n/// Tropical matrix multiplication with argmax tracking.\n///\n/// Returns both the result matrix and the argmax indices indicating\n/// which k produced each optimal C[i,j].\n///\n/// # Example\n///\n/// ```\n/// use tropical_gemm::{tropical_matmul_with_argmax, TropicalMaxPlus};\n///\n/// let a = vec![1.0f64, 2.0, 3.0, 4.0, 5.0, 6.0]; // 2x3\n/// let b = vec![1.0f64, 2.0, 3.0, 4.0, 5.0, 6.0]; // 3x2\n///\n/// let result = tropical_matmul_with_argmax::\u003cTropicalMaxPlus\u003cf64\u003e\u003e(\u0026a, 2, 3, \u0026b, 2);\n/// assert_eq!(result.m, 2);\n/// assert_eq!(result.n, 2);\n/// ```\npub fn tropical_matmul_with_argmax\u003cT: TropicalWithArgmax\u003cIndex = u32\u003e + KernelDispatch\u003e(\n    a: \u0026[T::Scalar],\n    m: usize,\n    k: usize,\n    b: \u0026[T::Scalar],\n    n: usize,\n) -\u003e GemmWithArgmax\u003cT\u003e {\n    assert_eq!(a.len(), m * k, \"A dimensions mismatch\");\n    assert_eq!(b.len(), k * n, \"B dimensions mismatch\");\n\n    let mut result = GemmWithArgmax::new(m, n);\n\n    unsafe {\n        crate::core::tropical_gemm_with_argmax_portable::\u003cT\u003e(\n            m,\n            n,\n            k,\n            a.as_ptr(),\n            k,\n            Transpose::NoTrans,\n            b.as_ptr(),\n            n,\n            Transpose::NoTrans,\n            \u0026mut result,\n        );\n    }\n\n    result\n}\n\n/// Builder for configuring tropical GEMM operations.\n///\n/// Provides a fluent API for setting options like transposition,\n/// alpha/beta scaling, and output preferences.\n///\n/// # Example\n///\n/// ```\n/// use tropical_gemm::{TropicalGemm, TropicalMaxPlus, TropicalSemiring};\n///\n/// let a = vec![1.0f32; 6]; // 2x3\n/// let b = vec![1.0f32; 6]; // 3x2\n/// let mut c = vec![TropicalMaxPlus::tropical_zero(); 4]; // 2x2\n///\n/// TropicalGemm::\u003cTropicalMaxPlus\u003cf32\u003e\u003e::new(2, 2, 3)\n///     .execute(\u0026a, 3, \u0026b, 2, \u0026mut c, 2);\n/// ```\npub struct TropicalGemm\u003cT: TropicalSemiring\u003e {\n    m: usize,\n    n: usize,\n    k: usize,\n    trans_a: Transpose,\n    trans_b: Transpose,\n    _phantom: std::marker::PhantomData\u003cT\u003e,\n}\n\nimpl\u003cT: TropicalSemiring + KernelDispatch\u003e TropicalGemm\u003cT\u003e {\n    /// Create a new GEMM builder.\n    pub fn new(m: usize, n: usize, k: usize) -\u003e Self {\n        Self {\n            m,\n            n,\n            k,\n            trans_a: Transpose::NoTrans,\n            trans_b: Transpose::NoTrans,\n            _phantom: std::marker::PhantomData,\n        }\n    }\n\n    /// Transpose matrix A.\n    pub fn trans_a(mut self) -\u003e Self {\n        self.trans_a = Transpose::Trans;\n        self\n    }\n\n    /// Transpose matrix B.\n    pub fn trans_b(mut self) -\u003e Self {\n        self.trans_b = Transpose::Trans;\n        self\n    }\n\n    /// Execute the GEMM operation.\n    ///\n    /// # Arguments\n    /// - `a`: Matrix A data\n    /// - `lda`: Leading dimension of A\n    /// - `b`: Matrix B data\n    /// - `ldb`: Leading dimension of B\n    /// - `c`: Output matrix C (must be pre-allocated)\n    /// - `ldc`: Leading dimension of C\n    pub fn execute(\n        self,\n        a: \u0026[T::Scalar],\n        lda: usize,\n        b: \u0026[T::Scalar],\n        ldb: usize,\n        c: \u0026mut [T],\n        ldc: usize,\n    ) {\n        unsafe {\n            tropical_gemm_dispatch::\u003cT\u003e(\n                self.m,\n                self.n,\n                self.k,\n                a.as_ptr(),\n                lda,\n                self.trans_a,\n                b.as_ptr(),\n                ldb,\n                self.trans_b,\n                c.as_mut_ptr(),\n                ldc,\n            );\n        }\n    }\n}\n\n/// BLAS-style GEMM interface.\n///\n/// C = A ⊗ B\n///\n/// # Safety\n/// All pointers must be valid for the specified dimensions.\npub unsafe fn tropical_gemm\u003cT: TropicalSemiring + KernelDispatch\u003e(\n    m: usize,\n    n: usize,\n    k: usize,\n    a: *const T::Scalar,\n    lda: usize,\n    trans_a: Transpose,\n    b: *const T::Scalar,\n    ldb: usize,\n    trans_b: Transpose,\n    c: *mut T,\n    ldc: usize,\n) {\n    tropical_gemm_dispatch::\u003cT\u003e(m, n, k, a, lda, trans_a, b, ldb, trans_b, c, ldc);\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use crate::types::TropicalMaxPlus;\n\n    #[test]\n    fn test_tropical_matmul() {\n        let a = vec![1.0f64, 2.0, 3.0, 4.0, 5.0, 6.0];\n        let b = vec![1.0f64, 2.0, 3.0, 4.0, 5.0, 6.0];\n\n        let c = tropical_matmul::\u003cTropicalMaxPlus\u003cf64\u003e\u003e(\u0026a, 2, 3, \u0026b, 2);\n\n        // C[0,0] = max(1+1, 2+3, 3+5) = 8\n        assert_eq!(c[0].0, 8.0);\n        // C[0,1] = max(1+2, 2+4, 3+6) = 9\n        assert_eq!(c[1].0, 9.0);\n        // C[1,0] = max(4+1, 5+3, 6+5) = 11\n        assert_eq!(c[2].0, 11.0);\n        // C[1,1] = max(4+2, 5+4, 6+6) = 12\n        assert_eq!(c[3].0, 12.0);\n    }\n\n    #[test]\n    fn test_tropical_matmul_with_argmax() {\n        let a = vec![1.0f64, 2.0, 3.0, 4.0, 5.0, 6.0];\n        let b = vec![1.0f64, 2.0, 3.0, 4.0, 5.0, 6.0];\n\n        let result = tropical_matmul_with_argmax::\u003cTropicalMaxPlus\u003cf64\u003e\u003e(\u0026a, 2, 3, \u0026b, 2);\n\n        assert_eq!(result.get(0, 0).0, 8.0);\n        assert_eq!(result.get_argmax(0, 0), 2); // k=2 produced max\n\n        assert_eq!(result.get(1, 1).0, 12.0);\n        assert_eq!(result.get_argmax(1, 1), 2); // k=2 produced max\n    }\n\n    #[test]\n    fn test_builder_api() {\n        let a = vec![1.0f32; 6];\n        let b = vec![1.0f32; 6];\n        let mut c = vec![TropicalMaxPlus::tropical_zero(); 4];\n\n        TropicalGemm::\u003cTropicalMaxPlus\u003cf32\u003e\u003e::new(2, 2, 3).execute(\u0026a, 3, \u0026b, 2, \u0026mut c, 2);\n\n        // C[0,0] = max(1+1, 1+1, 1+1) = 2 (tropical mul is addition, tropical add is max)\n        assert_eq!(c[0].0, 2.0);\n    }\n\n    #[test]\n    fn test_builder_api_trans_a() {\n        // A is 3x2 stored as column-major (actually 2x3 in row-major transposed)\n        // A^T is 2x3, B is 3x2, result is 2x2\n        let a = vec![1.0f32, 4.0, 2.0, 5.0, 3.0, 6.0]; // col-major 3x2\n        let b = vec![1.0f32, 2.0, 3.0, 4.0, 5.0, 6.0]; // row-major 3x2\n        let mut c = vec![TropicalMaxPlus::tropical_zero(); 4];\n\n        TropicalGemm::\u003cTropicalMaxPlus\u003cf32\u003e\u003e::new(2, 2, 3)\n            .trans_a()\n            .execute(\u0026a, 2, \u0026b, 2, \u0026mut c, 2);\n\n        // A^T = [[1, 2, 3], [4, 5, 6]]\n        // B = [[1, 2], [3, 4], [5, 6]]\n        // C[0,0] = max(1+1, 2+3, 3+5) = 8\n        assert_eq!(c[0].0, 8.0);\n    }\n\n    #[test]\n    fn test_builder_api_trans_b() {\n        // A is 2x3, B^T is 2x3 stored as column-major, result is 2x2\n        let a = vec![1.0f32, 2.0, 3.0, 4.0, 5.0, 6.0]; // row-major 2x3\n        let b = vec![1.0f32, 3.0, 5.0, 2.0, 4.0, 6.0]; // col-major 2x3\n        let mut c = vec![TropicalMaxPlus::tropical_zero(); 4];\n\n        TropicalGemm::\u003cTropicalMaxPlus\u003cf32\u003e\u003e::new(2, 2, 3)\n            .trans_b()\n            .execute(\u0026a, 3, \u0026b, 3, \u0026mut c, 2);\n\n        // A = [[1, 2, 3], [4, 5, 6]]\n        // B^T = [[1, 2], [3, 4], [5, 6]]\n        // C[0,0] = max(1+1, 2+3, 3+5) = 8\n        assert_eq!(c[0].0, 8.0);\n    }\n\n    #[test]\n    fn test_tropical_matmul_min_plus() {\n        use crate::types::TropicalMinPlus;\n\n        let a = vec![1.0f64, 2.0, 3.0, 4.0, 5.0, 6.0];\n        let b = vec![1.0f64, 2.0, 3.0, 4.0, 5.0, 6.0];\n\n        let c = tropical_matmul::\u003cTropicalMinPlus\u003cf64\u003e\u003e(\u0026a, 2, 3, \u0026b, 2);\n\n        // C[0,0] = min(1+1, 2+3, 3+5) = 2\n        assert_eq!(c[0].0, 2.0);\n        // C[0,1] = min(1+2, 2+4, 3+6) = 3\n        assert_eq!(c[1].0, 3.0);\n        // C[1,0] = min(4+1, 5+3, 6+5) = 5\n        assert_eq!(c[2].0, 5.0);\n        // C[1,1] = min(4+2, 5+4, 6+6) = 6\n        assert_eq!(c[3].0, 6.0);\n    }\n\n    #[test]\n    fn test_tropical_matmul_max_mul() {\n        use crate::types::TropicalMaxMul;\n\n        let a = vec![2.0f64, 3.0, 4.0, 5.0];\n        let b = vec![1.0f64, 2.0, 3.0, 4.0];\n\n        let c = tropical_matmul::\u003cTropicalMaxMul\u003cf64\u003e\u003e(\u0026a, 2, 2, \u0026b, 2);\n\n        // C[0,0] = max(2*1, 3*3) = max(2, 9) = 9\n        assert_eq!(c[0].0, 9.0);\n        // C[0,1] = max(2*2, 3*4) = max(4, 12) = 12\n        assert_eq!(c[1].0, 12.0);\n        // C[1,0] = max(4*1, 5*3) = max(4, 15) = 15\n        assert_eq!(c[2].0, 15.0);\n        // C[1,1] = max(4*2, 5*4) = max(8, 20) = 20\n        assert_eq!(c[3].0, 20.0);\n    }\n\n    #[test]\n    fn test_tropical_matmul_f32() {\n        let a = vec![1.0f32, 2.0, 3.0, 4.0, 5.0, 6.0];\n        let b = vec![1.0f32, 2.0, 3.0, 4.0, 5.0, 6.0];\n\n        let c = tropical_matmul::\u003cTropicalMaxPlus\u003cf32\u003e\u003e(\u0026a, 2, 3, \u0026b, 2);\n\n        assert!((c[0].0 - 8.0).abs() \u003c 1e-6);\n        assert!((c[1].0 - 9.0).abs() \u003c 1e-6);\n        assert!((c[2].0 - 11.0).abs() \u003c 1e-6);\n        assert!((c[3].0 - 12.0).abs() \u003c 1e-6);\n    }\n\n    #[test]\n    fn test_non_square_matrices() {\n        // 3x2 * 2x4 = 3x4\n        let a = vec![1.0f64, 2.0, 3.0, 4.0, 5.0, 6.0];\n        let b = vec![1.0f64, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0];\n\n        let c = tropical_matmul::\u003cTropicalMaxPlus\u003cf64\u003e\u003e(\u0026a, 3, 2, \u0026b, 4);\n\n        assert_eq!(c.len(), 12);\n        // C[0,0] = max(1+1, 2+5) = 7\n        assert_eq!(c[0].0, 7.0);\n    }\n\n    #[test]\n    fn test_single_element() {\n        let a = vec![5.0f64];\n        let b = vec![3.0f64];\n\n        let c = tropical_matmul::\u003cTropicalMaxPlus\u003cf64\u003e\u003e(\u0026a, 1, 1, \u0026b, 1);\n\n        assert_eq!(c.len(), 1);\n        assert_eq!(c[0].0, 8.0); // 5 + 3 = 8\n    }\n\n    #[test]\n    fn test_larger_matrix() {\n        let n = 16;\n        let a: Vec\u003cf64\u003e = (0..n * n).map(|i| i as f64).collect();\n        let b: Vec\u003cf64\u003e = (0..n * n).map(|i| (n * n - 1 - i) as f64).collect();\n\n        let c = tropical_matmul::\u003cTropicalMaxPlus\u003cf64\u003e\u003e(\u0026a, n, n, \u0026b, n);\n\n        assert_eq!(c.len(), n * n);\n        // Just verify it doesn't panic and produces reasonable results\n        for val in \u0026c {\n            assert!(val.0.is_finite());\n        }\n    }\n\n    #[test]\n    fn test_tropical_matmul_i32() {\n        let a = vec![1i32, 2, 3, 4, 5, 6];\n        let b = vec![1i32, 2, 3, 4, 5, 6];\n\n        let c = tropical_matmul::\u003cTropicalMaxPlus\u003ci32\u003e\u003e(\u0026a, 2, 3, \u0026b, 2);\n\n        assert_eq!(c[0].0, 8);\n        assert_eq!(c[1].0, 9);\n        assert_eq!(c[2].0, 11);\n        assert_eq!(c[3].0, 12);\n    }\n\n    #[test]\n    fn test_tropical_matmul_i64() {\n        let a = vec![1i64, 2, 3, 4, 5, 6];\n        let b = vec![1i64, 2, 3, 4, 5, 6];\n\n        let c = tropical_matmul::\u003cTropicalMaxPlus\u003ci64\u003e\u003e(\u0026a, 2, 3, \u0026b, 2);\n\n        assert_eq!(c[0].0, 8);\n        assert_eq!(c[1].0, 9);\n        assert_eq!(c[2].0, 11);\n        assert_eq!(c[3].0, 12);\n    }\n\n    #[test]\n    fn test_tropical_matmul_minplus_i32() {\n        use crate::types::TropicalMinPlus;\n\n        let a = vec![1i32, 2, 3, 4, 5, 6];\n        let b = vec![1i32, 2, 3, 4, 5, 6];\n\n        let c = tropical_matmul::\u003cTropicalMinPlus\u003ci32\u003e\u003e(\u0026a, 2, 3, \u0026b, 2);\n\n        assert_eq!(c[0].0, 2);\n        assert_eq!(c[1].0, 3);\n        assert_eq!(c[2].0, 5);\n        assert_eq!(c[3].0, 6);\n    }\n\n    #[test]\n    fn test_unsafe_tropical_gemm() {\n        let a = vec![1.0f64, 2.0, 3.0, 4.0, 5.0, 6.0];\n        let b = vec![1.0f64, 2.0, 3.0, 4.0, 5.0, 6.0];\n        let mut c = vec![TropicalMaxPlus::tropical_zero(); 4];\n\n        unsafe {\n            tropical_gemm::\u003cTropicalMaxPlus\u003cf64\u003e\u003e(\n                2,\n                2,\n                3,\n                a.as_ptr(),\n                3,\n                Transpose::NoTrans,\n                b.as_ptr(),\n                2,\n                Transpose::NoTrans,\n                c.as_mut_ptr(),\n                2,\n            );\n        }\n\n        assert_eq!(c[0].0, 8.0);\n        assert_eq!(c[1].0, 9.0);\n        assert_eq!(c[2].0, 11.0);\n        assert_eq!(c[3].0, 12.0);\n    }\n\n    #[test]\n    fn test_minplus_with_argmax() {\n        use crate::types::TropicalMinPlus;\n\n        let a = vec![1.0f64, 2.0, 3.0, 4.0, 5.0, 6.0];\n        let b = vec![1.0f64, 2.0, 3.0, 4.0, 5.0, 6.0];\n\n        let result = tropical_matmul_with_argmax::\u003cTropicalMinPlus\u003cf64\u003e\u003e(\u0026a, 2, 3, \u0026b, 2);\n\n        // C[0,0] = min(1+1, 2+3, 3+5) = 2 at k=0\n        assert_eq!(result.get(0, 0).0, 2.0);\n        assert_eq!(result.get_argmax(0, 0), 0);\n\n        // C[1,1] = min(4+2, 5+4, 6+6) = 6 at k=0\n        assert_eq!(result.get(1, 1).0, 6.0);\n        assert_eq!(result.get_argmax(1, 1), 0);\n    }\n\n    #[test]\n    fn test_maxmul_with_argmax() {\n        use crate::types::TropicalMaxMul;\n\n        let a = vec![2.0f64, 3.0, 4.0, 5.0];\n        let b = vec![1.0f64, 2.0, 3.0, 4.0];\n\n        let result = tropical_matmul_with_argmax::\u003cTropicalMaxMul\u003cf64\u003e\u003e(\u0026a, 2, 2, \u0026b, 2);\n\n        // C[0,0] = max(2*1, 3*3) = 9 at k=1\n        assert_eq!(result.get(0, 0).0, 9.0);\n        assert_eq!(result.get_argmax(0, 0), 1);\n    }\n\n    #[test]\n    fn test_gemmwithargmax_dimensions() {\n        let a = vec![1.0f64; 12]; // 3x4\n        let b = vec![1.0f64; 20]; // 4x5\n\n        let result = tropical_matmul_with_argmax::\u003cTropicalMaxPlus\u003cf64\u003e\u003e(\u0026a, 3, 4, \u0026b, 5);\n\n        assert_eq!(result.m, 3);\n        assert_eq!(result.n, 5);\n        assert_eq!(result.values.len(), 15);\n        assert_eq!(result.argmax.len(), 15);\n    }\n\n    #[test]\n    fn test_identity_like_matrix() {\n        // Matrix with -inf everywhere except diagonal has 0\n        let a = vec![0.0f64, f64::NEG_INFINITY, f64::NEG_INFINITY, 0.0];\n        let b = vec![1.0f64, 2.0, 3.0, 4.0];\n\n        let c = tropical_matmul::\u003cTropicalMaxPlus\u003cf64\u003e\u003e(\u0026a, 2, 2, \u0026b, 2);\n\n        // With \"identity\" A, C should equal B\n        assert_eq!(c[0].0, 1.0);\n        assert_eq!(c[1].0, 2.0);\n        assert_eq!(c[2].0, 3.0);\n        assert_eq!(c[3].0, 4.0);\n    }\n}\n","traces":[{"line":30,"address":[],"length":0,"stats":{"Line":11}},{"line":37,"address":[],"length":0,"stats":{"Line":44}},{"line":38,"address":[],"length":0,"stats":{"Line":44}},{"line":40,"address":[],"length":0,"stats":{"Line":44}},{"line":44,"address":[],"length":0,"stats":{"Line":22}},{"line":45,"address":[],"length":0,"stats":{"Line":22}},{"line":46,"address":[],"length":0,"stats":{"Line":22}},{"line":47,"address":[],"length":0,"stats":{"Line":33}},{"line":48,"address":[],"length":0,"stats":{"Line":22}},{"line":49,"address":[],"length":0,"stats":{"Line":22}},{"line":50,"address":[],"length":0,"stats":{"Line":33}},{"line":51,"address":[],"length":0,"stats":{"Line":22}},{"line":52,"address":[],"length":0,"stats":{"Line":22}},{"line":53,"address":[],"length":0,"stats":{"Line":22}},{"line":54,"address":[],"length":0,"stats":{"Line":11}},{"line":58,"address":[],"length":0,"stats":{"Line":11}},{"line":78,"address":[],"length":0,"stats":{"Line":4}},{"line":85,"address":[],"length":0,"stats":{"Line":16}},{"line":86,"address":[],"length":0,"stats":{"Line":16}},{"line":88,"address":[],"length":0,"stats":{"Line":16}},{"line":92,"address":[],"length":0,"stats":{"Line":8}},{"line":93,"address":[],"length":0,"stats":{"Line":8}},{"line":94,"address":[],"length":0,"stats":{"Line":8}},{"line":95,"address":[],"length":0,"stats":{"Line":12}},{"line":96,"address":[],"length":0,"stats":{"Line":8}},{"line":97,"address":[],"length":0,"stats":{"Line":8}},{"line":98,"address":[],"length":0,"stats":{"Line":12}},{"line":99,"address":[],"length":0,"stats":{"Line":8}},{"line":100,"address":[],"length":0,"stats":{"Line":4}},{"line":101,"address":[],"length":0,"stats":{"Line":4}},{"line":105,"address":[],"length":0,"stats":{"Line":4}},{"line":136,"address":[],"length":0,"stats":{"Line":3}},{"line":148,"address":[],"length":0,"stats":{"Line":1}},{"line":149,"address":[],"length":0,"stats":{"Line":1}},{"line":150,"address":[],"length":0,"stats":{"Line":1}},{"line":154,"address":[],"length":0,"stats":{"Line":1}},{"line":155,"address":[],"length":0,"stats":{"Line":1}},{"line":156,"address":[],"length":0,"stats":{"Line":1}},{"line":168,"address":[],"length":0,"stats":{"Line":3}},{"line":179,"address":[],"length":0,"stats":{"Line":6}},{"line":180,"address":[],"length":0,"stats":{"Line":6}},{"line":181,"address":[],"length":0,"stats":{"Line":6}},{"line":182,"address":[],"length":0,"stats":{"Line":9}},{"line":183,"address":[],"length":0,"stats":{"Line":6}},{"line":184,"address":[],"length":0,"stats":{"Line":6}},{"line":185,"address":[],"length":0,"stats":{"Line":9}},{"line":186,"address":[],"length":0,"stats":{"Line":6}},{"line":187,"address":[],"length":0,"stats":{"Line":6}},{"line":188,"address":[],"length":0,"stats":{"Line":6}},{"line":189,"address":[],"length":0,"stats":{"Line":3}},{"line":201,"address":[],"length":0,"stats":{"Line":1}},{"line":214,"address":[],"length":0,"stats":{"Line":12}}],"covered":52,"coverable":52},{"path":["/","home","leo","rcode","cutropicalgemm","crates","tropical-gemm","src","core","argmax.rs"],"content":"use crate::types::TropicalWithArgmax;\n\n/// Result of GEMM with argmax tracking.\n///\n/// For each element C[i,j], tracks which k index produced the optimal value:\n/// C[i,j] = ⊕_{k} A[i,k] ⊗ B[k,j]\n/// argmax[i,j] = argmax_k (A[i,k] ⊗ B[k,j])\n#[derive(Debug, Clone)]\npub struct GemmWithArgmax\u003cT: TropicalWithArgmax\u003cIndex = u32\u003e\u003e {\n    /// The result matrix values.\n    pub values: Vec\u003cT\u003e,\n    /// The argmax indices for each element.\n    pub argmax: Vec\u003cu32\u003e,\n    /// Number of rows in the result.\n    pub m: usize,\n    /// Number of columns in the result.\n    pub n: usize,\n    /// Leading dimension (stride between rows).\n    pub ld: usize,\n}\n\nimpl\u003cT: TropicalWithArgmax\u003cIndex = u32\u003e\u003e GemmWithArgmax\u003cT\u003e {\n    /// Create a new result container with tropical zeros.\n    pub fn new(m: usize, n: usize) -\u003e Self {\n        let size = m * n;\n        Self {\n            values: vec![T::tropical_zero(); size],\n            argmax: vec![0u32; size],\n            m,\n            n,\n            ld: n,\n        }\n    }\n\n    /// Create a new result container with specified leading dimension.\n    pub fn with_ld(m: usize, n: usize, ld: usize) -\u003e Self {\n        assert!(ld \u003e= n, \"Leading dimension must be \u003e= n\");\n        let size = m * ld;\n        Self {\n            values: vec![T::tropical_zero(); size],\n            argmax: vec![0u32; size],\n            m,\n            n,\n            ld,\n        }\n    }\n\n    /// Get value at (i, j).\n    #[inline]\n    pub fn get(\u0026self, i: usize, j: usize) -\u003e T {\n        debug_assert!(i \u003c self.m \u0026\u0026 j \u003c self.n);\n        self.values[i * self.ld + j]\n    }\n\n    /// Get argmax at (i, j).\n    #[inline]\n    pub fn get_argmax(\u0026self, i: usize, j: usize) -\u003e u32 {\n        debug_assert!(i \u003c self.m \u0026\u0026 j \u003c self.n);\n        self.argmax[i * self.ld + j]\n    }\n\n    /// Get mutable reference to value at (i, j).\n    #[inline]\n    pub fn get_mut(\u0026mut self, i: usize, j: usize) -\u003e \u0026mut T {\n        debug_assert!(i \u003c self.m \u0026\u0026 j \u003c self.n);\n        \u0026mut self.values[i * self.ld + j]\n    }\n\n    /// Get mutable reference to argmax at (i, j).\n    #[inline]\n    pub fn get_argmax_mut(\u0026mut self, i: usize, j: usize) -\u003e \u0026mut u32 {\n        debug_assert!(i \u003c self.m \u0026\u0026 j \u003c self.n);\n        \u0026mut self.argmax[i * self.ld + j]\n    }\n\n    /// Get raw pointers to the data.\n    #[inline]\n    pub fn as_mut_ptrs(\u0026mut self) -\u003e (*mut T, *mut u32) {\n        (self.values.as_mut_ptr(), self.argmax.as_mut_ptr())\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use crate::types::TropicalMaxPlus;\n\n    #[test]\n    fn test_gemm_with_argmax_new() {\n        let result: GemmWithArgmax\u003cTropicalMaxPlus\u003cf64\u003e\u003e = GemmWithArgmax::new(3, 4);\n\n        assert_eq!(result.m, 3);\n        assert_eq!(result.n, 4);\n        assert_eq!(result.ld, 4);\n        assert_eq!(result.values.len(), 12);\n        assert_eq!(result.argmax.len(), 12);\n\n        // All values should be tropical zero (-inf)\n        for i in 0..3 {\n            for j in 0..4 {\n                assert_eq!(result.get(i, j).0, f64::NEG_INFINITY);\n                assert_eq!(result.get_argmax(i, j), 0);\n            }\n        }\n    }\n\n    #[test]\n    fn test_gemm_with_argmax_with_ld() {\n        let result: GemmWithArgmax\u003cTropicalMaxPlus\u003cf64\u003e\u003e = GemmWithArgmax::with_ld(3, 4, 8);\n\n        assert_eq!(result.m, 3);\n        assert_eq!(result.n, 4);\n        assert_eq!(result.ld, 8);\n        // Size is m * ld = 3 * 8 = 24\n        assert_eq!(result.values.len(), 24);\n        assert_eq!(result.argmax.len(), 24);\n    }\n\n    #[test]\n    #[should_panic(expected = \"Leading dimension must be \u003e= n\")]\n    fn test_gemm_with_argmax_with_ld_invalid() {\n        let _: GemmWithArgmax\u003cTropicalMaxPlus\u003cf64\u003e\u003e = GemmWithArgmax::with_ld(3, 4, 2);\n    }\n\n    #[test]\n    fn test_gemm_with_argmax_get_mut() {\n        let mut result: GemmWithArgmax\u003cTropicalMaxPlus\u003cf64\u003e\u003e = GemmWithArgmax::new(2, 2);\n\n        // Modify value using get_mut\n        *result.get_mut(0, 1) = TropicalMaxPlus(5.0);\n        *result.get_mut(1, 0) = TropicalMaxPlus(3.0);\n\n        assert_eq!(result.get(0, 1).0, 5.0);\n        assert_eq!(result.get(1, 0).0, 3.0);\n        assert_eq!(result.get(0, 0).0, f64::NEG_INFINITY);\n    }\n\n    #[test]\n    fn test_gemm_with_argmax_get_argmax_mut() {\n        let mut result: GemmWithArgmax\u003cTropicalMaxPlus\u003cf64\u003e\u003e = GemmWithArgmax::new(2, 2);\n\n        // Modify argmax using get_argmax_mut\n        *result.get_argmax_mut(0, 1) = 42;\n        *result.get_argmax_mut(1, 0) = 7;\n\n        assert_eq!(result.get_argmax(0, 1), 42);\n        assert_eq!(result.get_argmax(1, 0), 7);\n        assert_eq!(result.get_argmax(0, 0), 0);\n    }\n\n    #[test]\n    fn test_gemm_with_argmax_as_mut_ptrs() {\n        let mut result: GemmWithArgmax\u003cTropicalMaxPlus\u003cf64\u003e\u003e = GemmWithArgmax::new(2, 3);\n        let (values_ptr, argmax_ptr) = result.as_mut_ptrs();\n\n        // Write through raw pointers\n        unsafe {\n            *values_ptr.add(0) = TropicalMaxPlus(1.0);\n            *values_ptr.add(5) = TropicalMaxPlus(6.0);\n            *argmax_ptr.add(0) = 10;\n            *argmax_ptr.add(5) = 20;\n        }\n\n        assert_eq!(result.get(0, 0).0, 1.0);\n        assert_eq!(result.get(1, 2).0, 6.0);\n        assert_eq!(result.get_argmax(0, 0), 10);\n        assert_eq!(result.get_argmax(1, 2), 20);\n    }\n}\n","traces":[{"line":24,"address":[],"length":0,"stats":{"Line":15}},{"line":25,"address":[],"length":0,"stats":{"Line":30}},{"line":27,"address":[],"length":0,"stats":{"Line":60}},{"line":28,"address":[],"length":0,"stats":{"Line":45}},{"line":36,"address":[],"length":0,"stats":{"Line":2}},{"line":37,"address":[],"length":0,"stats":{"Line":5}},{"line":38,"address":[],"length":0,"stats":{"Line":2}},{"line":40,"address":[],"length":0,"stats":{"Line":4}},{"line":41,"address":[],"length":0,"stats":{"Line":3}},{"line":50,"address":[],"length":0,"stats":{"Line":98}},{"line":51,"address":[],"length":0,"stats":{"Line":294}},{"line":52,"address":[],"length":0,"stats":{"Line":196}},{"line":57,"address":[],"length":0,"stats":{"Line":98}},{"line":58,"address":[],"length":0,"stats":{"Line":294}},{"line":59,"address":[],"length":0,"stats":{"Line":196}},{"line":64,"address":[],"length":0,"stats":{"Line":2}},{"line":65,"address":[],"length":0,"stats":{"Line":6}},{"line":66,"address":[],"length":0,"stats":{"Line":4}},{"line":71,"address":[],"length":0,"stats":{"Line":2}},{"line":72,"address":[],"length":0,"stats":{"Line":6}},{"line":73,"address":[],"length":0,"stats":{"Line":4}},{"line":78,"address":[],"length":0,"stats":{"Line":11}},{"line":79,"address":[],"length":0,"stats":{"Line":33}}],"covered":23,"coverable":23},{"path":["/","home","leo","rcode","cutropicalgemm","crates","tropical-gemm","src","core","gemm.rs"],"content":"use super::argmax::GemmWithArgmax;\nuse super::kernel::{Microkernel, MicrokernelWithArgmax, PortableMicrokernel};\nuse super::packing::{pack_a, pack_b, packed_a_size, packed_b_size, Layout, Transpose};\nuse super::tiling::{BlockIterator, TilingParams};\nuse crate::types::{TropicalSemiring, TropicalWithArgmax};\n\n/// Tropical GEMM: C = A ⊗ B\n///\n/// Computes C[i,j] = ⊕_k (A[i,k] ⊗ B[k,j])\n///\n/// This is a portable (non-SIMD) implementation using BLIS-style blocking\n/// for cache efficiency.\n///\n/// # Parameters\n/// - `m`: Number of rows in A and C\n/// - `n`: Number of columns in B and C\n/// - `k`: Number of columns in A / rows in B\n/// - `a`: Pointer to matrix A data\n/// - `lda`: Leading dimension of A\n/// - `trans_a`: Whether A is transposed\n/// - `b`: Pointer to matrix B data\n/// - `ldb`: Leading dimension of B\n/// - `trans_b`: Whether B is transposed\n/// - `c`: Pointer to matrix C data (output)\n/// - `ldc`: Leading dimension of C\n///\n/// # Safety\n/// - All pointers must be valid for the specified dimensions\n/// - Memory regions must not overlap inappropriately\npub unsafe fn tropical_gemm_portable\u003cT: TropicalSemiring\u003e(\n    m: usize,\n    n: usize,\n    k: usize,\n    a: *const T::Scalar,\n    lda: usize,\n    trans_a: Transpose,\n    b: *const T::Scalar,\n    ldb: usize,\n    trans_b: Transpose,\n    c: *mut T,\n    ldc: usize,\n) {\n    let params = TilingParams::PORTABLE;\n    let kernel = PortableMicrokernel;\n\n    tropical_gemm_inner::\u003cT, PortableMicrokernel\u003e(\n        m, n, k, a, lda, trans_a, b, ldb, trans_b, c, ldc, \u0026params, \u0026kernel,\n    );\n}\n\n/// Tropical GEMM with custom kernel and tiling parameters.\n///\n/// # Safety\n/// Same requirements as `tropical_gemm_portable`\npub unsafe fn tropical_gemm_inner\u003cT: TropicalSemiring, K: Microkernel\u003cT\u003e\u003e(\n    m: usize,\n    n: usize,\n    k: usize,\n    a: *const T::Scalar,\n    lda: usize,\n    trans_a: Transpose,\n    b: *const T::Scalar,\n    ldb: usize,\n    trans_b: Transpose,\n    c: *mut T,\n    ldc: usize,\n    params: \u0026TilingParams,\n    kernel: \u0026K,\n) {\n    if m == 0 || n == 0 || k == 0 {\n        return;\n    }\n\n    // Allocate packing buffers\n    let mut packed_a = vec![T::Scalar::scalar_zero(); packed_a_size(params.mc, params.kc, K::MR)];\n    let mut packed_b = vec![T::Scalar::scalar_zero(); packed_b_size(params.kc, params.nc, K::NR)];\n\n    // BLIS-style 5-loop blocking\n    // Loop 5: blocks of n\n    for (jc, nc) in BlockIterator::new(n, params.nc) {\n        // Loop 4: blocks of k\n        for (pc, kc) in BlockIterator::new(k, params.kc) {\n            // Pack B panel: kc × nc\n            pack_b::\u003cT::Scalar\u003e(\n                kc,\n                nc,\n                b_panel_ptr(b, pc, jc, ldb, trans_b),\n                ldb,\n                Layout::RowMajor,\n                trans_b,\n                packed_b.as_mut_ptr(),\n                K::NR,\n            );\n\n            // Loop 3: blocks of m\n            for (ic, mc) in BlockIterator::new(m, params.mc) {\n                // Pack A panel: mc × kc\n                pack_a::\u003cT::Scalar\u003e(\n                    mc,\n                    kc,\n                    a_panel_ptr(a, ic, pc, lda, trans_a),\n                    lda,\n                    Layout::RowMajor,\n                    trans_a,\n                    packed_a.as_mut_ptr(),\n                    K::MR,\n                );\n\n                // Loop 2: micro-blocks of n\n                let n_blocks = nc.div_ceil(K::NR);\n                for jr in 0..n_blocks {\n                    let j_start = jr * K::NR;\n                    let nr = (nc - j_start).min(K::NR);\n\n                    // Loop 1: micro-blocks of m\n                    let m_blocks = mc.div_ceil(K::MR);\n                    for ir in 0..m_blocks {\n                        let i_start = ir * K::MR;\n                        let mr = (mc - i_start).min(K::MR);\n\n                        // Microkernel\n                        let a_ptr = packed_a.as_ptr().add(ir * K::MR * kc);\n                        let b_ptr = packed_b.as_ptr().add(jr * K::NR * kc);\n                        let c_ptr = c.add((ic + i_start) * ldc + (jc + j_start));\n\n                        kernel.execute(mr, nr, kc, a_ptr, b_ptr, c_ptr, ldc);\n                    }\n                }\n            }\n        }\n    }\n}\n\n/// Tropical GEMM with argmax tracking.\n///\n/// Same as `tropical_gemm_portable` but also computes argmax indices.\n///\n/// # Safety\n/// Same requirements as `tropical_gemm_portable`\npub unsafe fn tropical_gemm_with_argmax_portable\u003cT: TropicalWithArgmax\u003cIndex = u32\u003e\u003e(\n    m: usize,\n    n: usize,\n    k: usize,\n    a: *const T::Scalar,\n    lda: usize,\n    trans_a: Transpose,\n    b: *const T::Scalar,\n    ldb: usize,\n    trans_b: Transpose,\n    result: \u0026mut GemmWithArgmax\u003cT\u003e,\n) {\n    let params = TilingParams::PORTABLE;\n    let kernel = PortableMicrokernel;\n\n    tropical_gemm_with_argmax_inner::\u003cT, PortableMicrokernel\u003e(\n        m, n, k, a, lda, trans_a, b, ldb, trans_b, result, \u0026params, \u0026kernel,\n    );\n}\n\n/// Tropical GEMM with argmax tracking and custom kernel.\n///\n/// # Safety\n/// Same requirements as `tropical_gemm_portable`\npub unsafe fn tropical_gemm_with_argmax_inner\u003c\n    T: TropicalWithArgmax\u003cIndex = u32\u003e,\n    K: MicrokernelWithArgmax\u003cT\u003e,\n\u003e(\n    m: usize,\n    n: usize,\n    k: usize,\n    a: *const T::Scalar,\n    lda: usize,\n    trans_a: Transpose,\n    b: *const T::Scalar,\n    ldb: usize,\n    trans_b: Transpose,\n    result: \u0026mut GemmWithArgmax\u003cT\u003e,\n    params: \u0026TilingParams,\n    kernel: \u0026K,\n) {\n    if m == 0 || n == 0 || k == 0 {\n        return;\n    }\n\n    let ldc = result.ld;\n    let (c, argmax) = result.as_mut_ptrs();\n\n    // Allocate packing buffers\n    let mut packed_a = vec![T::Scalar::scalar_zero(); packed_a_size(params.mc, params.kc, K::MR)];\n    let mut packed_b = vec![T::Scalar::scalar_zero(); packed_b_size(params.kc, params.nc, K::NR)];\n\n    // BLIS-style 5-loop blocking\n    for (jc, nc) in BlockIterator::new(n, params.nc) {\n        for (pc, kc) in BlockIterator::new(k, params.kc) {\n            pack_b::\u003cT::Scalar\u003e(\n                kc,\n                nc,\n                b_panel_ptr(b, pc, jc, ldb, trans_b),\n                ldb,\n                Layout::RowMajor,\n                trans_b,\n                packed_b.as_mut_ptr(),\n                K::NR,\n            );\n\n            for (ic, mc) in BlockIterator::new(m, params.mc) {\n                pack_a::\u003cT::Scalar\u003e(\n                    mc,\n                    kc,\n                    a_panel_ptr(a, ic, pc, lda, trans_a),\n                    lda,\n                    Layout::RowMajor,\n                    trans_a,\n                    packed_a.as_mut_ptr(),\n                    K::MR,\n                );\n\n                let n_blocks = nc.div_ceil(K::NR);\n                for jr in 0..n_blocks {\n                    let j_start = jr * K::NR;\n                    let nr = (nc - j_start).min(K::NR);\n\n                    let m_blocks = mc.div_ceil(K::MR);\n                    for ir in 0..m_blocks {\n                        let i_start = ir * K::MR;\n                        let mr = (mc - i_start).min(K::MR);\n\n                        let a_ptr = packed_a.as_ptr().add(ir * K::MR * kc);\n                        let b_ptr = packed_b.as_ptr().add(jr * K::NR * kc);\n                        let c_ptr = c.add((ic + i_start) * ldc + (jc + j_start));\n                        let argmax_ptr = argmax.add((ic + i_start) * ldc + (jc + j_start));\n\n                        kernel.execute_with_argmax(\n                            mr, nr, kc, pc, a_ptr, b_ptr, c_ptr, argmax_ptr, ldc,\n                        );\n                    }\n                }\n            }\n        }\n    }\n}\n\n/// Get pointer to A panel considering transpose.\n#[inline]\nunsafe fn a_panel_ptr\u003cT\u003e(\n    a: *const T,\n    row: usize,\n    col: usize,\n    lda: usize,\n    trans: Transpose,\n) -\u003e *const T {\n    match trans {\n        Transpose::NoTrans =\u003e a.add(row * lda + col),\n        Transpose::Trans =\u003e a.add(col * lda + row),\n    }\n}\n\n/// Get pointer to B panel considering transpose.\n#[inline]\nunsafe fn b_panel_ptr\u003cT\u003e(\n    b: *const T,\n    row: usize,\n    col: usize,\n    ldb: usize,\n    trans: Transpose,\n) -\u003e *const T {\n    match trans {\n        Transpose::NoTrans =\u003e b.add(row * ldb + col),\n        Transpose::Trans =\u003e b.add(col * ldb + row),\n    }\n}\n\nuse crate::types::TropicalScalar;\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use crate::types::TropicalMaxPlus;\n\n    #[test]\n    fn test_simple_gemm() {\n        let m = 2;\n        let n = 2;\n        let k = 3;\n\n        // A: 2x3 matrix\n        let a: [f64; 6] = [\n            1.0, 2.0, 3.0, // row 0\n            4.0, 5.0, 6.0, // row 1\n        ];\n\n        // B: 3x2 matrix\n        let b: [f64; 6] = [\n            1.0, 2.0, // row 0\n            3.0, 4.0, // row 1\n            5.0, 6.0, // row 2\n        ];\n\n        let mut c = vec![TropicalMaxPlus::tropical_zero(); m * n];\n\n        unsafe {\n            tropical_gemm_portable::\u003cTropicalMaxPlus\u003cf64\u003e\u003e(\n                m,\n                n,\n                k,\n                a.as_ptr(),\n                3,\n                Transpose::NoTrans,\n                b.as_ptr(),\n                2,\n                Transpose::NoTrans,\n                c.as_mut_ptr(),\n                n,\n            );\n        }\n\n        // C[0,0] = max(1+1, 2+3, 3+5) = max(2, 5, 8) = 8\n        assert_eq!(c[0].0, 8.0);\n        // C[0,1] = max(1+2, 2+4, 3+6) = max(3, 6, 9) = 9\n        assert_eq!(c[1].0, 9.0);\n        // C[1,0] = max(4+1, 5+3, 6+5) = max(5, 8, 11) = 11\n        assert_eq!(c[2].0, 11.0);\n        // C[1,1] = max(4+2, 5+4, 6+6) = max(6, 9, 12) = 12\n        assert_eq!(c[3].0, 12.0);\n    }\n\n    #[test]\n    fn test_gemm_with_argmax() {\n        let m = 2;\n        let n = 2;\n        let k = 3;\n\n        let a: [f64; 6] = [1.0, 2.0, 3.0, 4.0, 5.0, 6.0];\n        let b: [f64; 6] = [1.0, 2.0, 3.0, 4.0, 5.0, 6.0];\n\n        let mut result: GemmWithArgmax\u003cTropicalMaxPlus\u003cf64\u003e\u003e = GemmWithArgmax::new(m, n);\n\n        unsafe {\n            tropical_gemm_with_argmax_portable::\u003cTropicalMaxPlus\u003cf64\u003e\u003e(\n                m,\n                n,\n                k,\n                a.as_ptr(),\n                3,\n                Transpose::NoTrans,\n                b.as_ptr(),\n                2,\n                Transpose::NoTrans,\n                \u0026mut result,\n            );\n        }\n\n        // C[0,0] = max(1+1, 2+3, 3+5) = 8 at k=2\n        assert_eq!(result.get(0, 0).0, 8.0);\n        assert_eq!(result.get_argmax(0, 0), 2);\n\n        // C[1,1] = max(4+2, 5+4, 6+6) = 12 at k=2\n        assert_eq!(result.get(1, 1).0, 12.0);\n        assert_eq!(result.get_argmax(1, 1), 2);\n    }\n\n    #[test]\n    fn test_gemm_with_argmax_all_positions() {\n        // Test that argmax correctly tracks the optimal k for all positions\n        let m = 2;\n        let n = 2;\n        let k = 3;\n\n        // Design A and B so each C[i,j] has a different optimal k\n        // A: 2x3, B: 3x2\n        // C[i,j] = max_k(A[i,k] + B[k,j])\n        let a: [f64; 6] = [\n            10.0, 1.0, 1.0, // row 0: k=0 dominates for C[0,*]\n            1.0, 1.0, 10.0, // row 1: k=2 dominates for C[1,*]\n        ];\n        let b: [f64; 6] = [\n            10.0, 1.0, // row 0: col 0 prefers k=0\n            1.0, 10.0, // row 1: col 1 prefers k=1\n            1.0, 1.0, // row 2\n        ];\n\n        let mut result: GemmWithArgmax\u003cTropicalMaxPlus\u003cf64\u003e\u003e = GemmWithArgmax::new(m, n);\n\n        unsafe {\n            tropical_gemm_with_argmax_portable::\u003cTropicalMaxPlus\u003cf64\u003e\u003e(\n                m,\n                n,\n                k,\n                a.as_ptr(),\n                3,\n                Transpose::NoTrans,\n                b.as_ptr(),\n                2,\n                Transpose::NoTrans,\n                \u0026mut result,\n            );\n        }\n\n        // C[0,0] = max(10+10, 1+1, 1+1) = 20 at k=0\n        assert_eq!(result.get(0, 0).0, 20.0);\n        assert_eq!(result.get_argmax(0, 0), 0);\n\n        // C[0,1] = max(10+1, 1+10, 1+1) = 11 at k=0 or k=1 (both give 11)\n        assert_eq!(result.get(0, 1).0, 11.0);\n        // k=0 gives 11, k=1 gives 11 - first wins (\u003e=)\n        assert_eq!(result.get_argmax(0, 1), 0);\n\n        // C[1,0] = max(1+10, 1+1, 10+1) = 11 at k=0 or k=2\n        assert_eq!(result.get(1, 0).0, 11.0);\n        assert_eq!(result.get_argmax(1, 0), 0); // k=0 wins first\n\n        // C[1,1] = max(1+1, 1+10, 10+1) = 11 at k=1 or k=2\n        assert_eq!(result.get(1, 1).0, 11.0);\n        assert_eq!(result.get_argmax(1, 1), 1); // k=1 wins first with 11\n    }\n\n    #[test]\n    fn test_gemm_minplus_with_argmax() {\n        use crate::types::TropicalMinPlus;\n\n        let m = 2;\n        let n = 2;\n        let k = 3;\n\n        // For MinPlus, argmax tracks argmin\n        let a: [f64; 6] = [\n            1.0, 5.0, 3.0, // row 0\n            2.0, 4.0, 6.0, // row 1\n        ];\n        let b: [f64; 6] = [\n            1.0, 2.0, // row 0\n            3.0, 4.0, // row 1\n            5.0, 6.0, // row 2\n        ];\n\n        let mut result: GemmWithArgmax\u003cTropicalMinPlus\u003cf64\u003e\u003e = GemmWithArgmax::new(m, n);\n\n        unsafe {\n            tropical_gemm_with_argmax_portable::\u003cTropicalMinPlus\u003cf64\u003e\u003e(\n                m,\n                n,\n                k,\n                a.as_ptr(),\n                3,\n                Transpose::NoTrans,\n                b.as_ptr(),\n                2,\n                Transpose::NoTrans,\n                \u0026mut result,\n            );\n        }\n\n        // C[0,0] = min(1+1, 5+3, 3+5) = min(2, 8, 8) = 2 at k=0\n        assert_eq!(result.get(0, 0).0, 2.0);\n        assert_eq!(result.get_argmax(0, 0), 0);\n\n        // C[0,1] = min(1+2, 5+4, 3+6) = min(3, 9, 9) = 3 at k=0\n        assert_eq!(result.get(0, 1).0, 3.0);\n        assert_eq!(result.get_argmax(0, 1), 0);\n\n        // C[1,0] = min(2+1, 4+3, 6+5) = min(3, 7, 11) = 3 at k=0\n        assert_eq!(result.get(1, 0).0, 3.0);\n        assert_eq!(result.get_argmax(1, 0), 0);\n\n        // C[1,1] = min(2+2, 4+4, 6+6) = min(4, 8, 12) = 4 at k=0\n        assert_eq!(result.get(1, 1).0, 4.0);\n        assert_eq!(result.get_argmax(1, 1), 0);\n    }\n\n    #[test]\n    fn test_gemm_larger_with_argmax() {\n        // Test with larger matrix to exercise blocking code paths\n        let m = 8;\n        let n = 8;\n        let k = 8;\n\n        let a: Vec\u003cf64\u003e = (0..m * k).map(|i| i as f64).collect();\n        let b: Vec\u003cf64\u003e = (0..k * n).map(|i| (k * n - 1 - i) as f64).collect();\n\n        let mut result: GemmWithArgmax\u003cTropicalMaxPlus\u003cf64\u003e\u003e = GemmWithArgmax::new(m, n);\n\n        unsafe {\n            tropical_gemm_with_argmax_portable::\u003cTropicalMaxPlus\u003cf64\u003e\u003e(\n                m,\n                n,\n                k,\n                a.as_ptr(),\n                k,\n                Transpose::NoTrans,\n                b.as_ptr(),\n                n,\n                Transpose::NoTrans,\n                \u0026mut result,\n            );\n        }\n\n        // Verify all results are finite and argmax indices are valid\n        for i in 0..m {\n            for j in 0..n {\n                assert!(result.get(i, j).0.is_finite());\n                assert!(result.get_argmax(i, j) \u003c k as u32);\n            }\n        }\n    }\n\n    #[test]\n    fn test_gemm_trans_a() {\n        // Test with A transposed\n        // A is stored column-major (3x2), so A^T is 2x3\n        // A^T = [[1, 2, 3], [4, 5, 6]]\n        let m = 2;\n        let n = 2;\n        let k = 3;\n\n        let a: [f64; 6] = [\n            1.0, 4.0, // column 0\n            2.0, 5.0, // column 1\n            3.0, 6.0, // column 2\n        ];\n\n        let b: [f64; 6] = [\n            1.0, 2.0, // row 0\n            3.0, 4.0, // row 1\n            5.0, 6.0, // row 2\n        ];\n\n        let mut c = vec![TropicalMaxPlus::tropical_zero(); m * n];\n\n        unsafe {\n            tropical_gemm_portable::\u003cTropicalMaxPlus\u003cf64\u003e\u003e(\n                m,\n                n,\n                k,\n                a.as_ptr(),\n                2,\n                Transpose::Trans, // lda=2 for column-major 3x2\n                b.as_ptr(),\n                2,\n                Transpose::NoTrans,\n                c.as_mut_ptr(),\n                n,\n            );\n        }\n\n        // A^T = [[1, 2, 3], [4, 5, 6]]\n        // B = [[1, 2], [3, 4], [5, 6]]\n        // C[0,0] = max(1+1, 2+3, 3+5) = 8\n        assert_eq!(c[0].0, 8.0);\n        // C[0,1] = max(1+2, 2+4, 3+6) = 9\n        assert_eq!(c[1].0, 9.0);\n        // C[1,0] = max(4+1, 5+3, 6+5) = 11\n        assert_eq!(c[2].0, 11.0);\n        // C[1,1] = max(4+2, 5+4, 6+6) = 12\n        assert_eq!(c[3].0, 12.0);\n    }\n\n    #[test]\n    fn test_gemm_trans_b() {\n        // Test with B transposed\n        // B is stored column-major (2x3), so B^T is 3x2\n        let m = 2;\n        let n = 2;\n        let k = 3;\n\n        let a: [f64; 6] = [\n            1.0, 2.0, 3.0, // row 0\n            4.0, 5.0, 6.0, // row 1\n        ];\n\n        // B stored column-major: columns are [1,3,5], [2,4,6]\n        let b: [f64; 6] = [\n            1.0, 3.0, 5.0, // column 0 of B^T = row of B\n            2.0, 4.0, 6.0, // column 1 of B^T\n        ];\n\n        let mut c = vec![TropicalMaxPlus::tropical_zero(); m * n];\n\n        unsafe {\n            tropical_gemm_portable::\u003cTropicalMaxPlus\u003cf64\u003e\u003e(\n                m,\n                n,\n                k,\n                a.as_ptr(),\n                3,\n                Transpose::NoTrans,\n                b.as_ptr(),\n                3,\n                Transpose::Trans, // ldb=3 for column-major 2x3\n                c.as_mut_ptr(),\n                n,\n            );\n        }\n\n        // A = [[1, 2, 3], [4, 5, 6]]\n        // B^T = [[1, 2], [3, 4], [5, 6]]\n        // C[0,0] = max(1+1, 2+3, 3+5) = 8\n        assert_eq!(c[0].0, 8.0);\n        assert_eq!(c[1].0, 9.0);\n        assert_eq!(c[2].0, 11.0);\n        assert_eq!(c[3].0, 12.0);\n    }\n\n    #[test]\n    fn test_gemm_trans_both() {\n        // Test with both A and B transposed\n        let m = 2;\n        let n = 2;\n        let k = 3;\n\n        // A column-major (3x2), A^T is 2x3\n        let a: [f64; 6] = [1.0, 4.0, 2.0, 5.0, 3.0, 6.0];\n        // B column-major (2x3), B^T is 3x2\n        let b: [f64; 6] = [1.0, 3.0, 5.0, 2.0, 4.0, 6.0];\n\n        let mut c = vec![TropicalMaxPlus::tropical_zero(); m * n];\n\n        unsafe {\n            tropical_gemm_portable::\u003cTropicalMaxPlus\u003cf64\u003e\u003e(\n                m,\n                n,\n                k,\n                a.as_ptr(),\n                2,\n                Transpose::Trans,\n                b.as_ptr(),\n                3,\n                Transpose::Trans,\n                c.as_mut_ptr(),\n                n,\n            );\n        }\n\n        assert_eq!(c[0].0, 8.0);\n        assert_eq!(c[1].0, 9.0);\n        assert_eq!(c[2].0, 11.0);\n        assert_eq!(c[3].0, 12.0);\n    }\n\n    #[test]\n    fn test_gemm_empty_m() {\n        let m = 0;\n        let n = 2;\n        let k = 3;\n\n        let a: [f64; 0] = [];\n        let b: [f64; 6] = [1.0, 2.0, 3.0, 4.0, 5.0, 6.0];\n        let mut c: Vec\u003cTropicalMaxPlus\u003cf64\u003e\u003e = vec![];\n\n        unsafe {\n            tropical_gemm_portable::\u003cTropicalMaxPlus\u003cf64\u003e\u003e(\n                m,\n                n,\n                k,\n                a.as_ptr(),\n                3,\n                Transpose::NoTrans,\n                b.as_ptr(),\n                2,\n                Transpose::NoTrans,\n                c.as_mut_ptr(),\n                n,\n            );\n        }\n\n        // Should complete without panic\n        assert!(c.is_empty());\n    }\n\n    #[test]\n    fn test_gemm_empty_n() {\n        let m = 2;\n        let n = 0;\n        let k = 3;\n\n        let a: [f64; 6] = [1.0, 2.0, 3.0, 4.0, 5.0, 6.0];\n        let b: [f64; 0] = [];\n        let mut c: Vec\u003cTropicalMaxPlus\u003cf64\u003e\u003e = vec![];\n\n        unsafe {\n            tropical_gemm_portable::\u003cTropicalMaxPlus\u003cf64\u003e\u003e(\n                m,\n                n,\n                k,\n                a.as_ptr(),\n                3,\n                Transpose::NoTrans,\n                b.as_ptr(),\n                2,\n                Transpose::NoTrans,\n                c.as_mut_ptr(),\n                n,\n            );\n        }\n\n        assert!(c.is_empty());\n    }\n\n    #[test]\n    fn test_gemm_empty_k() {\n        let m = 2;\n        let n = 2;\n        let k = 0;\n\n        let a: [f64; 0] = [];\n        let b: [f64; 0] = [];\n        let mut c = vec![TropicalMaxPlus::tropical_zero(); m * n];\n\n        unsafe {\n            tropical_gemm_portable::\u003cTropicalMaxPlus\u003cf64\u003e\u003e(\n                m,\n                n,\n                k,\n                a.as_ptr(),\n                0,\n                Transpose::NoTrans,\n                b.as_ptr(),\n                2,\n                Transpose::NoTrans,\n                c.as_mut_ptr(),\n                n,\n            );\n        }\n\n        // C should remain initialized to tropical_zero\n        for val in \u0026c {\n            assert!(val.0.is_infinite() \u0026\u0026 val.0 \u003c 0.0);\n        }\n    }\n\n    #[test]\n    fn test_gemm_with_argmax_empty_k() {\n        let m = 2;\n        let n = 2;\n        let k = 0;\n\n        let a: [f64; 0] = [];\n        let b: [f64; 0] = [];\n        let mut result: GemmWithArgmax\u003cTropicalMaxPlus\u003cf64\u003e\u003e = GemmWithArgmax::new(m, n);\n\n        unsafe {\n            tropical_gemm_with_argmax_portable::\u003cTropicalMaxPlus\u003cf64\u003e\u003e(\n                m,\n                n,\n                k,\n                a.as_ptr(),\n                0,\n                Transpose::NoTrans,\n                b.as_ptr(),\n                2,\n                Transpose::NoTrans,\n                \u0026mut result,\n            );\n        }\n\n        // Should complete without panic\n        assert_eq!(result.m, 2);\n        assert_eq!(result.n, 2);\n    }\n\n    #[test]\n    fn test_gemm_with_argmax_trans_a() {\n        let m = 2;\n        let n = 2;\n        let k = 3;\n\n        let a: [f64; 6] = [1.0, 4.0, 2.0, 5.0, 3.0, 6.0];\n        let b: [f64; 6] = [1.0, 2.0, 3.0, 4.0, 5.0, 6.0];\n\n        let mut result: GemmWithArgmax\u003cTropicalMaxPlus\u003cf64\u003e\u003e = GemmWithArgmax::new(m, n);\n\n        unsafe {\n            tropical_gemm_with_argmax_portable::\u003cTropicalMaxPlus\u003cf64\u003e\u003e(\n                m,\n                n,\n                k,\n                a.as_ptr(),\n                2,\n                Transpose::Trans,\n                b.as_ptr(),\n                2,\n                Transpose::NoTrans,\n                \u0026mut result,\n            );\n        }\n\n        assert_eq!(result.get(0, 0).0, 8.0);\n        assert_eq!(result.get_argmax(0, 0), 2);\n    }\n\n    #[test]\n    fn test_gemm_with_argmax_trans_b() {\n        let m = 2;\n        let n = 2;\n        let k = 3;\n\n        let a: [f64; 6] = [1.0, 2.0, 3.0, 4.0, 5.0, 6.0];\n        let b: [f64; 6] = [1.0, 3.0, 5.0, 2.0, 4.0, 6.0];\n\n        let mut result: GemmWithArgmax\u003cTropicalMaxPlus\u003cf64\u003e\u003e = GemmWithArgmax::new(m, n);\n\n        unsafe {\n            tropical_gemm_with_argmax_portable::\u003cTropicalMaxPlus\u003cf64\u003e\u003e(\n                m,\n                n,\n                k,\n                a.as_ptr(),\n                3,\n                Transpose::NoTrans,\n                b.as_ptr(),\n                3,\n                Transpose::Trans,\n                \u0026mut result,\n            );\n        }\n\n        assert_eq!(result.get(0, 0).0, 8.0);\n        assert_eq!(result.get_argmax(0, 0), 2);\n    }\n}\n","traces":[{"line":30,"address":[],"length":0,"stats":{"Line":7}},{"line":43,"address":[],"length":0,"stats":{"Line":14}},{"line":44,"address":[],"length":0,"stats":{"Line":14}},{"line":47,"address":[],"length":0,"stats":{"Line":91}},{"line":55,"address":[],"length":0,"stats":{"Line":35}},{"line":70,"address":[],"length":0,"stats":{"Line":102}},{"line":71,"address":[],"length":0,"stats":{"Line":3}},{"line":75,"address":[],"length":0,"stats":{"Line":192}},{"line":76,"address":[],"length":0,"stats":{"Line":192}},{"line":80,"address":[],"length":0,"stats":{"Line":160}},{"line":82,"address":[],"length":0,"stats":{"Line":160}},{"line":85,"address":[],"length":0,"stats":{"Line":32}},{"line":86,"address":[],"length":0,"stats":{"Line":32}},{"line":87,"address":[],"length":0,"stats":{"Line":192}},{"line":88,"address":[],"length":0,"stats":{"Line":32}},{"line":89,"address":[],"length":0,"stats":{"Line":32}},{"line":90,"address":[],"length":0,"stats":{"Line":32}},{"line":91,"address":[],"length":0,"stats":{"Line":64}},{"line":92,"address":[],"length":0,"stats":{"Line":0}},{"line":96,"address":[],"length":0,"stats":{"Line":160}},{"line":99,"address":[],"length":0,"stats":{"Line":32}},{"line":100,"address":[],"length":0,"stats":{"Line":32}},{"line":101,"address":[],"length":0,"stats":{"Line":192}},{"line":102,"address":[],"length":0,"stats":{"Line":32}},{"line":103,"address":[],"length":0,"stats":{"Line":32}},{"line":104,"address":[],"length":0,"stats":{"Line":32}},{"line":105,"address":[],"length":0,"stats":{"Line":64}},{"line":106,"address":[],"length":0,"stats":{"Line":0}},{"line":110,"address":[],"length":0,"stats":{"Line":96}},{"line":111,"address":[],"length":0,"stats":{"Line":68}},{"line":112,"address":[],"length":0,"stats":{"Line":72}},{"line":113,"address":[],"length":0,"stats":{"Line":108}},{"line":116,"address":[],"length":0,"stats":{"Line":108}},{"line":117,"address":[],"length":0,"stats":{"Line":136}},{"line":118,"address":[],"length":0,"stats":{"Line":150}},{"line":119,"address":[],"length":0,"stats":{"Line":200}},{"line":122,"address":[],"length":0,"stats":{"Line":300}},{"line":123,"address":[],"length":0,"stats":{"Line":300}},{"line":124,"address":[],"length":0,"stats":{"Line":300}},{"line":126,"address":[],"length":0,"stats":{"Line":400}},{"line":140,"address":[],"length":0,"stats":{"Line":11}},{"line":152,"address":[],"length":0,"stats":{"Line":22}},{"line":153,"address":[],"length":0,"stats":{"Line":22}},{"line":156,"address":[],"length":0,"stats":{"Line":132}},{"line":164,"address":[],"length":0,"stats":{"Line":11}},{"line":181,"address":[],"length":0,"stats":{"Line":33}},{"line":182,"address":[],"length":0,"stats":{"Line":1}},{"line":185,"address":[],"length":0,"stats":{"Line":20}},{"line":186,"address":[],"length":0,"stats":{"Line":30}},{"line":189,"address":[],"length":0,"stats":{"Line":60}},{"line":190,"address":[],"length":0,"stats":{"Line":60}},{"line":193,"address":[],"length":0,"stats":{"Line":50}},{"line":194,"address":[],"length":0,"stats":{"Line":50}},{"line":196,"address":[],"length":0,"stats":{"Line":10}},{"line":197,"address":[],"length":0,"stats":{"Line":10}},{"line":198,"address":[],"length":0,"stats":{"Line":60}},{"line":199,"address":[],"length":0,"stats":{"Line":10}},{"line":200,"address":[],"length":0,"stats":{"Line":10}},{"line":201,"address":[],"length":0,"stats":{"Line":10}},{"line":202,"address":[],"length":0,"stats":{"Line":20}},{"line":203,"address":[],"length":0,"stats":{"Line":0}},{"line":206,"address":[],"length":0,"stats":{"Line":50}},{"line":208,"address":[],"length":0,"stats":{"Line":10}},{"line":209,"address":[],"length":0,"stats":{"Line":10}},{"line":210,"address":[],"length":0,"stats":{"Line":60}},{"line":211,"address":[],"length":0,"stats":{"Line":10}},{"line":212,"address":[],"length":0,"stats":{"Line":10}},{"line":213,"address":[],"length":0,"stats":{"Line":10}},{"line":214,"address":[],"length":0,"stats":{"Line":20}},{"line":215,"address":[],"length":0,"stats":{"Line":0}},{"line":218,"address":[],"length":0,"stats":{"Line":30}},{"line":219,"address":[],"length":0,"stats":{"Line":22}},{"line":220,"address":[],"length":0,"stats":{"Line":24}},{"line":221,"address":[],"length":0,"stats":{"Line":36}},{"line":223,"address":[],"length":0,"stats":{"Line":36}},{"line":224,"address":[],"length":0,"stats":{"Line":40}},{"line":225,"address":[],"length":0,"stats":{"Line":42}},{"line":226,"address":[],"length":0,"stats":{"Line":56}},{"line":228,"address":[],"length":0,"stats":{"Line":84}},{"line":229,"address":[],"length":0,"stats":{"Line":84}},{"line":230,"address":[],"length":0,"stats":{"Line":84}},{"line":231,"address":[],"length":0,"stats":{"Line":84}},{"line":233,"address":[],"length":0,"stats":{"Line":42}},{"line":234,"address":[],"length":0,"stats":{"Line":112}},{"line":245,"address":[],"length":0,"stats":{"Line":42}},{"line":252,"address":[],"length":0,"stats":{"Line":42}},{"line":253,"address":[],"length":0,"stats":{"Line":114}},{"line":254,"address":[],"length":0,"stats":{"Line":12}},{"line":260,"address":[],"length":0,"stats":{"Line":42}},{"line":267,"address":[],"length":0,"stats":{"Line":42}},{"line":268,"address":[],"length":0,"stats":{"Line":114}},{"line":269,"address":[],"length":0,"stats":{"Line":12}}],"covered":88,"coverable":92},{"path":["/","home","leo","rcode","cutropicalgemm","crates","tropical-gemm","src","core","kernel.rs"],"content":"use crate::types::{TropicalSemiring, TropicalWithArgmax};\n\n/// Trait for GEMM microkernels.\n///\n/// A microkernel computes a small block of C += A * B using register blocking.\n/// The dimensions mr x nr define the \"register tile\" that fits in CPU registers.\npub trait Microkernel\u003cT: TropicalSemiring\u003e {\n    /// Rows of the microkernel (typically 4-8 for f32).\n    const MR: usize;\n\n    /// Columns of the microkernel (typically 4-8 for f32).\n    const NR: usize;\n\n    /// Execute the microkernel.\n    ///\n    /// Computes C[0..mr, 0..nr] = A[0..mr, 0..k] ⊗ B[0..k, 0..nr]\n    /// where the result is combined with existing C values using tropical addition.\n    ///\n    /// # Safety\n    /// - `a` must point to at least `mr * k` elements (packed column-major)\n    /// - `b` must point to at least `k * nr` elements (packed row-major)\n    /// - `c` must point to at least `mr * ldc` elements\n    /// - `mr \u003c= Self::MR` and `nr \u003c= Self::NR`\n    unsafe fn execute(\n        \u0026self,\n        mr: usize,\n        nr: usize,\n        k: usize,\n        a: *const T::Scalar,\n        b: *const T::Scalar,\n        c: *mut T,\n        ldc: usize,\n    );\n}\n\n/// Trait for microkernels that track argmax during computation.\npub trait MicrokernelWithArgmax\u003cT: TropicalWithArgmax\u003cIndex = u32\u003e\u003e: Microkernel\u003cT\u003e {\n    /// Execute the microkernel with argmax tracking.\n    ///\n    /// Same as `execute`, but also fills `argmax` with the k-index that\n    /// produced each optimal C[i,j] value.\n    ///\n    /// # Safety\n    /// Same requirements as `execute`, plus:\n    /// - `argmax` must point to at least `mr * ldc` elements\n    unsafe fn execute_with_argmax(\n        \u0026self,\n        mr: usize,\n        nr: usize,\n        k: usize,\n        k_offset: usize,\n        a: *const T::Scalar,\n        b: *const T::Scalar,\n        c: *mut T,\n        argmax: *mut u32,\n        ldc: usize,\n    );\n}\n\n/// Portable (non-SIMD) microkernel implementation.\n#[derive(Default, Clone, Copy)]\npub struct PortableMicrokernel;\n\n/// Constants for PortableMicrokernel\nimpl PortableMicrokernel {\n    /// Microkernel row dimension.\n    pub const MR: usize = 4;\n    /// Microkernel column dimension.\n    pub const NR: usize = 4;\n}\n\nimpl\u003cT: TropicalSemiring\u003e Microkernel\u003cT\u003e for PortableMicrokernel {\n    const MR: usize = 4;\n    const NR: usize = 4;\n\n    unsafe fn execute(\n        \u0026self,\n        mr: usize,\n        nr: usize,\n        k: usize,\n        a: *const T::Scalar,\n        b: *const T::Scalar,\n        c: *mut T,\n        ldc: usize,\n    ) {\n        const MR: usize = 4;\n        const NR: usize = 4;\n\n        // Initialize accumulators from C\n        let mut acc = [[T::tropical_zero(); NR]; MR];\n        for i in 0..mr {\n            for j in 0..nr {\n                acc[i][j] = *c.add(i * ldc + j);\n            }\n        }\n\n        // Main loop\n        for p in 0..k {\n            for i in 0..mr {\n                let a_val = T::from_scalar(*a.add(p * MR + i));\n                for j in 0..nr {\n                    let b_val = T::from_scalar(*b.add(p * NR + j));\n                    let product = a_val.tropical_mul(b_val);\n                    acc[i][j] = acc[i][j].tropical_add(product);\n                }\n            }\n        }\n\n        // Write back\n        for i in 0..mr {\n            for j in 0..nr {\n                *c.add(i * ldc + j) = acc[i][j];\n            }\n        }\n    }\n}\n\nimpl\u003cT: TropicalWithArgmax\u003cIndex = u32\u003e\u003e MicrokernelWithArgmax\u003cT\u003e for PortableMicrokernel {\n    unsafe fn execute_with_argmax(\n        \u0026self,\n        mr: usize,\n        nr: usize,\n        k: usize,\n        k_offset: usize,\n        a: *const T::Scalar,\n        b: *const T::Scalar,\n        c: *mut T,\n        argmax: *mut u32,\n        ldc: usize,\n    ) {\n        const MR: usize = 4;\n        const NR: usize = 4;\n\n        // Initialize accumulators from C and existing argmax\n        let mut acc = [[T::tropical_zero(); NR]; MR];\n        let mut idx = [[0u32; NR]; MR];\n        for i in 0..mr {\n            for j in 0..nr {\n                acc[i][j] = *c.add(i * ldc + j);\n                idx[i][j] = *argmax.add(i * ldc + j);\n            }\n        }\n\n        // Main loop with argmax tracking\n        for p in 0..k {\n            let current_k = (k_offset + p) as u32;\n            for i in 0..mr {\n                let a_val = T::from_scalar(*a.add(p * MR + i));\n                for j in 0..nr {\n                    let b_val = T::from_scalar(*b.add(p * NR + j));\n                    let product = a_val.tropical_mul(b_val);\n                    let (new_acc, new_idx) =\n                        acc[i][j].tropical_add_argmax(idx[i][j], product, current_k);\n                    acc[i][j] = new_acc;\n                    idx[i][j] = new_idx;\n                }\n            }\n        }\n\n        // Write back\n        for i in 0..mr {\n            for j in 0..nr {\n                *c.add(i * ldc + j) = acc[i][j];\n                *argmax.add(i * ldc + j) = idx[i][j];\n            }\n        }\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use crate::types::TropicalMaxPlus;\n\n    #[test]\n    fn test_portable_kernel() {\n        let kernel = PortableMicrokernel;\n        let mr = 2;\n        let nr = 2;\n        let k = 3;\n\n        // A: 2x3 matrix (packed column-major in MR chunks)\n        // A = [[1, 2, 3],\n        //      [4, 5, 6]]\n        let a: [f64; 12] = [1.0, 4.0, 0.0, 0.0, 2.0, 5.0, 0.0, 0.0, 3.0, 6.0, 0.0, 0.0];\n\n        // B: 3x2 matrix (packed row-major in NR chunks)\n        // B = [[1, 2],\n        //      [3, 4],\n        //      [5, 6]]\n        let b: [f64; 12] = [1.0, 2.0, 0.0, 0.0, 3.0, 4.0, 0.0, 0.0, 5.0, 6.0, 0.0, 0.0];\n\n        // C: 2x2 output\n        let mut c = [TropicalMaxPlus::tropical_zero(); 4];\n        let ldc = 2;\n\n        unsafe {\n            kernel.execute(mr, nr, k, a.as_ptr(), b.as_ptr(), c.as_mut_ptr(), ldc);\n        }\n\n        // C[0,0] = max(A[0,0]+B[0,0], A[0,1]+B[1,0], A[0,2]+B[2,0])\n        //        = max(1+1, 2+3, 3+5) = max(2, 5, 8) = 8\n        assert_eq!(c[0].0, 8.0);\n\n        // C[0,1] = max(1+2, 2+4, 3+6) = max(3, 6, 9) = 9\n        assert_eq!(c[1].0, 9.0);\n\n        // C[1,0] = max(4+1, 5+3, 6+5) = max(5, 8, 11) = 11\n        assert_eq!(c[2].0, 11.0);\n\n        // C[1,1] = max(4+2, 5+4, 6+6) = max(6, 9, 12) = 12\n        assert_eq!(c[3].0, 12.0);\n    }\n\n    #[test]\n    fn test_portable_kernel_minplus() {\n        use crate::types::TropicalMinPlus;\n\n        let kernel = PortableMicrokernel;\n        let mr = 2;\n        let nr = 2;\n        let k = 3;\n\n        let a: [f64; 12] = [1.0, 4.0, 0.0, 0.0, 2.0, 5.0, 0.0, 0.0, 3.0, 6.0, 0.0, 0.0];\n        let b: [f64; 12] = [1.0, 2.0, 0.0, 0.0, 3.0, 4.0, 0.0, 0.0, 5.0, 6.0, 0.0, 0.0];\n\n        let mut c = [TropicalMinPlus::tropical_zero(); 4];\n        let ldc = 2;\n\n        unsafe {\n            kernel.execute(mr, nr, k, a.as_ptr(), b.as_ptr(), c.as_mut_ptr(), ldc);\n        }\n\n        // C[0,0] = min(1+1, 2+3, 3+5) = min(2, 5, 8) = 2\n        assert_eq!(c[0].0, 2.0);\n        // C[0,1] = min(1+2, 2+4, 3+6) = min(3, 6, 9) = 3\n        assert_eq!(c[1].0, 3.0);\n        // C[1,0] = min(4+1, 5+3, 6+5) = min(5, 8, 11) = 5\n        assert_eq!(c[2].0, 5.0);\n        // C[1,1] = min(4+2, 5+4, 6+6) = min(6, 9, 12) = 6\n        assert_eq!(c[3].0, 6.0);\n    }\n\n    #[test]\n    fn test_portable_kernel_maxmul() {\n        use crate::types::TropicalMaxMul;\n\n        let kernel = PortableMicrokernel;\n        let mr = 2;\n        let nr = 2;\n        let k = 2;\n\n        // A: [[2, 4], [3, 5]]\n        let a: [f64; 8] = [2.0, 3.0, 0.0, 0.0, 4.0, 5.0, 0.0, 0.0];\n        // B: [[1, 2], [3, 4]]\n        let b: [f64; 8] = [1.0, 2.0, 0.0, 0.0, 3.0, 4.0, 0.0, 0.0];\n\n        let mut c = [TropicalMaxMul::tropical_zero(); 4];\n        let ldc = 2;\n\n        unsafe {\n            kernel.execute(mr, nr, k, a.as_ptr(), b.as_ptr(), c.as_mut_ptr(), ldc);\n        }\n\n        // C[0,0] = max(2*1, 4*3) = max(2, 12) = 12\n        assert_eq!(c[0].0, 12.0);\n        // C[0,1] = max(2*2, 4*4) = max(4, 16) = 16\n        assert_eq!(c[1].0, 16.0);\n        // C[1,0] = max(3*1, 5*3) = max(3, 15) = 15\n        assert_eq!(c[2].0, 15.0);\n        // C[1,1] = max(3*2, 5*4) = max(6, 20) = 20\n        assert_eq!(c[3].0, 20.0);\n    }\n\n    #[test]\n    fn test_portable_kernel_with_argmax() {\n        let kernel = PortableMicrokernel;\n        let mr = 2;\n        let nr = 2;\n        let k = 3;\n\n        let a: [f64; 12] = [1.0, 4.0, 0.0, 0.0, 2.0, 5.0, 0.0, 0.0, 3.0, 6.0, 0.0, 0.0];\n        let b: [f64; 12] = [1.0, 2.0, 0.0, 0.0, 3.0, 4.0, 0.0, 0.0, 5.0, 6.0, 0.0, 0.0];\n\n        let mut c = [TropicalMaxPlus::tropical_zero(); 4];\n        let mut argmax = [0u32; 4];\n        let ldc = 2;\n        let k_offset = 0;\n\n        unsafe {\n            kernel.execute_with_argmax(\n                mr,\n                nr,\n                k,\n                k_offset,\n                a.as_ptr(),\n                b.as_ptr(),\n                c.as_mut_ptr(),\n                argmax.as_mut_ptr(),\n                ldc,\n            );\n        }\n\n        // C[0,0] = max(1+1, 2+3, 3+5) = 8 at k=2\n        assert_eq!(c[0].0, 8.0);\n        assert_eq!(argmax[0], 2);\n\n        // C[0,1] = max(1+2, 2+4, 3+6) = 9 at k=2\n        assert_eq!(c[1].0, 9.0);\n        assert_eq!(argmax[1], 2);\n\n        // C[1,0] = max(4+1, 5+3, 6+5) = 11 at k=2\n        assert_eq!(c[2].0, 11.0);\n        assert_eq!(argmax[2], 2);\n\n        // C[1,1] = max(4+2, 5+4, 6+6) = 12 at k=2\n        assert_eq!(c[3].0, 12.0);\n        assert_eq!(argmax[3], 2);\n    }\n\n    #[test]\n    fn test_portable_kernel_with_argmax_offset() {\n        // Test that k_offset is correctly applied\n        let kernel = PortableMicrokernel;\n        let mr = 2;\n        let nr = 2;\n        let k = 2;\n\n        let a: [f64; 8] = [1.0, 2.0, 0.0, 0.0, 10.0, 20.0, 0.0, 0.0];\n        let b: [f64; 8] = [1.0, 1.0, 0.0, 0.0, 1.0, 1.0, 0.0, 0.0];\n\n        let mut c = [TropicalMaxPlus::tropical_zero(); 4];\n        let mut argmax = [0u32; 4];\n        let ldc = 2;\n        let k_offset = 5; // Start from global k=5\n\n        unsafe {\n            kernel.execute_with_argmax(\n                mr,\n                nr,\n                k,\n                k_offset,\n                a.as_ptr(),\n                b.as_ptr(),\n                c.as_mut_ptr(),\n                argmax.as_mut_ptr(),\n                ldc,\n            );\n        }\n\n        // A[:,1] has larger values, so k=1 (global k=6) should win\n        // C[0,0] = max(1+1, 10+1) = 11 at local k=1, global k=6\n        assert_eq!(c[0].0, 11.0);\n        assert_eq!(argmax[0], 6); // k_offset + 1\n\n        // C[1,0] = max(2+1, 20+1) = 21 at local k=1, global k=6\n        assert_eq!(c[2].0, 21.0);\n        assert_eq!(argmax[2], 6);\n    }\n\n    #[test]\n    fn test_portable_kernel_f32() {\n        let kernel = PortableMicrokernel;\n        let mr = 2;\n        let nr = 2;\n        let k = 2;\n\n        let a: [f32; 8] = [1.0, 2.0, 0.0, 0.0, 3.0, 4.0, 0.0, 0.0];\n        let b: [f32; 8] = [1.0, 2.0, 0.0, 0.0, 3.0, 4.0, 0.0, 0.0];\n\n        let mut c = [TropicalMaxPlus::tropical_zero(); 4];\n        let ldc = 2;\n\n        unsafe {\n            kernel.execute(mr, nr, k, a.as_ptr(), b.as_ptr(), c.as_mut_ptr(), ldc);\n        }\n\n        // C[0,0] = max(1+1, 3+3) = 6\n        assert!((c[0].0 - 6.0).abs() \u003c 1e-6);\n        // C[0,1] = max(1+2, 3+4) = 7\n        assert!((c[1].0 - 7.0).abs() \u003c 1e-6);\n    }\n}\n","traces":[{"line":76,"address":[],"length":0,"stats":{"Line":22}},{"line":90,"address":[],"length":0,"stats":{"Line":44}},{"line":91,"address":[],"length":0,"stats":{"Line":66}},{"line":92,"address":[],"length":0,"stats":{"Line":220}},{"line":93,"address":[],"length":0,"stats":{"Line":352}},{"line":98,"address":[],"length":0,"stats":{"Line":76}},{"line":99,"address":[],"length":0,"stats":{"Line":162}},{"line":100,"address":[],"length":0,"stats":{"Line":540}},{"line":101,"address":[],"length":0,"stats":{"Line":540}},{"line":102,"address":[],"length":0,"stats":{"Line":1296}},{"line":103,"address":[],"length":0,"stats":{"Line":1080}},{"line":104,"address":[],"length":0,"stats":{"Line":648}},{"line":110,"address":[],"length":0,"stats":{"Line":66}},{"line":111,"address":[],"length":0,"stats":{"Line":220}},{"line":112,"address":[],"length":0,"stats":{"Line":352}},{"line":119,"address":[],"length":0,"stats":{"Line":17}},{"line":135,"address":[],"length":0,"stats":{"Line":34}},{"line":136,"address":[],"length":0,"stats":{"Line":34}},{"line":137,"address":[],"length":0,"stats":{"Line":61}},{"line":138,"address":[],"length":0,"stats":{"Line":290}},{"line":139,"address":[],"length":0,"stats":{"Line":615}},{"line":140,"address":[],"length":0,"stats":{"Line":492}},{"line":145,"address":[],"length":0,"stats":{"Line":87}},{"line":146,"address":[],"length":0,"stats":{"Line":140}},{"line":147,"address":[],"length":0,"stats":{"Line":282}},{"line":148,"address":[],"length":0,"stats":{"Line":1060}},{"line":149,"address":[],"length":0,"stats":{"Line":1596}},{"line":150,"address":[],"length":0,"stats":{"Line":4152}},{"line":151,"address":[],"length":0,"stats":{"Line":3460}},{"line":152,"address":[],"length":0,"stats":{"Line":2076}},{"line":153,"address":[],"length":0,"stats":{"Line":3460}},{"line":154,"address":[],"length":0,"stats":{"Line":1384}},{"line":155,"address":[],"length":0,"stats":{"Line":692}},{"line":161,"address":[],"length":0,"stats":{"Line":61}},{"line":162,"address":[],"length":0,"stats":{"Line":290}},{"line":163,"address":[],"length":0,"stats":{"Line":615}},{"line":164,"address":[],"length":0,"stats":{"Line":492}}],"covered":37,"coverable":37},{"path":["/","home","leo","rcode","cutropicalgemm","crates","tropical-gemm","src","core","mod.rs"],"content":"//! Core tropical GEMM algorithms.\n//!\n//! This module provides the portable implementation of tropical\n//! matrix multiplication using BLIS-style blocking for cache efficiency.\n\nmod argmax;\nmod gemm;\nmod kernel;\nmod packing;\nmod tiling;\n\npub use argmax::GemmWithArgmax;\npub use gemm::{\n    tropical_gemm_inner, tropical_gemm_portable, tropical_gemm_with_argmax_inner,\n    tropical_gemm_with_argmax_portable,\n};\npub use kernel::{Microkernel, MicrokernelWithArgmax, PortableMicrokernel};\npub use packing::{pack_a, pack_b, packed_a_size, packed_b_size, Layout, Transpose};\npub use tiling::{BlockIterator, TilingParams};\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","leo","rcode","cutropicalgemm","crates","tropical-gemm","src","core","packing.rs"],"content":"use crate::types::TropicalScalar;\n\n/// Matrix layout enumeration.\n#[derive(Debug, Clone, Copy, PartialEq, Eq)]\npub enum Layout {\n    /// Row-major layout (C-style).\n    RowMajor,\n    /// Column-major layout (Fortran-style).\n    ColMajor,\n}\n\n/// Transpose specification.\n#[derive(Debug, Clone, Copy, PartialEq, Eq)]\npub enum Transpose {\n    /// No transpose.\n    NoTrans,\n    /// Transpose the matrix.\n    Trans,\n}\n\n/// Pack a panel of matrix A into a contiguous buffer.\n///\n/// The packed format stores `mc` rows in column-major order within\n/// blocks of `mr` rows. This improves cache locality during the\n/// microkernel computation.\n///\n/// # Layout\n/// For A with dimensions m×k:\n/// ```text\n/// Original A (row-major, m=6, k=4, mr=4):\n/// [ a00 a01 a02 a03 ]\n/// [ a10 a11 a12 a13 ]\n/// [ a20 a21 a22 a23 ]\n/// [ a30 a31 a32 a33 ]\n/// [ a40 a41 a42 a43 ]\n/// [ a50 a51 a52 a53 ]\n///\n/// Packed (column-major within mr×k blocks):\n/// Block 0 (rows 0-3): a00 a10 a20 a30 | a01 a11 a21 a31 | a02 a12 a22 a32 | a03 a13 a23 a33\n/// Block 1 (rows 4-5): a40 a50 0   0   | a41 a51 0   0   | a42 a52 0   0   | a43 a53 0   0\n/// ```\n///\n/// # Safety\n/// - `a` must point to valid memory for at least `m * lda` elements\n/// - `packed` must have capacity for at least `((m + mr - 1) / mr) * mr * k` elements\npub unsafe fn pack_a\u003cT: TropicalScalar\u003e(\n    m: usize,\n    k: usize,\n    a: *const T,\n    lda: usize,\n    layout: Layout,\n    trans: Transpose,\n    packed: *mut T,\n    mr: usize,\n) {\n    let zero = T::scalar_zero();\n\n    let mut packed_idx = 0;\n\n    // Process full mr×k blocks\n    let m_blocks = m / mr;\n    let m_rem = m % mr;\n\n    for block in 0..m_blocks {\n        let row_start = block * mr;\n        for col in 0..k {\n            for row_offset in 0..mr {\n                let row = row_start + row_offset;\n                let val = get_element(a, row, col, lda, layout, trans);\n                *packed.add(packed_idx) = val;\n                packed_idx += 1;\n            }\n        }\n    }\n\n    // Process remaining rows (if any)\n    if m_rem \u003e 0 {\n        let row_start = m_blocks * mr;\n        for col in 0..k {\n            for row_offset in 0..mr {\n                let row = row_start + row_offset;\n                let val = if row \u003c m {\n                    get_element(a, row, col, lda, layout, trans)\n                } else {\n                    zero\n                };\n                *packed.add(packed_idx) = val;\n                packed_idx += 1;\n            }\n        }\n    }\n}\n\n/// Pack a panel of matrix B into a contiguous buffer.\n///\n/// The packed format stores `nc` columns in row-major order within\n/// blocks of `nr` columns.\n///\n/// # Layout\n/// For B with dimensions k×n:\n/// ```text\n/// Original B (row-major, k=3, n=6, nr=4):\n/// [ b00 b01 b02 b03 b04 b05 ]\n/// [ b10 b11 b12 b13 b14 b15 ]\n/// [ b20 b21 b22 b23 b24 b25 ]\n///\n/// Packed (row-major within k×nr blocks):\n/// Block 0 (cols 0-3): b00 b01 b02 b03 | b10 b11 b12 b13 | b20 b21 b22 b23\n/// Block 1 (cols 4-5): b04 b05 0   0   | b14 b15 0   0   | b24 b25 0   0\n/// ```\n///\n/// # Safety\n/// - `b` must point to valid memory for at least `k * ldb` or `ldb * n` elements\n/// - `packed` must have capacity for at least `((n + nr - 1) / nr) * nr * k` elements\npub unsafe fn pack_b\u003cT: TropicalScalar\u003e(\n    k: usize,\n    n: usize,\n    b: *const T,\n    ldb: usize,\n    layout: Layout,\n    trans: Transpose,\n    packed: *mut T,\n    nr: usize,\n) {\n    let zero = T::scalar_zero();\n\n    let mut packed_idx = 0;\n\n    // Process full k×nr blocks\n    let n_blocks = n / nr;\n    let n_rem = n % nr;\n\n    for block in 0..n_blocks {\n        let col_start = block * nr;\n        for row in 0..k {\n            for col_offset in 0..nr {\n                let col = col_start + col_offset;\n                let val = get_element(b, row, col, ldb, layout, trans);\n                *packed.add(packed_idx) = val;\n                packed_idx += 1;\n            }\n        }\n    }\n\n    // Process remaining columns (if any)\n    if n_rem \u003e 0 {\n        let col_start = n_blocks * nr;\n        for row in 0..k {\n            for col_offset in 0..nr {\n                let col = col_start + col_offset;\n                let val = if col \u003c n {\n                    get_element(b, row, col, ldb, layout, trans)\n                } else {\n                    zero\n                };\n                *packed.add(packed_idx) = val;\n                packed_idx += 1;\n            }\n        }\n    }\n}\n\n/// Get element from matrix considering layout and transpose.\n#[inline(always)]\nunsafe fn get_element\u003cT: Copy\u003e(\n    ptr: *const T,\n    row: usize,\n    col: usize,\n    ld: usize,\n    layout: Layout,\n    trans: Transpose,\n) -\u003e T {\n    let (actual_row, actual_col) = match trans {\n        Transpose::NoTrans =\u003e (row, col),\n        Transpose::Trans =\u003e (col, row),\n    };\n\n    let idx = match layout {\n        Layout::RowMajor =\u003e actual_row * ld + actual_col,\n        Layout::ColMajor =\u003e actual_col * ld + actual_row,\n    };\n\n    *ptr.add(idx)\n}\n\n/// Calculate packed buffer size for A.\n#[inline]\npub fn packed_a_size(m: usize, k: usize, mr: usize) -\u003e usize {\n    let m_padded = m.div_ceil(mr) * mr;\n    m_padded * k\n}\n\n/// Calculate packed buffer size for B.\n#[inline]\npub fn packed_b_size(k: usize, n: usize, nr: usize) -\u003e usize {\n    let n_padded = n.div_ceil(nr) * nr;\n    k * n_padded\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_pack_a_row_major() {\n        let a: [f64; 6] = [\n            1.0, 2.0, 3.0, // row 0\n            4.0, 5.0, 6.0, // row 1\n        ];\n        let m = 2;\n        let k = 3;\n        let mr = 4;\n        let lda = 3;\n\n        let mut packed = vec![0.0f64; packed_a_size(m, k, mr)];\n\n        unsafe {\n            pack_a(\n                m,\n                k,\n                a.as_ptr(),\n                lda,\n                Layout::RowMajor,\n                Transpose::NoTrans,\n                packed.as_mut_ptr(),\n                mr,\n            );\n        }\n\n        // Expected: column 0: [1,4,0,0], column 1: [2,5,0,0], column 2: [3,6,0,0]\n        assert_eq!(packed[0], 1.0); // a[0,0]\n        assert_eq!(packed[1], 4.0); // a[1,0]\n        assert_eq!(packed[2], 0.0); // padding\n        assert_eq!(packed[3], 0.0); // padding\n        assert_eq!(packed[4], 2.0); // a[0,1]\n        assert_eq!(packed[5], 5.0); // a[1,1]\n    }\n\n    #[test]\n    fn test_pack_a_col_major() {\n        // Column-major: columns are stored contiguously\n        // Matrix: [[1, 2, 3], [4, 5, 6]]\n        // Col-major storage: [1, 4, 2, 5, 3, 6]\n        let a: [f64; 6] = [1.0, 4.0, 2.0, 5.0, 3.0, 6.0];\n        let m = 2;\n        let k = 3;\n        let mr = 4;\n        let lda = 2; // Leading dimension for col-major\n\n        let mut packed = vec![0.0f64; packed_a_size(m, k, mr)];\n\n        unsafe {\n            pack_a(\n                m,\n                k,\n                a.as_ptr(),\n                lda,\n                Layout::ColMajor,\n                Transpose::NoTrans,\n                packed.as_mut_ptr(),\n                mr,\n            );\n        }\n\n        // Same result as row-major since we're extracting the same logical matrix\n        assert_eq!(packed[0], 1.0); // a[0,0]\n        assert_eq!(packed[1], 4.0); // a[1,0]\n        assert_eq!(packed[4], 2.0); // a[0,1]\n        assert_eq!(packed[5], 5.0); // a[1,1]\n    }\n\n    #[test]\n    fn test_pack_b_row_major() {\n        let b: [f64; 6] = [\n            1.0, 2.0, // row 0\n            3.0, 4.0, // row 1\n            5.0, 6.0, // row 2\n        ];\n        let k = 3;\n        let n = 2;\n        let nr = 4;\n        let ldb = 2;\n\n        let mut packed = vec![0.0f64; packed_b_size(k, n, nr)];\n\n        unsafe {\n            pack_b(\n                k,\n                n,\n                b.as_ptr(),\n                ldb,\n                Layout::RowMajor,\n                Transpose::NoTrans,\n                packed.as_mut_ptr(),\n                nr,\n            );\n        }\n\n        // Expected: row 0: [1,2,0,0], row 1: [3,4,0,0], row 2: [5,6,0,0]\n        assert_eq!(packed[0], 1.0); // b[0,0]\n        assert_eq!(packed[1], 2.0); // b[0,1]\n        assert_eq!(packed[2], 0.0); // padding\n        assert_eq!(packed[3], 0.0); // padding\n        assert_eq!(packed[4], 3.0); // b[1,0]\n        assert_eq!(packed[5], 4.0); // b[1,1]\n    }\n\n    #[test]\n    fn test_pack_b_col_major() {\n        // Column-major: columns are stored contiguously\n        // Matrix B (k=3, n=2): [[1, 2], [3, 4], [5, 6]]\n        // Col-major storage: [1, 3, 5, 2, 4, 6]\n        let b: [f64; 6] = [1.0, 3.0, 5.0, 2.0, 4.0, 6.0];\n        let k = 3;\n        let n = 2;\n        let nr = 4;\n        let ldb = 3; // Leading dimension for col-major (number of rows)\n\n        let mut packed = vec![0.0f64; packed_b_size(k, n, nr)];\n\n        unsafe {\n            pack_b(\n                k,\n                n,\n                b.as_ptr(),\n                ldb,\n                Layout::ColMajor,\n                Transpose::NoTrans,\n                packed.as_mut_ptr(),\n                nr,\n            );\n        }\n\n        // Expected: same logical values as row-major\n        assert_eq!(packed[0], 1.0); // b[0,0]\n        assert_eq!(packed[1], 2.0); // b[0,1]\n        assert_eq!(packed[4], 3.0); // b[1,0]\n        assert_eq!(packed[5], 4.0); // b[1,1]\n    }\n\n    #[test]\n    fn test_pack_a_with_transpose() {\n        // Test packing with transpose\n        let a: [f64; 6] = [\n            1.0, 2.0, // row 0 (becomes col 0 after trans)\n            3.0, 4.0, // row 1\n            5.0, 6.0, // row 2\n        ];\n        let m = 2; // After transpose: original 2 columns become 2 rows\n        let k = 3; // After transpose: original 3 rows become 3 cols\n        let mr = 4;\n        let lda = 2;\n\n        let mut packed = vec![0.0f64; packed_a_size(m, k, mr)];\n\n        unsafe {\n            pack_a(\n                m,\n                k,\n                a.as_ptr(),\n                lda,\n                Layout::RowMajor,\n                Transpose::Trans,\n                packed.as_mut_ptr(),\n                mr,\n            );\n        }\n\n        // A^T = [[1, 3, 5], [2, 4, 6]]\n        assert_eq!(packed[0], 1.0); // a^T[0,0]\n        assert_eq!(packed[1], 2.0); // a^T[1,0]\n        assert_eq!(packed[4], 3.0); // a^T[0,1]\n        assert_eq!(packed[5], 4.0); // a^T[1,1]\n    }\n\n    #[test]\n    fn test_pack_b_with_transpose() {\n        // Test packing B with transpose\n        let b: [f64; 6] = [\n            1.0, 2.0, 3.0, // row 0\n            4.0, 5.0, 6.0, // row 1\n        ];\n        let k = 3; // After transpose: original 3 cols become 3 rows\n        let n = 2; // After transpose: original 2 rows become 2 cols\n        let nr = 4;\n        let ldb = 3;\n\n        let mut packed = vec![0.0f64; packed_b_size(k, n, nr)];\n\n        unsafe {\n            pack_b(\n                k,\n                n,\n                b.as_ptr(),\n                ldb,\n                Layout::RowMajor,\n                Transpose::Trans,\n                packed.as_mut_ptr(),\n                nr,\n            );\n        }\n\n        // B^T = [[1, 4], [2, 5], [3, 6]]\n        assert_eq!(packed[0], 1.0); // b^T[0,0]\n        assert_eq!(packed[1], 4.0); // b^T[0,1]\n        assert_eq!(packed[4], 2.0); // b^T[1,0]\n        assert_eq!(packed[5], 5.0); // b^T[1,1]\n    }\n\n    #[test]\n    fn test_pack_a_exact_mr() {\n        // Test when m is exactly divisible by mr (no remainder path)\n        let a: [f64; 12] = [\n            1.0, 2.0, 3.0, // row 0\n            4.0, 5.0, 6.0, // row 1\n            7.0, 8.0, 9.0, // row 2\n            10.0, 11.0, 12.0, // row 3\n        ];\n        let m = 4;\n        let k = 3;\n        let mr = 4;\n        let lda = 3;\n\n        let mut packed = vec![0.0f64; packed_a_size(m, k, mr)];\n\n        unsafe {\n            pack_a(\n                m,\n                k,\n                a.as_ptr(),\n                lda,\n                Layout::RowMajor,\n                Transpose::NoTrans,\n                packed.as_mut_ptr(),\n                mr,\n            );\n        }\n\n        // No padding needed\n        assert_eq!(packed[0], 1.0);\n        assert_eq!(packed[1], 4.0);\n        assert_eq!(packed[2], 7.0);\n        assert_eq!(packed[3], 10.0);\n    }\n\n    #[test]\n    fn test_pack_b_exact_nr() {\n        // Test when n is exactly divisible by nr (no remainder path)\n        let b: [f64; 12] = [\n            1.0, 2.0, 3.0, 4.0, // row 0\n            5.0, 6.0, 7.0, 8.0, // row 1\n            9.0, 10.0, 11.0, 12.0, // row 2\n        ];\n        let k = 3;\n        let n = 4;\n        let nr = 4;\n        let ldb = 4;\n\n        let mut packed = vec![0.0f64; packed_b_size(k, n, nr)];\n\n        unsafe {\n            pack_b(\n                k,\n                n,\n                b.as_ptr(),\n                ldb,\n                Layout::RowMajor,\n                Transpose::NoTrans,\n                packed.as_mut_ptr(),\n                nr,\n            );\n        }\n\n        // No padding needed\n        assert_eq!(packed[0], 1.0);\n        assert_eq!(packed[1], 2.0);\n        assert_eq!(packed[2], 3.0);\n        assert_eq!(packed[3], 4.0);\n    }\n\n    #[test]\n    fn test_packed_a_size() {\n        // Exact multiple of mr\n        assert_eq!(packed_a_size(8, 10, 4), 8 * 10);\n        // Needs padding: m=5, mr=4 -\u003e m_padded=8\n        assert_eq!(packed_a_size(5, 10, 4), 8 * 10);\n        // m=1, mr=4 -\u003e m_padded=4\n        assert_eq!(packed_a_size(1, 10, 4), 4 * 10);\n    }\n\n    #[test]\n    fn test_packed_b_size() {\n        // Exact multiple of nr\n        assert_eq!(packed_b_size(10, 8, 4), 10 * 8);\n        // Needs padding: n=5, nr=4 -\u003e n_padded=8\n        assert_eq!(packed_b_size(10, 5, 4), 10 * 8);\n        // n=1, nr=4 -\u003e n_padded=4\n        assert_eq!(packed_b_size(10, 1, 4), 10 * 4);\n    }\n\n    #[test]\n    fn test_layout_debug() {\n        assert_eq!(format!(\"{:?}\", Layout::RowMajor), \"RowMajor\");\n        assert_eq!(format!(\"{:?}\", Layout::ColMajor), \"ColMajor\");\n    }\n\n    #[test]\n    fn test_layout_clone_eq() {\n        let l1 = Layout::RowMajor;\n        let l2 = l1;\n        assert_eq!(l1, l2);\n        assert_ne!(l1, Layout::ColMajor);\n    }\n\n    #[test]\n    fn test_transpose_debug() {\n        assert_eq!(format!(\"{:?}\", Transpose::NoTrans), \"NoTrans\");\n        assert_eq!(format!(\"{:?}\", Transpose::Trans), \"Trans\");\n    }\n\n    #[test]\n    fn test_transpose_clone_eq() {\n        let t1 = Transpose::Trans;\n        let t2 = t1;\n        assert_eq!(t1, t2);\n        assert_ne!(t1, Transpose::NoTrans);\n    }\n}\n","traces":[{"line":46,"address":[],"length":0,"stats":{"Line":46}},{"line":56,"address":[],"length":0,"stats":{"Line":92}},{"line":58,"address":[],"length":0,"stats":{"Line":92}},{"line":61,"address":[],"length":0,"stats":{"Line":92}},{"line":62,"address":[],"length":0,"stats":{"Line":92}},{"line":64,"address":[],"length":0,"stats":{"Line":55}},{"line":65,"address":[],"length":0,"stats":{"Line":18}},{"line":66,"address":[],"length":0,"stats":{"Line":124}},{"line":67,"address":[],"length":0,"stats":{"Line":1291}},{"line":68,"address":[],"length":0,"stats":{"Line":1764}},{"line":69,"address":[],"length":0,"stats":{"Line":5292}},{"line":70,"address":[],"length":0,"stats":{"Line":1764}},{"line":71,"address":[],"length":0,"stats":{"Line":588}},{"line":77,"address":[],"length":0,"stats":{"Line":46}},{"line":78,"address":[],"length":0,"stats":{"Line":84}},{"line":79,"address":[],"length":0,"stats":{"Line":151}},{"line":80,"address":[],"length":0,"stats":{"Line":617}},{"line":81,"address":[],"length":0,"stats":{"Line":1016}},{"line":82,"address":[],"length":0,"stats":{"Line":1016}},{"line":83,"address":[],"length":0,"stats":{"Line":1561}},{"line":85,"address":[],"length":0,"stats":{"Line":285}},{"line":87,"address":[],"length":0,"stats":{"Line":1524}},{"line":88,"address":[],"length":0,"stats":{"Line":508}},{"line":115,"address":[],"length":0,"stats":{"Line":46}},{"line":125,"address":[],"length":0,"stats":{"Line":92}},{"line":127,"address":[],"length":0,"stats":{"Line":92}},{"line":130,"address":[],"length":0,"stats":{"Line":92}},{"line":131,"address":[],"length":0,"stats":{"Line":92}},{"line":133,"address":[],"length":0,"stats":{"Line":57}},{"line":134,"address":[],"length":0,"stats":{"Line":22}},{"line":135,"address":[],"length":0,"stats":{"Line":132}},{"line":136,"address":[],"length":0,"stats":{"Line":1345}},{"line":137,"address":[],"length":0,"stats":{"Line":1836}},{"line":138,"address":[],"length":0,"stats":{"Line":5508}},{"line":139,"address":[],"length":0,"stats":{"Line":1836}},{"line":140,"address":[],"length":0,"stats":{"Line":612}},{"line":146,"address":[],"length":0,"stats":{"Line":46}},{"line":147,"address":[],"length":0,"stats":{"Line":82}},{"line":148,"address":[],"length":0,"stats":{"Line":148}},{"line":149,"address":[],"length":0,"stats":{"Line":607}},{"line":150,"address":[],"length":0,"stats":{"Line":1000}},{"line":151,"address":[],"length":0,"stats":{"Line":1000}},{"line":152,"address":[],"length":0,"stats":{"Line":1463}},{"line":154,"address":[],"length":0,"stats":{"Line":291}},{"line":156,"address":[],"length":0,"stats":{"Line":1500}},{"line":157,"address":[],"length":0,"stats":{"Line":500}},{"line":165,"address":[],"length":0,"stats":{"Line":1632}},{"line":173,"address":[],"length":0,"stats":{"Line":4896}},{"line":174,"address":[],"length":0,"stats":{"Line":1572}},{"line":175,"address":[],"length":0,"stats":{"Line":60}},{"line":178,"address":[],"length":0,"stats":{"Line":3264}},{"line":179,"address":[],"length":0,"stats":{"Line":1620}},{"line":180,"address":[],"length":0,"stats":{"Line":12}},{"line":183,"address":[],"length":0,"stats":{"Line":3264}},{"line":188,"address":[],"length":0,"stats":{"Line":49}},{"line":189,"address":[],"length":0,"stats":{"Line":196}},{"line":190,"address":[],"length":0,"stats":{"Line":49}},{"line":195,"address":[],"length":0,"stats":{"Line":49}},{"line":196,"address":[],"length":0,"stats":{"Line":196}},{"line":197,"address":[],"length":0,"stats":{"Line":49}}],"covered":60,"coverable":60},{"path":["/","home","leo","rcode","cutropicalgemm","crates","tropical-gemm","src","core","tiling.rs"],"content":"/// Tiling parameters for BLIS-style GEMM blocking.\n///\n/// These parameters control how matrices are partitioned to fit in\n/// various levels of the cache hierarchy.\n#[derive(Debug, Clone, Copy)]\npub struct TilingParams {\n    /// Block size for M dimension (L2 cache).\n    pub mc: usize,\n    /// Block size for N dimension (L2 cache).\n    pub nc: usize,\n    /// Block size for K dimension (L1 cache).\n    pub kc: usize,\n    /// Microkernel M dimension (registers).\n    pub mr: usize,\n    /// Microkernel N dimension (registers).\n    pub nr: usize,\n}\n\nimpl TilingParams {\n    /// Default parameters for f32 with AVX2.\n    pub const F32_AVX2: Self = Self {\n        mc: 256,\n        nc: 256,\n        kc: 512,\n        mr: 8,\n        nr: 8,\n    };\n\n    /// Default parameters for f64 with AVX2.\n    pub const F64_AVX2: Self = Self {\n        mc: 128,\n        nc: 128,\n        kc: 256,\n        mr: 4,\n        nr: 4,\n    };\n\n    /// Default parameters for portable (non-SIMD) execution.\n    pub const PORTABLE: Self = Self {\n        mc: 64,\n        nc: 64,\n        kc: 256,\n        mr: 4,\n        nr: 4,\n    };\n\n    /// Create custom tiling parameters.\n    pub const fn new(mc: usize, nc: usize, kc: usize, mr: usize, nr: usize) -\u003e Self {\n        Self { mc, nc, kc, mr, nr }\n    }\n\n    /// Validate that tiling parameters are consistent.\n    pub fn validate(\u0026self) -\u003e Result\u003c(), \u0026'static str\u003e {\n        // Check for zero values first (before divisibility checks)\n        if self.mr == 0 || self.nr == 0 {\n            return Err(\"mr and nr must be non-zero\");\n        }\n        if self.mc == 0 || self.nc == 0 || self.kc == 0 {\n            return Err(\"mc, nc, and kc must be non-zero\");\n        }\n        // Now check divisibility\n        if !self.mc.is_multiple_of(self.mr) {\n            return Err(\"mc must be divisible by mr\");\n        }\n        if !self.nc.is_multiple_of(self.nr) {\n            return Err(\"nc must be divisible by nr\");\n        }\n        Ok(())\n    }\n}\n\nimpl Default for TilingParams {\n    fn default() -\u003e Self {\n        Self::PORTABLE\n    }\n}\n\n/// Iterator over blocks for the outer loop.\npub struct BlockIterator {\n    total: usize,\n    block_size: usize,\n    current: usize,\n}\n\nimpl BlockIterator {\n    pub fn new(total: usize, block_size: usize) -\u003e Self {\n        Self {\n            total,\n            block_size,\n            current: 0,\n        }\n    }\n}\n\nimpl Iterator for BlockIterator {\n    /// (start, length) of each block\n    type Item = (usize, usize);\n\n    fn next(\u0026mut self) -\u003e Option\u003cSelf::Item\u003e {\n        if self.current \u003e= self.total {\n            return None;\n        }\n\n        let start = self.current;\n        let len = (self.total - start).min(self.block_size);\n        self.current += len;\n\n        Some((start, len))\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_block_iterator() {\n        let iter = BlockIterator::new(10, 3);\n        let blocks: Vec\u003c_\u003e = iter.collect();\n\n        assert_eq!(blocks, vec![(0, 3), (3, 3), (6, 3), (9, 1)]);\n    }\n\n    #[test]\n    fn test_block_iterator_exact() {\n        // When total is exactly divisible by block_size\n        let iter = BlockIterator::new(9, 3);\n        let blocks: Vec\u003c_\u003e = iter.collect();\n        assert_eq!(blocks, vec![(0, 3), (3, 3), (6, 3)]);\n    }\n\n    #[test]\n    fn test_block_iterator_empty() {\n        let iter = BlockIterator::new(0, 3);\n        let blocks: Vec\u003c_\u003e = iter.collect();\n        assert!(blocks.is_empty());\n    }\n\n    #[test]\n    fn test_validate_params() {\n        assert!(TilingParams::F32_AVX2.validate().is_ok());\n        assert!(TilingParams::F64_AVX2.validate().is_ok());\n        assert!(TilingParams::PORTABLE.validate().is_ok());\n\n        let bad = TilingParams::new(100, 64, 256, 8, 8);\n        assert!(bad.validate().is_err()); // 100 % 8 != 0\n    }\n\n    #[test]\n    fn test_validate_nc_not_divisible() {\n        // nc not divisible by nr\n        let bad = TilingParams::new(64, 100, 256, 8, 8);\n        assert_eq!(bad.validate(), Err(\"nc must be divisible by nr\"));\n    }\n\n    #[test]\n    fn test_validate_mr_zero() {\n        let bad = TilingParams::new(64, 64, 256, 0, 8);\n        assert_eq!(bad.validate(), Err(\"mr and nr must be non-zero\"));\n    }\n\n    #[test]\n    fn test_validate_nr_zero() {\n        let bad = TilingParams::new(64, 64, 256, 8, 0);\n        assert_eq!(bad.validate(), Err(\"mr and nr must be non-zero\"));\n    }\n\n    #[test]\n    fn test_validate_mc_zero() {\n        let bad = TilingParams::new(0, 64, 256, 8, 8);\n        assert_eq!(bad.validate(), Err(\"mc, nc, and kc must be non-zero\"));\n    }\n\n    #[test]\n    fn test_validate_nc_zero() {\n        let bad = TilingParams::new(64, 0, 256, 8, 8);\n        assert_eq!(bad.validate(), Err(\"mc, nc, and kc must be non-zero\"));\n    }\n\n    #[test]\n    fn test_validate_kc_zero() {\n        let bad = TilingParams::new(64, 64, 0, 8, 8);\n        assert_eq!(bad.validate(), Err(\"mc, nc, and kc must be non-zero\"));\n    }\n\n    #[test]\n    fn test_default() {\n        let default = TilingParams::default();\n        assert_eq!(default.mc, TilingParams::PORTABLE.mc);\n        assert_eq!(default.nc, TilingParams::PORTABLE.nc);\n        assert_eq!(default.kc, TilingParams::PORTABLE.kc);\n        assert_eq!(default.mr, TilingParams::PORTABLE.mr);\n        assert_eq!(default.nr, TilingParams::PORTABLE.nr);\n    }\n\n    #[test]\n    fn test_debug() {\n        let params = TilingParams::PORTABLE;\n        let debug_str = format!(\"{:?}\", params);\n        assert!(debug_str.contains(\"TilingParams\"));\n    }\n\n    #[test]\n    fn test_clone() {\n        let params = TilingParams::F32_AVX2;\n        let cloned = params;\n        assert_eq!(params.mc, cloned.mc);\n    }\n}\n","traces":[{"line":48,"address":[],"length":0,"stats":{"Line":7}},{"line":53,"address":[],"length":0,"stats":{"Line":10}},{"line":55,"address":[],"length":0,"stats":{"Line":19}},{"line":56,"address":[],"length":0,"stats":{"Line":2}},{"line":58,"address":[],"length":0,"stats":{"Line":21}},{"line":59,"address":[],"length":0,"stats":{"Line":3}},{"line":62,"address":[],"length":0,"stats":{"Line":10}},{"line":63,"address":[],"length":0,"stats":{"Line":1}},{"line":65,"address":[],"length":0,"stats":{"Line":8}},{"line":66,"address":[],"length":0,"stats":{"Line":1}},{"line":68,"address":[],"length":0,"stats":{"Line":3}},{"line":73,"address":[],"length":0,"stats":{"Line":1}},{"line":74,"address":[],"length":0,"stats":{"Line":1}},{"line":86,"address":[],"length":0,"stats":{"Line":129}},{"line":99,"address":[],"length":0,"stats":{"Line":262}},{"line":100,"address":[],"length":0,"stats":{"Line":262}},{"line":101,"address":[],"length":0,"stats":{"Line":129}},{"line":104,"address":[],"length":0,"stats":{"Line":266}},{"line":105,"address":[],"length":0,"stats":{"Line":532}},{"line":106,"address":[],"length":0,"stats":{"Line":133}},{"line":108,"address":[],"length":0,"stats":{"Line":133}}],"covered":21,"coverable":21},{"path":["/","home","leo","rcode","cutropicalgemm","crates","tropical-gemm","src","lib.rs"],"content":"//! High-performance tropical matrix multiplication.\n//!\n//! This library provides BLAS-level performance for tropical matrix\n//! multiplication across multiple semiring types.\n//!\n//! # GPU Acceleration\n//!\n//! For GPU-accelerated operations, add the `tropical-gemm-cuda` crate:\n//!\n//! ```toml\n//! [dependencies]\n//! tropical-gemm = \"0.1\"\n//! tropical-gemm-cuda = \"0.1\"\n//! ```\n//!\n//! Then use the GPU API:\n//!\n//! ```ignore\n//! use tropical_gemm::TropicalMaxPlus;\n//! use tropical_gemm_cuda::{tropical_matmul_gpu, CudaContext};\n//!\n//! let c = tropical_matmul_gpu::\u003cTropicalMaxPlus\u003cf32\u003e\u003e(\u0026a, m, k, \u0026b, n)?;\n//! ```\n//!\n//! # Tropical Semirings\n//!\n//! Tropical algebra replaces standard arithmetic operations:\n//! - Standard addition → tropical addition (typically max or min)\n//! - Standard multiplication → tropical multiplication (typically + or ×)\n//!\n//! | Type | ⊕ (add) | ⊗ (mul) | Zero | One | Use Case |\n//! |------|---------|---------|------|-----|----------|\n//! | [`TropicalMaxPlus\u003cT\u003e`] | max | + | -∞ | 0 | Viterbi, longest path |\n//! | [`TropicalMinPlus\u003cT\u003e`] | min | + | +∞ | 0 | Shortest path |\n//! | [`TropicalMaxMul\u003cT\u003e`] | max | × | 0 | 1 | Probability (non-log) |\n//! | [`TropicalAndOr`] | OR | AND | false | true | Graph reachability |\n//! | [`CountingTropical\u003cT,C\u003e`] | max+count | +,× | (-∞,0) | (0,1) | Path counting |\n//!\n//! # Quick Start\n//!\n//! ## Function-based API\n//!\n//! ```\n//! use tropical_gemm::{tropical_matmul, TropicalMaxPlus, TropicalSemiring};\n//!\n//! // Create 2x3 and 3x2 matrices\n//! let a = vec![1.0f32, 2.0, 3.0, 4.0, 5.0, 6.0];\n//! let b = vec![1.0f32, 2.0, 3.0, 4.0, 5.0, 6.0];\n//!\n//! // Compute C = A ⊗ B using TropicalMaxPlus semiring\n//! let c = tropical_matmul::\u003cTropicalMaxPlus\u003cf32\u003e\u003e(\u0026a, 2, 3, \u0026b, 2);\n//!\n//! // C[i,j] = max_k(A[i,k] + B[k,j])\n//! assert_eq!(c[0].value(), 8.0); // max(1+1, 2+3, 3+5) = 8\n//! ```\n//!\n//! ## Matrix-based API (faer-style)\n//!\n//! ```\n//! use tropical_gemm::{Mat, MatRef, MaxPlus, TropicalSemiring};\n//!\n//! // Create matrix views from raw data\n//! let a_data = [1.0f32, 2.0, 3.0, 4.0, 5.0, 6.0];\n//! let b_data = [1.0f32, 2.0, 3.0, 4.0, 5.0, 6.0];\n//!\n//! let a = MatRef::\u003cMaxPlus\u003cf32\u003e\u003e::from_slice(\u0026a_data, 2, 3);\n//! let b = MatRef::\u003cMaxPlus\u003cf32\u003e\u003e::from_slice(\u0026b_data, 3, 2);\n//!\n//! // Matrix multiplication using operators\n//! let c = \u0026a * \u0026b;\n//! assert_eq!(c[(0, 0)].value(), 8.0);\n//!\n//! // Or using methods\n//! let c = a.matmul(\u0026b);\n//!\n//! // Factory methods\n//! let zeros = Mat::\u003cMaxPlus\u003cf32\u003e\u003e::zeros(3, 3);\n//! let identity = Mat::\u003cMaxPlus\u003cf32\u003e\u003e::identity(3);\n//! ```\n//!\n//! # Argmax Tracking (Backpropagation)\n//!\n//! For gradient routing in neural networks, you can track which k index\n//! produced each optimal value:\n//!\n//! ```\n//! use tropical_gemm::{tropical_matmul_with_argmax, TropicalMaxPlus, TropicalSemiring};\n//!\n//! let a = vec![1.0f64, 2.0, 3.0, 4.0, 5.0, 6.0];\n//! let b = vec![1.0f64, 2.0, 3.0, 4.0, 5.0, 6.0];\n//!\n//! let result = tropical_matmul_with_argmax::\u003cTropicalMaxPlus\u003cf64\u003e\u003e(\u0026a, 2, 3, \u0026b, 2);\n//!\n//! // Get the optimal value and which k produced it\n//! let value = result.get(0, 0).value(); // 8.0\n//! let k_idx = result.get_argmax(0, 0);  // 2 (k=2 gave max)\n//! ```\n//!\n//! # Performance\n//!\n//! The library uses:\n//! - BLIS-style cache blocking for memory efficiency\n//! - Runtime CPU feature detection for optimal SIMD kernels\n//! - AVX2/AVX-512 on x86-64, NEON on ARM\n//!\n//! ```\n//! use tropical_gemm::Backend;\n//!\n//! println!(\"Using: {}\", Backend::description());\n//! ```\n//!\n//! # BLAS-style API\n//!\n//! For fine-grained control:\n//!\n//! ```\n//! use tropical_gemm::{TropicalGemm, TropicalMaxPlus, TropicalSemiring};\n//!\n//! let a = vec![1.0f32; 64 * 64];\n//! let b = vec![1.0f32; 64 * 64];\n//! let mut c = vec![TropicalMaxPlus::tropical_zero(); 64 * 64];\n//!\n//! TropicalGemm::\u003cTropicalMaxPlus\u003cf32\u003e\u003e::new(64, 64, 64)\n//!     .execute(\u0026a, 64, \u0026b, 64, \u0026mut c, 64);\n//! ```\n\n// Internal modules\npub mod core;\npub mod mat;\npub mod simd;\npub mod types;\n\nmod api;\nmod backend;\n\n// Public API\npub use api::{tropical_gemm, tropical_matmul, tropical_matmul_with_argmax, TropicalGemm};\npub use backend::{version_info, Backend};\n\n// Re-export commonly used types at crate root\npub use core::{GemmWithArgmax, Layout, Transpose};\npub use mat::{Mat, MatMut, MatRef, MatWithArgmax};\npub use simd::{simd_level, KernelDispatch, SimdLevel};\npub use types::{\n    CountingTropical, SimdTropical, TropicalAndOr, TropicalMaxMul, TropicalMaxPlus,\n    TropicalMinPlus, TropicalScalar, TropicalSemiring, TropicalWithArgmax,\n};\n\n// Convenient type aliases\n/// Alias for [`TropicalMaxPlus`].\npub type MaxPlus\u003cT\u003e = TropicalMaxPlus\u003cT\u003e;\n/// Alias for [`TropicalMinPlus`].\npub type MinPlus\u003cT\u003e = TropicalMinPlus\u003cT\u003e;\n/// Alias for [`TropicalMaxMul`].\npub type MaxMul\u003cT\u003e = TropicalMaxMul\u003cT\u003e;\n/// Alias for [`TropicalAndOr`].\npub type AndOr = TropicalAndOr;\n\n/// Prelude module for convenient imports.\npub mod prelude {\n    pub use super::{\n        tropical_matmul, tropical_matmul_with_argmax, AndOr, Backend, CountingTropical,\n        GemmWithArgmax, Mat, MatMut, MatRef, MatWithArgmax, MaxMul, MaxPlus, MinPlus, Transpose,\n        TropicalAndOr, TropicalGemm, TropicalMaxMul, TropicalMaxPlus, TropicalMinPlus,\n        TropicalSemiring, TropicalWithArgmax,\n    };\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","leo","rcode","cutropicalgemm","crates","tropical-gemm","src","simd","kernels","avx2.rs"],"content":"use crate::core::Microkernel;\nuse crate::types::{TropicalMaxMul, TropicalMaxPlus, TropicalMinPlus};\nuse wide::{f32x8, f64x4};\n\n/// AVX2 microkernel for TropicalMaxPlus\u003cf32\u003e.\n///\n/// Uses 8x8 register blocking with f32x8 vectors.\n/// Total: 8 accumulators × 8 lanes = 64 elements in registers.\n#[derive(Default, Clone, Copy)]\npub struct Avx2MaxPlusF32Kernel;\n\nimpl Microkernel\u003cTropicalMaxPlus\u003cf32\u003e\u003e for Avx2MaxPlusF32Kernel {\n    const MR: usize = 8;\n    const NR: usize = 8;\n\n    #[target_feature(enable = \"avx2\")]\n    unsafe fn execute(\n        \u0026self,\n        mr: usize,\n        nr: usize,\n        k: usize,\n        a: *const f32,\n        b: *const f32,\n        c: *mut TropicalMaxPlus\u003cf32\u003e,\n        ldc: usize,\n    ) {\n        // Initialize accumulators with -inf\n        let neg_inf = f32x8::splat(f32::NEG_INFINITY);\n        let mut acc = [neg_inf; 8];\n\n        // Load existing C values into accumulators\n        for i in 0..mr {\n            let mut row_acc = [f32::NEG_INFINITY; 8];\n            for j in 0..nr {\n                row_acc[j] = (*c.add(i * ldc + j)).0;\n            }\n            acc[i] = f32x8::from(row_acc);\n        }\n\n        // Main computation loop\n        for p in 0..k {\n            // Load A column (mr elements, padded to 8)\n            let mut a_vals = [0.0f32; 8];\n            for i in 0..mr {\n                a_vals[i] = *a.add(p * Self::MR + i);\n            }\n\n            // Load B row (nr elements, padded to 8)\n            let mut b_vals = [0.0f32; 8];\n            for j in 0..nr {\n                b_vals[j] = *b.add(p * Self::NR + j);\n            }\n            let b_vec = f32x8::from(b_vals);\n\n            // For each row of A\n            for i in 0..mr {\n                // Tropical mul: a[i] + b[j] for all j\n                let a_broadcast = f32x8::splat(a_vals[i]);\n                let product = a_broadcast + b_vec;\n\n                // Tropical add: max(acc, product)\n                acc[i] = acc[i].max(product);\n            }\n        }\n\n        // Write back results\n        for i in 0..mr {\n            let row: [f32; 8] = acc[i].into();\n            for j in 0..nr {\n                *c.add(i * ldc + j) = TropicalMaxPlus(row[j]);\n            }\n        }\n    }\n}\n\n/// AVX2 microkernel for TropicalMaxPlus\u003cf64\u003e.\n#[derive(Default, Clone, Copy)]\npub struct Avx2MaxPlusF64Kernel;\n\nimpl Microkernel\u003cTropicalMaxPlus\u003cf64\u003e\u003e for Avx2MaxPlusF64Kernel {\n    const MR: usize = 4;\n    const NR: usize = 4;\n\n    #[target_feature(enable = \"avx2\")]\n    unsafe fn execute(\n        \u0026self,\n        mr: usize,\n        nr: usize,\n        k: usize,\n        a: *const f64,\n        b: *const f64,\n        c: *mut TropicalMaxPlus\u003cf64\u003e,\n        ldc: usize,\n    ) {\n        let neg_inf = f64x4::splat(f64::NEG_INFINITY);\n        let mut acc = [neg_inf; 4];\n\n        // Load existing C\n        for i in 0..mr {\n            let mut row_acc = [f64::NEG_INFINITY; 4];\n            for j in 0..nr {\n                row_acc[j] = (*c.add(i * ldc + j)).0;\n            }\n            acc[i] = f64x4::from(row_acc);\n        }\n\n        // Main loop\n        for p in 0..k {\n            let mut a_vals = [0.0f64; 4];\n            for i in 0..mr {\n                a_vals[i] = *a.add(p * Self::MR + i);\n            }\n\n            let mut b_vals = [0.0f64; 4];\n            for j in 0..nr {\n                b_vals[j] = *b.add(p * Self::NR + j);\n            }\n            let b_vec = f64x4::from(b_vals);\n\n            for i in 0..mr {\n                let a_broadcast = f64x4::splat(a_vals[i]);\n                let product = a_broadcast + b_vec;\n                acc[i] = acc[i].max(product);\n            }\n        }\n\n        // Write back\n        for i in 0..mr {\n            let row: [f64; 4] = acc[i].into();\n            for j in 0..nr {\n                *c.add(i * ldc + j) = TropicalMaxPlus(row[j]);\n            }\n        }\n    }\n}\n\n/// AVX2 microkernel for TropicalMinPlus\u003cf32\u003e.\n#[derive(Default, Clone, Copy)]\npub struct Avx2MinPlusF32Kernel;\n\nimpl Microkernel\u003cTropicalMinPlus\u003cf32\u003e\u003e for Avx2MinPlusF32Kernel {\n    const MR: usize = 8;\n    const NR: usize = 8;\n\n    #[target_feature(enable = \"avx2\")]\n    unsafe fn execute(\n        \u0026self,\n        mr: usize,\n        nr: usize,\n        k: usize,\n        a: *const f32,\n        b: *const f32,\n        c: *mut TropicalMinPlus\u003cf32\u003e,\n        ldc: usize,\n    ) {\n        let pos_inf = f32x8::splat(f32::INFINITY);\n        let mut acc = [pos_inf; 8];\n\n        // Load existing C\n        for i in 0..mr {\n            let mut row_acc = [f32::INFINITY; 8];\n            for j in 0..nr {\n                row_acc[j] = (*c.add(i * ldc + j)).0;\n            }\n            acc[i] = f32x8::from(row_acc);\n        }\n\n        // Main loop\n        for p in 0..k {\n            let mut a_vals = [0.0f32; 8];\n            for i in 0..mr {\n                a_vals[i] = *a.add(p * Self::MR + i);\n            }\n\n            let mut b_vals = [0.0f32; 8];\n            for j in 0..nr {\n                b_vals[j] = *b.add(p * Self::NR + j);\n            }\n            let b_vec = f32x8::from(b_vals);\n\n            for i in 0..mr {\n                let a_broadcast = f32x8::splat(a_vals[i]);\n                let product = a_broadcast + b_vec;\n                // MinPlus: tropical add = min\n                acc[i] = acc[i].min(product);\n            }\n        }\n\n        // Write back\n        for i in 0..mr {\n            let row: [f32; 8] = acc[i].into();\n            for j in 0..nr {\n                *c.add(i * ldc + j) = TropicalMinPlus(row[j]);\n            }\n        }\n    }\n}\n\n/// AVX2 microkernel for TropicalMaxMul\u003cf32\u003e.\n#[derive(Default, Clone, Copy)]\npub struct Avx2MaxMulF32Kernel;\n\nimpl Microkernel\u003cTropicalMaxMul\u003cf32\u003e\u003e for Avx2MaxMulF32Kernel {\n    const MR: usize = 8;\n    const NR: usize = 8;\n\n    #[target_feature(enable = \"avx2\")]\n    unsafe fn execute(\n        \u0026self,\n        mr: usize,\n        nr: usize,\n        k: usize,\n        a: *const f32,\n        b: *const f32,\n        c: *mut TropicalMaxMul\u003cf32\u003e,\n        ldc: usize,\n    ) {\n        let zero = f32x8::splat(0.0);\n        let mut acc = [zero; 8];\n\n        // Load existing C\n        for i in 0..mr {\n            let mut row_acc = [0.0f32; 8];\n            for j in 0..nr {\n                row_acc[j] = (*c.add(i * ldc + j)).0;\n            }\n            acc[i] = f32x8::from(row_acc);\n        }\n\n        // Main loop\n        for p in 0..k {\n            let mut a_vals = [0.0f32; 8];\n            for i in 0..mr {\n                a_vals[i] = *a.add(p * Self::MR + i);\n            }\n\n            let mut b_vals = [0.0f32; 8];\n            for j in 0..nr {\n                b_vals[j] = *b.add(p * Self::NR + j);\n            }\n            let b_vec = f32x8::from(b_vals);\n\n            for i in 0..mr {\n                let a_broadcast = f32x8::splat(a_vals[i]);\n                // MaxMul: tropical mul = standard mul\n                let product = a_broadcast * b_vec;\n                // tropical add = max\n                acc[i] = acc[i].max(product);\n            }\n        }\n\n        // Write back\n        for i in 0..mr {\n            let row: [f32; 8] = acc[i].into();\n            for j in 0..nr {\n                *c.add(i * ldc + j) = TropicalMaxMul(row[j]);\n            }\n        }\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use crate::types::TropicalSemiring;\n\n    #[test]\n    #[cfg(target_arch = \"x86_64\")]\n    fn test_avx2_max_plus_f32() {\n        if !is_x86_feature_detected!(\"avx2\") {\n            println!(\"AVX2 not available, skipping test\");\n            return;\n        }\n\n        let kernel = Avx2MaxPlusF32Kernel;\n        let mr = 2;\n        let nr = 2;\n        let k = 3;\n\n        // A: 2x3 packed\n        let a: [f32; 24] = [\n            1.0, 4.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, // col 0\n            2.0, 5.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, // col 1\n            3.0, 6.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, // col 2\n        ];\n\n        // B: 3x2 packed\n        let b: [f32; 24] = [\n            1.0, 2.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, // row 0\n            3.0, 4.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, // row 1\n            5.0, 6.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, // row 2\n        ];\n\n        let mut c = vec![TropicalMaxPlus::tropical_zero(); 4];\n        let ldc = 2;\n\n        unsafe {\n            kernel.execute(mr, nr, k, a.as_ptr(), b.as_ptr(), c.as_mut_ptr(), ldc);\n        }\n\n        // C[0,0] = max(1+1, 2+3, 3+5) = 8\n        assert!((c[0].0 - 8.0).abs() \u003c 1e-6);\n        // C[0,1] = max(1+2, 2+4, 3+6) = 9\n        assert!((c[1].0 - 9.0).abs() \u003c 1e-6);\n        // C[1,0] = max(4+1, 5+3, 6+5) = 11\n        assert!((c[2].0 - 11.0).abs() \u003c 1e-6);\n        // C[1,1] = max(4+2, 5+4, 6+6) = 12\n        assert!((c[3].0 - 12.0).abs() \u003c 1e-6);\n    }\n\n    #[test]\n    #[cfg(target_arch = \"x86_64\")]\n    fn test_avx2_min_plus_f32() {\n        if !is_x86_feature_detected!(\"avx2\") {\n            println!(\"AVX2 not available, skipping test\");\n            return;\n        }\n\n        let kernel = Avx2MinPlusF32Kernel;\n        let mr = 2;\n        let nr = 2;\n        let k = 3;\n\n        // A: 2x3 packed\n        let a: [f32; 24] = [\n            1.0, 4.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 2.0, 5.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 3.0,\n            6.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0,\n        ];\n\n        // B: 3x2 packed\n        let b: [f32; 24] = [\n            1.0, 2.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 3.0, 4.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 5.0,\n            6.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0,\n        ];\n\n        let mut c = vec![TropicalMinPlus::tropical_zero(); 4];\n        let ldc = 2;\n\n        unsafe {\n            kernel.execute(mr, nr, k, a.as_ptr(), b.as_ptr(), c.as_mut_ptr(), ldc);\n        }\n\n        // C[0,0] = min(1+1, 2+3, 3+5) = 2\n        assert!((c[0].0 - 2.0).abs() \u003c 1e-6);\n        // C[0,1] = min(1+2, 2+4, 3+6) = 3\n        assert!((c[1].0 - 3.0).abs() \u003c 1e-6);\n        // C[1,0] = min(4+1, 5+3, 6+5) = 5\n        assert!((c[2].0 - 5.0).abs() \u003c 1e-6);\n        // C[1,1] = min(4+2, 5+4, 6+6) = 6\n        assert!((c[3].0 - 6.0).abs() \u003c 1e-6);\n    }\n\n    #[test]\n    #[cfg(target_arch = \"x86_64\")]\n    fn test_avx2_max_mul_f32() {\n        if !is_x86_feature_detected!(\"avx2\") {\n            println!(\"AVX2 not available, skipping test\");\n            return;\n        }\n\n        let kernel = Avx2MaxMulF32Kernel;\n        let mr = 2;\n        let nr = 2;\n        let k = 2;\n\n        // A: 2x2 packed\n        let a: [f32; 16] = [\n            2.0, 3.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 4.0, 5.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0,\n        ];\n\n        // B: 2x2 packed\n        let b: [f32; 16] = [\n            1.0, 2.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 3.0, 4.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0,\n        ];\n\n        let mut c = vec![TropicalMaxMul::tropical_zero(); 4];\n        let ldc = 2;\n\n        unsafe {\n            kernel.execute(mr, nr, k, a.as_ptr(), b.as_ptr(), c.as_mut_ptr(), ldc);\n        }\n\n        // C[0,0] = max(2*1, 4*3) = max(2, 12) = 12\n        assert!((c[0].0 - 12.0).abs() \u003c 1e-6);\n        // C[0,1] = max(2*2, 4*4) = max(4, 16) = 16\n        assert!((c[1].0 - 16.0).abs() \u003c 1e-6);\n        // C[1,0] = max(3*1, 5*3) = max(3, 15) = 15\n        assert!((c[2].0 - 15.0).abs() \u003c 1e-6);\n        // C[1,1] = max(3*2, 5*4) = max(6, 20) = 20\n        assert!((c[3].0 - 20.0).abs() \u003c 1e-6);\n    }\n\n    #[test]\n    #[cfg(target_arch = \"x86_64\")]\n    fn test_avx2_max_plus_f64() {\n        if !is_x86_feature_detected!(\"avx2\") {\n            println!(\"AVX2 not available, skipping test\");\n            return;\n        }\n\n        let kernel = Avx2MaxPlusF64Kernel;\n        let mr = 2;\n        let nr = 2;\n        let k = 2;\n\n        // A: 2x2 packed (4 f64 per column for mr=4 padding)\n        let a: [f64; 8] = [\n            1.0, 2.0, 0.0, 0.0, // col 0\n            3.0, 4.0, 0.0, 0.0, // col 1\n        ];\n\n        // B: 2x2 packed (4 f64 per row for nr=4 padding)\n        let b: [f64; 8] = [\n            1.0, 2.0, 0.0, 0.0, // row 0\n            3.0, 4.0, 0.0, 0.0, // row 1\n        ];\n\n        let mut c = vec![TropicalMaxPlus::tropical_zero(); 4];\n        let ldc = 2;\n\n        unsafe {\n            kernel.execute(mr, nr, k, a.as_ptr(), b.as_ptr(), c.as_mut_ptr(), ldc);\n        }\n\n        // C[0,0] = max(1+1, 3+3) = 6\n        assert!((c[0].0 - 6.0).abs() \u003c 1e-10);\n        // C[0,1] = max(1+2, 3+4) = 7\n        assert!((c[1].0 - 7.0).abs() \u003c 1e-10);\n        // C[1,0] = max(2+1, 4+3) = 7\n        assert!((c[2].0 - 7.0).abs() \u003c 1e-10);\n        // C[1,1] = max(2+2, 4+4) = 8\n        assert!((c[3].0 - 8.0).abs() \u003c 1e-10);\n    }\n}\n","traces":[{"line":17,"address":[],"length":0,"stats":{"Line":10}},{"line":28,"address":[],"length":0,"stats":{"Line":20}},{"line":29,"address":[],"length":0,"stats":{"Line":20}},{"line":32,"address":[],"length":0,"stats":{"Line":54}},{"line":33,"address":[],"length":0,"stats":{"Line":88}},{"line":34,"address":[],"length":0,"stats":{"Line":604}},{"line":35,"address":[],"length":0,"stats":{"Line":1120}},{"line":37,"address":[],"length":0,"stats":{"Line":88}},{"line":41,"address":[],"length":0,"stats":{"Line":91}},{"line":43,"address":[],"length":0,"stats":{"Line":162}},{"line":44,"address":[],"length":0,"stats":{"Line":1173}},{"line":45,"address":[],"length":0,"stats":{"Line":2184}},{"line":49,"address":[],"length":0,"stats":{"Line":162}},{"line":50,"address":[],"length":0,"stats":{"Line":1173}},{"line":51,"address":[],"length":0,"stats":{"Line":2184}},{"line":53,"address":[],"length":0,"stats":{"Line":243}},{"line":56,"address":[],"length":0,"stats":{"Line":1173}},{"line":58,"address":[],"length":0,"stats":{"Line":2184}},{"line":59,"address":[],"length":0,"stats":{"Line":1638}},{"line":62,"address":[],"length":0,"stats":{"Line":1638}},{"line":67,"address":[],"length":0,"stats":{"Line":54}},{"line":68,"address":[],"length":0,"stats":{"Line":176}},{"line":69,"address":[],"length":0,"stats":{"Line":604}},{"line":70,"address":[],"length":0,"stats":{"Line":840}},{"line":85,"address":[],"length":0,"stats":{"Line":23}},{"line":95,"address":[],"length":0,"stats":{"Line":46}},{"line":96,"address":[],"length":0,"stats":{"Line":46}},{"line":99,"address":[],"length":0,"stats":{"Line":101}},{"line":100,"address":[],"length":0,"stats":{"Line":156}},{"line":101,"address":[],"length":0,"stats":{"Line":656}},{"line":102,"address":[],"length":0,"stats":{"Line":1156}},{"line":104,"address":[],"length":0,"stats":{"Line":156}},{"line":108,"address":[],"length":0,"stats":{"Line":294}},{"line":109,"address":[],"length":0,"stats":{"Line":542}},{"line":110,"address":[],"length":0,"stats":{"Line":2381}},{"line":111,"address":[],"length":0,"stats":{"Line":4220}},{"line":114,"address":[],"length":0,"stats":{"Line":542}},{"line":115,"address":[],"length":0,"stats":{"Line":2385}},{"line":116,"address":[],"length":0,"stats":{"Line":4228}},{"line":118,"address":[],"length":0,"stats":{"Line":813}},{"line":120,"address":[],"length":0,"stats":{"Line":2381}},{"line":121,"address":[],"length":0,"stats":{"Line":4220}},{"line":122,"address":[],"length":0,"stats":{"Line":3165}},{"line":123,"address":[],"length":0,"stats":{"Line":3165}},{"line":128,"address":[],"length":0,"stats":{"Line":101}},{"line":129,"address":[],"length":0,"stats":{"Line":312}},{"line":130,"address":[],"length":0,"stats":{"Line":656}},{"line":131,"address":[],"length":0,"stats":{"Line":867}},{"line":146,"address":[],"length":0,"stats":{"Line":2}},{"line":156,"address":[],"length":0,"stats":{"Line":4}},{"line":157,"address":[],"length":0,"stats":{"Line":4}},{"line":160,"address":[],"length":0,"stats":{"Line":6}},{"line":161,"address":[],"length":0,"stats":{"Line":8}},{"line":162,"address":[],"length":0,"stats":{"Line":20}},{"line":163,"address":[],"length":0,"stats":{"Line":32}},{"line":165,"address":[],"length":0,"stats":{"Line":8}},{"line":169,"address":[],"length":0,"stats":{"Line":7}},{"line":170,"address":[],"length":0,"stats":{"Line":10}},{"line":171,"address":[],"length":0,"stats":{"Line":25}},{"line":172,"address":[],"length":0,"stats":{"Line":40}},{"line":175,"address":[],"length":0,"stats":{"Line":10}},{"line":176,"address":[],"length":0,"stats":{"Line":25}},{"line":177,"address":[],"length":0,"stats":{"Line":40}},{"line":179,"address":[],"length":0,"stats":{"Line":15}},{"line":181,"address":[],"length":0,"stats":{"Line":25}},{"line":182,"address":[],"length":0,"stats":{"Line":40}},{"line":183,"address":[],"length":0,"stats":{"Line":30}},{"line":185,"address":[],"length":0,"stats":{"Line":30}},{"line":190,"address":[],"length":0,"stats":{"Line":6}},{"line":191,"address":[],"length":0,"stats":{"Line":16}},{"line":192,"address":[],"length":0,"stats":{"Line":20}},{"line":193,"address":[],"length":0,"stats":{"Line":24}},{"line":208,"address":[],"length":0,"stats":{"Line":2}},{"line":218,"address":[],"length":0,"stats":{"Line":4}},{"line":219,"address":[],"length":0,"stats":{"Line":4}},{"line":222,"address":[],"length":0,"stats":{"Line":6}},{"line":223,"address":[],"length":0,"stats":{"Line":8}},{"line":224,"address":[],"length":0,"stats":{"Line":20}},{"line":225,"address":[],"length":0,"stats":{"Line":32}},{"line":227,"address":[],"length":0,"stats":{"Line":8}},{"line":231,"address":[],"length":0,"stats":{"Line":6}},{"line":232,"address":[],"length":0,"stats":{"Line":8}},{"line":233,"address":[],"length":0,"stats":{"Line":20}},{"line":234,"address":[],"length":0,"stats":{"Line":32}},{"line":237,"address":[],"length":0,"stats":{"Line":8}},{"line":238,"address":[],"length":0,"stats":{"Line":20}},{"line":239,"address":[],"length":0,"stats":{"Line":32}},{"line":241,"address":[],"length":0,"stats":{"Line":12}},{"line":243,"address":[],"length":0,"stats":{"Line":20}},{"line":244,"address":[],"length":0,"stats":{"Line":32}},{"line":246,"address":[],"length":0,"stats":{"Line":24}},{"line":248,"address":[],"length":0,"stats":{"Line":24}},{"line":253,"address":[],"length":0,"stats":{"Line":6}},{"line":254,"address":[],"length":0,"stats":{"Line":16}},{"line":255,"address":[],"length":0,"stats":{"Line":20}},{"line":256,"address":[],"length":0,"stats":{"Line":24}}],"covered":96,"coverable":96},{"path":["/","home","leo","rcode","cutropicalgemm","crates","tropical-gemm","src","simd","kernels","mod.rs"],"content":"//! SIMD microkernel implementations.\n\n#[cfg(any(target_arch = \"x86\", target_arch = \"x86_64\"))]\npub mod avx2;\n#[cfg(target_arch = \"aarch64\")]\npub mod neon;\npub mod portable;\n\n#[cfg(any(target_arch = \"x86\", target_arch = \"x86_64\"))]\npub use avx2::{\n    Avx2MaxMulF32Kernel, Avx2MaxPlusF32Kernel, Avx2MaxPlusF64Kernel, Avx2MinPlusF32Kernel,\n};\n#[cfg(target_arch = \"aarch64\")]\npub use neon::{NeonMaxPlusF32Kernel, NeonMaxPlusF64Kernel, NeonMinPlusF32Kernel};\npub use portable::PortableKernel;\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","leo","rcode","cutropicalgemm","crates","tropical-gemm","src","simd","kernels","neon.rs"],"content":"use crate::core::Microkernel;\nuse crate::types::{TropicalMaxPlus, TropicalMinPlus};\nuse wide::{f32x4, f64x2};\n\n/// ARM NEON microkernel for TropicalMaxPlus\u003cf32\u003e.\n///\n/// Uses 4x4 register blocking with f32x4 vectors.\n#[derive(Default, Clone, Copy)]\npub struct NeonMaxPlusF32Kernel;\n\nimpl Microkernel\u003cTropicalMaxPlus\u003cf32\u003e\u003e for NeonMaxPlusF32Kernel {\n    const MR: usize = 4;\n    const NR: usize = 4;\n\n    unsafe fn execute(\n        \u0026self,\n        mr: usize,\n        nr: usize,\n        k: usize,\n        a: *const f32,\n        b: *const f32,\n        c: *mut TropicalMaxPlus\u003cf32\u003e,\n        ldc: usize,\n    ) {\n        let neg_inf = f32x4::splat(f32::NEG_INFINITY);\n        let mut acc = [neg_inf; 4];\n\n        // Load existing C\n        for i in 0..mr {\n            let mut row_acc = [f32::NEG_INFINITY; 4];\n            for j in 0..nr {\n                row_acc[j] = (*c.add(i * ldc + j)).0;\n            }\n            acc[i] = f32x4::from(row_acc);\n        }\n\n        // Main loop\n        for p in 0..k {\n            let mut a_vals = [0.0f32; 4];\n            for i in 0..mr {\n                a_vals[i] = *a.add(p * Self::MR + i);\n            }\n\n            let mut b_vals = [0.0f32; 4];\n            for j in 0..nr {\n                b_vals[j] = *b.add(p * Self::NR + j);\n            }\n            let b_vec = f32x4::from(b_vals);\n\n            for i in 0..mr {\n                let a_broadcast = f32x4::splat(a_vals[i]);\n                let product = a_broadcast + b_vec;\n                acc[i] = acc[i].max(product);\n            }\n        }\n\n        // Write back\n        for i in 0..mr {\n            let row: [f32; 4] = acc[i].into();\n            for j in 0..nr {\n                *c.add(i * ldc + j) = TropicalMaxPlus(row[j]);\n            }\n        }\n    }\n}\n\n/// ARM NEON microkernel for TropicalMaxPlus\u003cf64\u003e.\n#[derive(Default, Clone, Copy)]\npub struct NeonMaxPlusF64Kernel;\n\nimpl Microkernel\u003cTropicalMaxPlus\u003cf64\u003e\u003e for NeonMaxPlusF64Kernel {\n    const MR: usize = 2;\n    const NR: usize = 2;\n\n    unsafe fn execute(\n        \u0026self,\n        mr: usize,\n        nr: usize,\n        k: usize,\n        a: *const f64,\n        b: *const f64,\n        c: *mut TropicalMaxPlus\u003cf64\u003e,\n        ldc: usize,\n    ) {\n        let neg_inf = f64x2::splat(f64::NEG_INFINITY);\n        let mut acc = [neg_inf; 2];\n\n        // Load existing C\n        for i in 0..mr {\n            let mut row_acc = [f64::NEG_INFINITY; 2];\n            for j in 0..nr {\n                row_acc[j] = (*c.add(i * ldc + j)).0;\n            }\n            acc[i] = f64x2::from(row_acc);\n        }\n\n        // Main loop\n        for p in 0..k {\n            let mut a_vals = [0.0f64; 2];\n            for i in 0..mr {\n                a_vals[i] = *a.add(p * Self::MR + i);\n            }\n\n            let mut b_vals = [0.0f64; 2];\n            for j in 0..nr {\n                b_vals[j] = *b.add(p * Self::NR + j);\n            }\n            let b_vec = f64x2::from(b_vals);\n\n            for i in 0..mr {\n                let a_broadcast = f64x2::splat(a_vals[i]);\n                let product = a_broadcast + b_vec;\n                acc[i] = acc[i].max(product);\n            }\n        }\n\n        // Write back\n        for i in 0..mr {\n            let row: [f64; 2] = acc[i].into();\n            for j in 0..nr {\n                *c.add(i * ldc + j) = TropicalMaxPlus(row[j]);\n            }\n        }\n    }\n}\n\n/// ARM NEON microkernel for TropicalMinPlus\u003cf32\u003e.\n#[derive(Default, Clone, Copy)]\npub struct NeonMinPlusF32Kernel;\n\nimpl Microkernel\u003cTropicalMinPlus\u003cf32\u003e\u003e for NeonMinPlusF32Kernel {\n    const MR: usize = 4;\n    const NR: usize = 4;\n\n    unsafe fn execute(\n        \u0026self,\n        mr: usize,\n        nr: usize,\n        k: usize,\n        a: *const f32,\n        b: *const f32,\n        c: *mut TropicalMinPlus\u003cf32\u003e,\n        ldc: usize,\n    ) {\n        let pos_inf = f32x4::splat(f32::INFINITY);\n        let mut acc = [pos_inf; 4];\n\n        for i in 0..mr {\n            let mut row_acc = [f32::INFINITY; 4];\n            for j in 0..nr {\n                row_acc[j] = (*c.add(i * ldc + j)).0;\n            }\n            acc[i] = f32x4::from(row_acc);\n        }\n\n        for p in 0..k {\n            let mut a_vals = [0.0f32; 4];\n            for i in 0..mr {\n                a_vals[i] = *a.add(p * Self::MR + i);\n            }\n\n            let mut b_vals = [0.0f32; 4];\n            for j in 0..nr {\n                b_vals[j] = *b.add(p * Self::NR + j);\n            }\n            let b_vec = f32x4::from(b_vals);\n\n            for i in 0..mr {\n                let a_broadcast = f32x4::splat(a_vals[i]);\n                let product = a_broadcast + b_vec;\n                acc[i] = acc[i].min(product);\n            }\n        }\n\n        for i in 0..mr {\n            let row: [f32; 4] = acc[i].into();\n            for j in 0..nr {\n                *c.add(i * ldc + j) = TropicalMinPlus(row[j]);\n            }\n        }\n    }\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","leo","rcode","cutropicalgemm","crates","tropical-gemm","src","simd","kernels","portable.rs"],"content":"use crate::core::{Microkernel, MicrokernelWithArgmax};\nuse crate::types::{TropicalSemiring, TropicalWithArgmax};\n\n/// Portable (non-SIMD) microkernel using the `wide` crate.\n///\n/// This provides a fallback when no SIMD instructions are available,\n/// but uses `wide` types which may still auto-vectorize.\n#[derive(Default, Clone, Copy)]\npub struct PortableKernel;\n\nimpl\u003cT: TropicalSemiring\u003e Microkernel\u003cT\u003e for PortableKernel {\n    const MR: usize = 4;\n    const NR: usize = 4;\n\n    unsafe fn execute(\n        \u0026self,\n        mr: usize,\n        nr: usize,\n        k: usize,\n        a: *const T::Scalar,\n        b: *const T::Scalar,\n        c: *mut T,\n        ldc: usize,\n    ) {\n        // Delegate to the core portable implementation\n        let core_kernel = crate::core::PortableMicrokernel;\n        core_kernel.execute(mr, nr, k, a, b, c, ldc);\n    }\n}\n\nimpl\u003cT: TropicalWithArgmax\u003cIndex = u32\u003e\u003e MicrokernelWithArgmax\u003cT\u003e for PortableKernel {\n    unsafe fn execute_with_argmax(\n        \u0026self,\n        mr: usize,\n        nr: usize,\n        k: usize,\n        k_offset: usize,\n        a: *const T::Scalar,\n        b: *const T::Scalar,\n        c: *mut T,\n        argmax: *mut u32,\n        ldc: usize,\n    ) {\n        let core_kernel = crate::core::PortableMicrokernel;\n        core_kernel.execute_with_argmax(mr, nr, k, k_offset, a, b, c, argmax, ldc);\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use crate::types::TropicalMaxPlus;\n\n    #[test]\n    fn test_portable_kernel_execute() {\n        let kernel = PortableKernel;\n        let mr = 2;\n        let nr = 2;\n        let k = 2;\n\n        let a: [f64; 8] = [1.0, 2.0, 0.0, 0.0, 3.0, 4.0, 0.0, 0.0];\n        let b: [f64; 8] = [1.0, 2.0, 0.0, 0.0, 3.0, 4.0, 0.0, 0.0];\n        let mut c = [TropicalMaxPlus::tropical_zero(); 4];\n        let ldc = 2;\n\n        unsafe {\n            kernel.execute(mr, nr, k, a.as_ptr(), b.as_ptr(), c.as_mut_ptr(), ldc);\n        }\n\n        // C[0,0] = max(1+1, 3+3) = 6\n        assert_eq!(c[0].0, 6.0);\n    }\n\n    #[test]\n    fn test_portable_kernel_execute_with_argmax() {\n        let kernel = PortableKernel;\n        let mr = 2;\n        let nr = 2;\n        let k = 2;\n\n        let a: [f64; 8] = [1.0, 2.0, 0.0, 0.0, 10.0, 20.0, 0.0, 0.0];\n        let b: [f64; 8] = [1.0, 1.0, 0.0, 0.0, 1.0, 1.0, 0.0, 0.0];\n        let mut c = [TropicalMaxPlus::tropical_zero(); 4];\n        let mut argmax = [0u32; 4];\n        let ldc = 2;\n        let k_offset = 0;\n\n        unsafe {\n            kernel.execute_with_argmax(\n                mr,\n                nr,\n                k,\n                k_offset,\n                a.as_ptr(),\n                b.as_ptr(),\n                c.as_mut_ptr(),\n                argmax.as_mut_ptr(),\n                ldc,\n            );\n        }\n\n        // C[0,0] = max(1+1, 10+1) = 11 at k=1\n        assert_eq!(c[0].0, 11.0);\n        assert_eq!(argmax[0], 1);\n    }\n\n    #[test]\n    fn test_portable_kernel_default() {\n        let kernel = PortableKernel::default();\n        // Just verify it can be created and constants are accessible\n        assert_eq!(\u003cPortableKernel as Microkernel\u003cTropicalMaxPlus\u003cf64\u003e\u003e\u003e::MR, 4);\n        assert_eq!(\u003cPortableKernel as Microkernel\u003cTropicalMaxPlus\u003cf64\u003e\u003e\u003e::NR, 4);\n        let _ = kernel;\n    }\n}\n","traces":[{"line":15,"address":[],"length":0,"stats":{"Line":14}},{"line":26,"address":[],"length":0,"stats":{"Line":28}},{"line":27,"address":[],"length":0,"stats":{"Line":126}},{"line":32,"address":[],"length":0,"stats":{"Line":1}},{"line":44,"address":[],"length":0,"stats":{"Line":2}},{"line":45,"address":[],"length":0,"stats":{"Line":11}}],"covered":6,"coverable":6},{"path":["/","home","leo","rcode","cutropicalgemm","crates","tropical-gemm","src","simd","mod.rs"],"content":"//! SIMD-optimized microkernels for tropical GEMM.\n//!\n//! This module provides architecture-specific SIMD implementations\n//! of the microkernel for tropical matrix multiplication.\n\nmod detect;\npub mod dispatch;\npub mod kernels;\n\npub use detect::{simd_level, SimdLevel};\npub use dispatch::{tropical_gemm_dispatch, KernelDispatch};\npub use kernels::*;\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","leo","rcode","cutropicalgemm","crates","tropical-gemm","src","types","and_or.rs"],"content":"use super::traits::{SimdTropical, TropicalSemiring, TropicalWithArgmax};\nuse std::fmt;\nuse std::ops::{Add, Mul};\n\n/// TropicalAndOr semiring: ({true, false}, OR, AND)\n///\n/// - Addition (⊕) = OR (logical disjunction)\n/// - Multiplication (⊗) = AND (logical conjunction)\n/// - Zero = false\n/// - One = true\n///\n/// This is used for:\n/// - Boolean matrix multiplication (transitive closure)\n/// - Graph reachability\n/// - SAT-related computations\n#[derive(Copy, Clone, PartialEq, Eq)]\n#[repr(transparent)]\npub struct TropicalAndOr(pub bool);\n\nimpl TropicalAndOr {\n    /// Create a new TropicalAndOr value.\n    #[inline(always)]\n    pub fn new(value: bool) -\u003e Self {\n        Self(value)\n    }\n}\n\nimpl TropicalSemiring for TropicalAndOr {\n    type Scalar = bool;\n\n    #[inline(always)]\n    fn tropical_zero() -\u003e Self {\n        Self(false)\n    }\n\n    #[inline(always)]\n    fn tropical_one() -\u003e Self {\n        Self(true)\n    }\n\n    #[inline(always)]\n    fn tropical_add(self, rhs: Self) -\u003e Self {\n        Self(self.0 || rhs.0)\n    }\n\n    #[inline(always)]\n    fn tropical_mul(self, rhs: Self) -\u003e Self {\n        Self(self.0 \u0026\u0026 rhs.0)\n    }\n\n    #[inline(always)]\n    fn value(\u0026self) -\u003e bool {\n        self.0\n    }\n\n    #[inline(always)]\n    fn from_scalar(s: bool) -\u003e Self {\n        Self(s)\n    }\n}\n\nimpl TropicalWithArgmax for TropicalAndOr {\n    type Index = u32;\n\n    #[inline(always)]\n    fn tropical_add_argmax(self, self_idx: u32, rhs: Self, rhs_idx: u32) -\u003e (Self, u32) {\n        // For OR, return index of first true (or last if both false)\n        if self.0 {\n            (self, self_idx)\n        } else if rhs.0 {\n            (rhs, rhs_idx)\n        } else {\n            (self, self_idx)\n        }\n    }\n}\n\nimpl SimdTropical for TropicalAndOr {\n    // Bool operations can be SIMD'd via bitmasks\n    const SIMD_AVAILABLE: bool = true;\n    const SIMD_WIDTH: usize = 256; // 256 bits = 256 bools for AVX2\n}\n\nimpl Add for TropicalAndOr {\n    type Output = Self;\n\n    #[inline(always)]\n    fn add(self, rhs: Self) -\u003e Self::Output {\n        self.tropical_add(rhs)\n    }\n}\n\nimpl Mul for TropicalAndOr {\n    type Output = Self;\n\n    #[inline(always)]\n    fn mul(self, rhs: Self) -\u003e Self::Output {\n        self.tropical_mul(rhs)\n    }\n}\n\nimpl Default for TropicalAndOr {\n    #[inline(always)]\n    fn default() -\u003e Self {\n        Self::tropical_zero()\n    }\n}\n\nimpl fmt::Debug for TropicalAndOr {\n    fn fmt(\u0026self, f: \u0026mut fmt::Formatter\u003c'_\u003e) -\u003e fmt::Result {\n        write!(f, \"TropicalAndOr({})\", self.0)\n    }\n}\n\nimpl fmt::Display for TropicalAndOr {\n    fn fmt(\u0026self, f: \u0026mut fmt::Formatter\u003c'_\u003e) -\u003e fmt::Result {\n        write!(f, \"{}\", self.0)\n    }\n}\n\nimpl From\u003cbool\u003e for TropicalAndOr {\n    #[inline(always)]\n    fn from(value: bool) -\u003e Self {\n        Self(value)\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_semiring_identity() {\n        let a = TropicalAndOr::new(true);\n        let zero = TropicalAndOr::tropical_zero();\n        let one = TropicalAndOr::tropical_one();\n\n        // a ⊕ 0 = a\n        assert_eq!(a.tropical_add(zero), a);\n        // a ⊗ 1 = a\n        assert_eq!(a.tropical_mul(one), a);\n\n        // Test with false value too\n        let f = TropicalAndOr::new(false);\n        assert_eq!(f.tropical_add(zero), f);\n        assert_eq!(f.tropical_mul(one), f);\n    }\n\n    #[test]\n    fn test_operations() {\n        let t = TropicalAndOr::new(true);\n        let f = TropicalAndOr::new(false);\n\n        // OR operations\n        assert!(t.tropical_add(f).0);\n        assert!(!f.tropical_add(f).0);\n        assert!(t.tropical_add(t).0);\n\n        // AND operations\n        assert!(!t.tropical_mul(f).0);\n        assert!(t.tropical_mul(t).0);\n        assert!(!f.tropical_mul(f).0);\n    }\n\n    #[test]\n    fn test_absorbing_zero() {\n        let a = TropicalAndOr::new(true);\n        let zero = TropicalAndOr::tropical_zero();\n\n        // a ⊗ 0 = 0\n        assert_eq!(a.tropical_mul(zero), zero);\n    }\n\n    #[test]\n    fn test_reachability_example() {\n        // Graph adjacency: can we reach node j from node i?\n        // A[0,1] = true (0-\u003e1), A[1,2] = true (1-\u003e2)\n        // (A*A)[0,2] = A[0,0]*A[0,2] OR A[0,1]*A[1,2] = false OR true = true\n        let a01 = TropicalAndOr::new(true);\n        let a12 = TropicalAndOr::new(true);\n        let a00 = TropicalAndOr::new(false);\n        let a02 = TropicalAndOr::new(false);\n\n        let result = a00.tropical_mul(a02).tropical_add(a01.tropical_mul(a12));\n        assert!(result.0);\n    }\n\n    #[test]\n    fn test_operator_overloads() {\n        let t = TropicalAndOr::new(true);\n        let f = TropicalAndOr::new(false);\n\n        // Add operator (OR)\n        assert!((t + f).0);\n        assert!((f + t).0);\n        assert!(!(f + f).0);\n        assert!((t + t).0);\n\n        // Mul operator (AND)\n        assert!(!(t * f).0);\n        assert!(!(f * t).0);\n        assert!(!(f * f).0);\n        assert!((t * t).0);\n    }\n\n    #[test]\n    fn test_default() {\n        let d = TropicalAndOr::default();\n        assert!(!d.0); // Default is zero (false)\n        assert_eq!(d, TropicalAndOr::tropical_zero());\n    }\n\n    #[test]\n    fn test_display_debug() {\n        let t = TropicalAndOr::new(true);\n        let f = TropicalAndOr::new(false);\n\n        assert_eq!(format!(\"{}\", t), \"true\");\n        assert_eq!(format!(\"{}\", f), \"false\");\n        assert_eq!(format!(\"{:?}\", t), \"TropicalAndOr(true)\");\n        assert_eq!(format!(\"{:?}\", f), \"TropicalAndOr(false)\");\n    }\n\n    #[test]\n    fn test_from() {\n        let t: TropicalAndOr = true.into();\n        let f: TropicalAndOr = false.into();\n\n        assert!(t.0);\n        assert!(!f.0);\n\n        // Using From trait directly\n        let t2 = TropicalAndOr::from(true);\n        let f2 = TropicalAndOr::from(false);\n        assert!(t2.0);\n        assert!(!f2.0);\n    }\n\n    #[test]\n    fn test_value_and_from_scalar() {\n        let t = TropicalAndOr::new(true);\n        let f = TropicalAndOr::new(false);\n\n        assert!(t.value());\n        assert!(!f.value());\n\n        let t2 = TropicalAndOr::from_scalar(true);\n        let f2 = TropicalAndOr::from_scalar(false);\n        assert!(t2.value());\n        assert!(!f2.value());\n    }\n\n    #[test]\n    fn test_argmax_self_true() {\n        // If self is true, return self\n        let t = TropicalAndOr::new(true);\n        let f = TropicalAndOr::new(false);\n\n        let (result, idx) = t.tropical_add_argmax(1, f, 2);\n        assert!(result.0);\n        assert_eq!(idx, 1);\n\n        let (result, idx) = t.tropical_add_argmax(5, t, 10);\n        assert!(result.0);\n        assert_eq!(idx, 5);\n    }\n\n    #[test]\n    fn test_argmax_rhs_true() {\n        // If self is false but rhs is true, return rhs\n        let t = TropicalAndOr::new(true);\n        let f = TropicalAndOr::new(false);\n\n        let (result, idx) = f.tropical_add_argmax(1, t, 2);\n        assert!(result.0);\n        assert_eq!(idx, 2);\n    }\n\n    #[test]\n    fn test_argmax_both_false() {\n        // If both are false, return self (first one)\n        let f1 = TropicalAndOr::new(false);\n        let f2 = TropicalAndOr::new(false);\n\n        let (result, idx) = f1.tropical_add_argmax(10, f2, 20);\n        assert!(!result.0);\n        assert_eq!(idx, 10);\n    }\n\n    #[test]\n    fn test_argmax_chain() {\n        // Simulate accumulating through k iterations - find first true\n        let mut acc = TropicalAndOr::tropical_zero();\n        let mut idx = 0u32;\n\n        let values = [false, false, true, false]; // First true at index 2\n        for (k, \u0026val) in values.iter().enumerate() {\n            let candidate = TropicalAndOr::new(val);\n            (acc, idx) = acc.tropical_add_argmax(idx, candidate, k as u32);\n        }\n\n        assert!(acc.0);\n        assert_eq!(idx, 2); // Index where first true occurred\n    }\n\n    #[test]\n    fn test_simd_tropical() {\n        assert!(TropicalAndOr::SIMD_AVAILABLE);\n        assert_eq!(TropicalAndOr::SIMD_WIDTH, 256);\n    }\n\n    #[test]\n    fn test_clone_copy() {\n        let t = TropicalAndOr::new(true);\n        let t_copy = t; // Copy\n        let t_clone = t.clone(); // Clone\n\n        assert_eq!(t, t_copy);\n        assert_eq!(t, t_clone);\n    }\n\n    #[test]\n    fn test_eq() {\n        let t1 = TropicalAndOr::new(true);\n        let t2 = TropicalAndOr::new(true);\n        let f1 = TropicalAndOr::new(false);\n        let f2 = TropicalAndOr::new(false);\n\n        assert_eq!(t1, t2);\n        assert_eq!(f1, f2);\n        assert_ne!(t1, f1);\n    }\n}\n","traces":[{"line":23,"address":[],"length":0,"stats":{"Line":30}},{"line":24,"address":[],"length":0,"stats":{"Line":30}},{"line":32,"address":[],"length":0,"stats":{"Line":5}},{"line":33,"address":[],"length":0,"stats":{"Line":5}},{"line":37,"address":[],"length":0,"stats":{"Line":1}},{"line":38,"address":[],"length":0,"stats":{"Line":1}},{"line":42,"address":[],"length":0,"stats":{"Line":10}},{"line":43,"address":[],"length":0,"stats":{"Line":15}},{"line":47,"address":[],"length":0,"stats":{"Line":12}},{"line":48,"address":[],"length":0,"stats":{"Line":19}},{"line":52,"address":[],"length":0,"stats":{"Line":4}},{"line":53,"address":[],"length":0,"stats":{"Line":4}},{"line":57,"address":[],"length":0,"stats":{"Line":2}},{"line":58,"address":[],"length":0,"stats":{"Line":2}},{"line":66,"address":[],"length":0,"stats":{"Line":8}},{"line":68,"address":[],"length":0,"stats":{"Line":8}},{"line":69,"address":[],"length":0,"stats":{"Line":3}},{"line":70,"address":[],"length":0,"stats":{"Line":5}},{"line":71,"address":[],"length":0,"stats":{"Line":2}},{"line":73,"address":[],"length":0,"stats":{"Line":3}},{"line":88,"address":[],"length":0,"stats":{"Line":4}},{"line":89,"address":[],"length":0,"stats":{"Line":12}},{"line":97,"address":[],"length":0,"stats":{"Line":4}},{"line":98,"address":[],"length":0,"stats":{"Line":12}},{"line":104,"address":[],"length":0,"stats":{"Line":1}},{"line":105,"address":[],"length":0,"stats":{"Line":1}},{"line":110,"address":[],"length":0,"stats":{"Line":2}},{"line":111,"address":[],"length":0,"stats":{"Line":6}},{"line":116,"address":[],"length":0,"stats":{"Line":2}},{"line":117,"address":[],"length":0,"stats":{"Line":6}},{"line":123,"address":[],"length":0,"stats":{"Line":2}},{"line":124,"address":[],"length":0,"stats":{"Line":2}}],"covered":32,"coverable":32},{"path":["/","home","leo","rcode","cutropicalgemm","crates","tropical-gemm","src","types","counting.rs"],"content":"use super::scalar::TropicalScalar;\nuse super::traits::{SimdTropical, TropicalSemiring, TropicalWithArgmax};\nuse std::fmt;\nuse std::ops::{Add, Mul};\n\n/// CountingTropical semiring: tracks both the tropical value and the count of optimal paths.\n///\n/// For TropicalMaxPlus semantics:\n/// - Multiplication: (n₁, c₁) ⊗ (n₂, c₂) = (n₁ + n₂, c₁ × c₂)\n/// - Addition: (n₁, c₁) ⊕ (n₂, c₂) =\n///   - if n₁ \u003e n₂: (n₁, c₁)\n///   - if n₁ \u003c n₂: (n₂, c₂)\n///   - if n₁ = n₂: (n₁, c₁ + c₂)\n///\n/// This is used for:\n/// - Counting optimal paths in dynamic programming\n/// - Computing partition functions\n/// - Gradient computations in certain neural network architectures\n#[derive(Copy, Clone, PartialEq)]\n#[repr(C)]\npub struct CountingTropical\u003cT: TropicalScalar, C: TropicalScalar = T\u003e {\n    /// The tropical value (using MaxPlus semantics).\n    pub value: T,\n    /// The count of paths achieving this value.\n    pub count: C,\n}\n\nimpl\u003cT: TropicalScalar, C: TropicalScalar\u003e CountingTropical\u003cT, C\u003e {\n    /// Create a new CountingTropical value.\n    #[inline(always)]\n    pub fn new(value: T, count: C) -\u003e Self {\n        Self { value, count }\n    }\n\n    /// Create a CountingTropical from a single value with count 1.\n    #[inline(always)]\n    pub fn from_value(value: T) -\u003e Self {\n        Self {\n            value,\n            count: C::scalar_one(),\n        }\n    }\n}\n\nimpl\u003cT: TropicalScalar, C: TropicalScalar\u003e TropicalSemiring for CountingTropical\u003cT, C\u003e {\n    type Scalar = T;\n\n    #[inline(always)]\n    fn tropical_zero() -\u003e Self {\n        Self {\n            value: T::neg_infinity(),\n            count: C::scalar_zero(),\n        }\n    }\n\n    #[inline(always)]\n    fn tropical_one() -\u003e Self {\n        Self {\n            value: T::scalar_zero(),\n            count: C::scalar_one(),\n        }\n    }\n\n    #[inline(always)]\n    fn tropical_add(self, rhs: Self) -\u003e Self {\n        if self.value \u003e rhs.value {\n            self\n        } else if self.value \u003c rhs.value {\n            rhs\n        } else {\n            // Equal values: add counts\n            Self {\n                value: self.value,\n                count: self.count.scalar_add(rhs.count),\n            }\n        }\n    }\n\n    #[inline(always)]\n    fn tropical_mul(self, rhs: Self) -\u003e Self {\n        Self {\n            value: self.value.scalar_add(rhs.value),\n            count: self.count.scalar_mul(rhs.count),\n        }\n    }\n\n    #[inline(always)]\n    fn value(\u0026self) -\u003e T {\n        self.value\n    }\n\n    #[inline(always)]\n    fn from_scalar(s: T) -\u003e Self {\n        Self::from_value(s)\n    }\n}\n\nimpl\u003cT: TropicalScalar, C: TropicalScalar\u003e TropicalWithArgmax for CountingTropical\u003cT, C\u003e {\n    type Index = u32;\n\n    #[inline(always)]\n    fn tropical_add_argmax(self, self_idx: u32, rhs: Self, rhs_idx: u32) -\u003e (Self, u32) {\n        if self.value \u003e rhs.value {\n            (self, self_idx)\n        } else if self.value \u003c rhs.value {\n            (rhs, rhs_idx)\n        } else {\n            // Equal values: add counts, keep first index\n            (\n                Self {\n                    value: self.value,\n                    count: self.count.scalar_add(rhs.count),\n                },\n                self_idx,\n            )\n        }\n    }\n}\n\nimpl\u003cT: TropicalScalar, C: TropicalScalar\u003e SimdTropical for CountingTropical\u003cT, C\u003e {\n    // SIMD for CountingTropical requires SOA layout\n    const SIMD_AVAILABLE: bool = true;\n    const SIMD_WIDTH: usize = 8;\n}\n\nimpl\u003cT: TropicalScalar, C: TropicalScalar\u003e Add for CountingTropical\u003cT, C\u003e {\n    type Output = Self;\n\n    #[inline(always)]\n    fn add(self, rhs: Self) -\u003e Self::Output {\n        self.tropical_add(rhs)\n    }\n}\n\nimpl\u003cT: TropicalScalar, C: TropicalScalar\u003e Mul for CountingTropical\u003cT, C\u003e {\n    type Output = Self;\n\n    #[inline(always)]\n    fn mul(self, rhs: Self) -\u003e Self::Output {\n        self.tropical_mul(rhs)\n    }\n}\n\nimpl\u003cT: TropicalScalar, C: TropicalScalar\u003e Default for CountingTropical\u003cT, C\u003e {\n    #[inline(always)]\n    fn default() -\u003e Self {\n        Self::tropical_zero()\n    }\n}\n\nimpl\u003cT: TropicalScalar, C: TropicalScalar\u003e fmt::Debug for CountingTropical\u003cT, C\u003e {\n    fn fmt(\u0026self, f: \u0026mut fmt::Formatter\u003c'_\u003e) -\u003e fmt::Result {\n        write!(f, \"CountingTropical({}, {})\", self.value, self.count)\n    }\n}\n\nimpl\u003cT: TropicalScalar, C: TropicalScalar\u003e fmt::Display for CountingTropical\u003cT, C\u003e {\n    fn fmt(\u0026self, f: \u0026mut fmt::Formatter\u003c'_\u003e) -\u003e fmt::Result {\n        write!(f, \"({}, {})\", self.value, self.count)\n    }\n}\n\nimpl\u003cT: TropicalScalar, C: TropicalScalar\u003e From\u003cT\u003e for CountingTropical\u003cT, C\u003e {\n    #[inline(always)]\n    fn from(value: T) -\u003e Self {\n        Self::from_value(value)\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_semiring_identity() {\n        let a = CountingTropical::\u003cf64\u003e::new(5.0, 2.0);\n        let zero = CountingTropical::tropical_zero();\n        let one = CountingTropical::tropical_one();\n\n        // a ⊕ 0 = a\n        let result = a.tropical_add(zero);\n        assert_eq!(result.value, a.value);\n        assert_eq!(result.count, a.count);\n\n        // a ⊗ 1 = a\n        let result = a.tropical_mul(one);\n        assert_eq!(result.value, a.value);\n        assert_eq!(result.count, a.count);\n    }\n\n    #[test]\n    fn test_multiplication() {\n        let a = CountingTropical::\u003cf64\u003e::new(3.0, 2.0);\n        let b = CountingTropical::\u003cf64\u003e::new(5.0, 3.0);\n\n        let result = a.tropical_mul(b);\n        // value = 3 + 5 = 8\n        assert_eq!(result.value, 8.0);\n        // count = 2 * 3 = 6\n        assert_eq!(result.count, 6.0);\n    }\n\n    #[test]\n    fn test_addition_different_values() {\n        let a = CountingTropical::\u003cf64\u003e::new(3.0, 2.0);\n        let b = CountingTropical::\u003cf64\u003e::new(5.0, 3.0);\n\n        let result = a.tropical_add(b);\n        // max(3, 5) = 5, keep count of winner\n        assert_eq!(result.value, 5.0);\n        assert_eq!(result.count, 3.0);\n    }\n\n    #[test]\n    fn test_addition_equal_values() {\n        let a = CountingTropical::\u003cf64\u003e::new(5.0, 2.0);\n        let b = CountingTropical::\u003cf64\u003e::new(5.0, 3.0);\n\n        let result = a.tropical_add(b);\n        // same value, add counts\n        assert_eq!(result.value, 5.0);\n        assert_eq!(result.count, 5.0);\n    }\n\n    #[test]\n    fn test_addition_self_wins() {\n        let a = CountingTropical::\u003cf64\u003e::new(7.0, 1.0);\n        let b = CountingTropical::\u003cf64\u003e::new(5.0, 3.0);\n\n        let result = a.tropical_add(b);\n        // max(7, 5) = 7, keep count of winner\n        assert_eq!(result.value, 7.0);\n        assert_eq!(result.count, 1.0);\n    }\n\n    #[test]\n    fn test_path_counting_example() {\n        // Example: counting paths in a graph\n        // Path A-\u003eB has value 3, count 1 (one path)\n        // Path A-\u003eC-\u003eB has value 3, count 2 (two equivalent paths)\n        // Total paths A-\u003eB with optimal value: 1 + 2 = 3\n\n        let path1 = CountingTropical::\u003cf64\u003e::new(3.0, 1.0);\n        let path2 = CountingTropical::\u003cf64\u003e::new(3.0, 2.0);\n\n        let result = path1.tropical_add(path2);\n        assert_eq!(result.value, 3.0);\n        assert_eq!(result.count, 3.0);\n    }\n\n    #[test]\n    fn test_operator_overloads() {\n        let a = CountingTropical::\u003cf64\u003e::new(3.0, 2.0);\n        let b = CountingTropical::\u003cf64\u003e::new(5.0, 3.0);\n\n        // Add operator\n        let result = a + b;\n        assert_eq!(result.value, 5.0);\n        assert_eq!(result.count, 3.0);\n\n        // Mul operator\n        let result = a * b;\n        assert_eq!(result.value, 8.0);\n        assert_eq!(result.count, 6.0);\n    }\n\n    #[test]\n    fn test_default() {\n        let d = CountingTropical::\u003cf64\u003e::default();\n        assert!(d.value.is_infinite() \u0026\u0026 d.value \u003c 0.0); // -inf\n        assert_eq!(d.count, 0.0);\n    }\n\n    #[test]\n    fn test_display_debug() {\n        let a = CountingTropical::\u003cf64\u003e::new(3.0, 2.0);\n\n        assert_eq!(format!(\"{}\", a), \"(3, 2)\");\n        assert_eq!(format!(\"{:?}\", a), \"CountingTropical(3, 2)\");\n    }\n\n    #[test]\n    fn test_from() {\n        let a: CountingTropical\u003cf64\u003e = 5.0.into();\n        assert_eq!(a.value, 5.0);\n        assert_eq!(a.count, 1.0); // Default count is 1\n\n        let b = CountingTropical::\u003cf64\u003e::from(3.0);\n        assert_eq!(b.value, 3.0);\n        assert_eq!(b.count, 1.0);\n    }\n\n    #[test]\n    fn test_from_value() {\n        let a = CountingTropical::\u003cf64\u003e::from_value(7.0);\n        assert_eq!(a.value, 7.0);\n        assert_eq!(a.count, 1.0);\n    }\n\n    #[test]\n    fn test_value_and_from_scalar() {\n        let a = CountingTropical::\u003cf64\u003e::new(5.0, 2.0);\n        assert_eq!(a.value(), 5.0);\n\n        let b = CountingTropical::\u003cf64\u003e::from_scalar(3.0);\n        assert_eq!(b.value(), 3.0);\n        assert_eq!(b.count, 1.0);\n    }\n\n    #[test]\n    fn test_argmax_self_wins() {\n        let a = CountingTropical::\u003cf64\u003e::new(7.0, 2.0);\n        let b = CountingTropical::\u003cf64\u003e::new(3.0, 1.0);\n\n        let (result, idx) = a.tropical_add_argmax(1, b, 2);\n        assert_eq!(result.value, 7.0);\n        assert_eq!(result.count, 2.0);\n        assert_eq!(idx, 1);\n    }\n\n    #[test]\n    fn test_argmax_rhs_wins() {\n        let a = CountingTropical::\u003cf64\u003e::new(3.0, 1.0);\n        let b = CountingTropical::\u003cf64\u003e::new(7.0, 2.0);\n\n        let (result, idx) = a.tropical_add_argmax(1, b, 2);\n        assert_eq!(result.value, 7.0);\n        assert_eq!(result.count, 2.0);\n        assert_eq!(idx, 2);\n    }\n\n    #[test]\n    fn test_argmax_equal_counts_added() {\n        // Equal values: counts are added, first index is kept\n        let a = CountingTropical::\u003cf64\u003e::new(5.0, 2.0);\n        let b = CountingTropical::\u003cf64\u003e::new(5.0, 3.0);\n\n        let (result, idx) = a.tropical_add_argmax(1, b, 2);\n        assert_eq!(result.value, 5.0);\n        assert_eq!(result.count, 5.0); // 2 + 3\n        assert_eq!(idx, 1); // First index is kept\n    }\n\n    #[test]\n    fn test_argmax_chain() {\n        let mut acc = CountingTropical::\u003cf64\u003e::tropical_zero();\n        let mut idx = 0u32;\n\n        // Values with different counts\n        let values = [(3.0, 1.0), (7.0, 2.0), (7.0, 3.0), (5.0, 1.0)];\n        for (k, \u0026(val, count)) in values.iter().enumerate() {\n            let candidate = CountingTropical::new(val, count);\n            (acc, idx) = acc.tropical_add_argmax(idx, candidate, k as u32);\n        }\n\n        // Max value is 7.0, first encountered at k=1\n        // Counts: 2 + 3 = 5 (both k=1 and k=2 have value 7.0)\n        assert_eq!(acc.value, 7.0);\n        assert_eq!(acc.count, 5.0);\n        assert_eq!(idx, 1); // First index where max occurred\n    }\n\n    #[test]\n    fn test_simd_tropical() {\n        assert!(CountingTropical::\u003cf64\u003e::SIMD_AVAILABLE);\n        assert_eq!(CountingTropical::\u003cf64\u003e::SIMD_WIDTH, 8);\n    }\n\n    #[test]\n    fn test_clone_copy() {\n        let a = CountingTropical::\u003cf64\u003e::new(5.0, 2.0);\n        let a_copy = a;\n        let a_clone = a.clone();\n\n        assert_eq!(a.value, a_copy.value);\n        assert_eq!(a.count, a_copy.count);\n        assert_eq!(a.value, a_clone.value);\n        assert_eq!(a.count, a_clone.count);\n    }\n\n    #[test]\n    fn test_eq() {\n        let a1 = CountingTropical::\u003cf64\u003e::new(5.0, 2.0);\n        let a2 = CountingTropical::\u003cf64\u003e::new(5.0, 2.0);\n        let b = CountingTropical::\u003cf64\u003e::new(5.0, 3.0);\n\n        assert_eq!(a1, a2);\n        assert_ne!(a1, b);\n    }\n\n    #[test]\n    fn test_f32() {\n        let a = CountingTropical::\u003cf32\u003e::new(3.0, 2.0);\n        let b = CountingTropical::\u003cf32\u003e::new(5.0, 3.0);\n\n        let result = a.tropical_mul(b);\n        assert!((result.value - 8.0).abs() \u003c 1e-6);\n        assert!((result.count - 6.0).abs() \u003c 1e-6);\n    }\n\n    #[test]\n    fn test_different_count_type() {\n        // Use different types for value and count\n        let a = CountingTropical::\u003cf64, f32\u003e::new(3.0, 2.0);\n        let b = CountingTropical::\u003cf64, f32\u003e::new(5.0, 3.0);\n\n        let result = a.tropical_mul(b);\n        assert_eq!(result.value, 8.0);\n        assert!((result.count - 6.0).abs() \u003c 1e-6);\n    }\n}\n","traces":[{"line":31,"address":[],"length":0,"stats":{"Line":33}},{"line":37,"address":[],"length":0,"stats":{"Line":1}},{"line":40,"address":[],"length":0,"stats":{"Line":1}},{"line":49,"address":[],"length":0,"stats":{"Line":3}},{"line":51,"address":[],"length":0,"stats":{"Line":3}},{"line":52,"address":[],"length":0,"stats":{"Line":3}},{"line":57,"address":[],"length":0,"stats":{"Line":1}},{"line":59,"address":[],"length":0,"stats":{"Line":1}},{"line":60,"address":[],"length":0,"stats":{"Line":1}},{"line":65,"address":[],"length":0,"stats":{"Line":6}},{"line":66,"address":[],"length":0,"stats":{"Line":6}},{"line":67,"address":[],"length":0,"stats":{"Line":2}},{"line":68,"address":[],"length":0,"stats":{"Line":4}},{"line":69,"address":[],"length":0,"stats":{"Line":2}},{"line":73,"address":[],"length":0,"stats":{"Line":4}},{"line":74,"address":[],"length":0,"stats":{"Line":4}},{"line":80,"address":[],"length":0,"stats":{"Line":5}},{"line":82,"address":[],"length":0,"stats":{"Line":20}},{"line":83,"address":[],"length":0,"stats":{"Line":10}},{"line":88,"address":[],"length":0,"stats":{"Line":2}},{"line":89,"address":[],"length":0,"stats":{"Line":2}},{"line":93,"address":[],"length":0,"stats":{"Line":1}},{"line":94,"address":[],"length":0,"stats":{"Line":2}},{"line":102,"address":[],"length":0,"stats":{"Line":7}},{"line":103,"address":[],"length":0,"stats":{"Line":7}},{"line":104,"address":[],"length":0,"stats":{"Line":2}},{"line":105,"address":[],"length":0,"stats":{"Line":5}},{"line":106,"address":[],"length":0,"stats":{"Line":3}},{"line":110,"address":[],"length":0,"stats":{"Line":2}},{"line":111,"address":[],"length":0,"stats":{"Line":4}},{"line":112,"address":[],"length":0,"stats":{"Line":4}},{"line":114,"address":[],"length":0,"stats":{"Line":2}},{"line":130,"address":[],"length":0,"stats":{"Line":1}},{"line":131,"address":[],"length":0,"stats":{"Line":3}},{"line":139,"address":[],"length":0,"stats":{"Line":1}},{"line":140,"address":[],"length":0,"stats":{"Line":3}},{"line":146,"address":[],"length":0,"stats":{"Line":1}},{"line":147,"address":[],"length":0,"stats":{"Line":1}},{"line":152,"address":[],"length":0,"stats":{"Line":1}},{"line":153,"address":[],"length":0,"stats":{"Line":3}},{"line":158,"address":[],"length":0,"stats":{"Line":1}},{"line":159,"address":[],"length":0,"stats":{"Line":3}},{"line":165,"address":[],"length":0,"stats":{"Line":1}},{"line":166,"address":[],"length":0,"stats":{"Line":2}}],"covered":44,"coverable":44},{"path":["/","home","leo","rcode","cutropicalgemm","crates","tropical-gemm","src","types","max_mul.rs"],"content":"use super::scalar::TropicalScalar;\nuse super::traits::{SimdTropical, TropicalSemiring, TropicalWithArgmax};\nuse std::fmt;\nuse std::ops::{Add, Mul};\n\n/// TropicalMaxMul semiring: (ℝ⁺, max, ×)\n///\n/// - Addition (⊕) = max\n/// - Multiplication (⊗) = ×\n/// - Zero = 0\n/// - One = 1\n///\n/// This is used for:\n/// - Probability computations (non-log space)\n/// - Fuzzy logic with product t-norm\n#[derive(Copy, Clone, PartialEq)]\n#[repr(transparent)]\npub struct TropicalMaxMul\u003cT: TropicalScalar\u003e(pub T);\n\nimpl\u003cT: TropicalScalar\u003e TropicalMaxMul\u003cT\u003e {\n    /// Create a new TropicalMaxMul value.\n    #[inline(always)]\n    pub fn new(value: T) -\u003e Self {\n        Self(value)\n    }\n}\n\nimpl\u003cT: TropicalScalar\u003e TropicalSemiring for TropicalMaxMul\u003cT\u003e {\n    type Scalar = T;\n\n    #[inline(always)]\n    fn tropical_zero() -\u003e Self {\n        Self(T::scalar_zero())\n    }\n\n    #[inline(always)]\n    fn tropical_one() -\u003e Self {\n        Self(T::scalar_one())\n    }\n\n    #[inline(always)]\n    fn tropical_add(self, rhs: Self) -\u003e Self {\n        Self(self.0.scalar_max(rhs.0))\n    }\n\n    #[inline(always)]\n    fn tropical_mul(self, rhs: Self) -\u003e Self {\n        Self(self.0.scalar_mul(rhs.0))\n    }\n\n    #[inline(always)]\n    fn value(\u0026self) -\u003e T {\n        self.0\n    }\n\n    #[inline(always)]\n    fn from_scalar(s: T) -\u003e Self {\n        Self(s)\n    }\n}\n\nimpl\u003cT: TropicalScalar\u003e TropicalWithArgmax for TropicalMaxMul\u003cT\u003e {\n    type Index = u32;\n\n    #[inline(always)]\n    fn tropical_add_argmax(self, self_idx: u32, rhs: Self, rhs_idx: u32) -\u003e (Self, u32) {\n        if self.0 \u003e= rhs.0 {\n            (self, self_idx)\n        } else {\n            (rhs, rhs_idx)\n        }\n    }\n}\n\nimpl\u003cT: TropicalScalar\u003e SimdTropical for TropicalMaxMul\u003cT\u003e {\n    const SIMD_AVAILABLE: bool = true;\n    const SIMD_WIDTH: usize = 8;\n}\n\nimpl\u003cT: TropicalScalar\u003e Add for TropicalMaxMul\u003cT\u003e {\n    type Output = Self;\n\n    #[inline(always)]\n    fn add(self, rhs: Self) -\u003e Self::Output {\n        self.tropical_add(rhs)\n    }\n}\n\nimpl\u003cT: TropicalScalar\u003e Mul for TropicalMaxMul\u003cT\u003e {\n    type Output = Self;\n\n    #[inline(always)]\n    fn mul(self, rhs: Self) -\u003e Self::Output {\n        self.tropical_mul(rhs)\n    }\n}\n\nimpl\u003cT: TropicalScalar\u003e Default for TropicalMaxMul\u003cT\u003e {\n    #[inline(always)]\n    fn default() -\u003e Self {\n        Self::tropical_zero()\n    }\n}\n\nimpl\u003cT: TropicalScalar\u003e fmt::Debug for TropicalMaxMul\u003cT\u003e {\n    fn fmt(\u0026self, f: \u0026mut fmt::Formatter\u003c'_\u003e) -\u003e fmt::Result {\n        write!(f, \"TropicalMaxMul({})\", self.0)\n    }\n}\n\nimpl\u003cT: TropicalScalar\u003e fmt::Display for TropicalMaxMul\u003cT\u003e {\n    fn fmt(\u0026self, f: \u0026mut fmt::Formatter\u003c'_\u003e) -\u003e fmt::Result {\n        write!(f, \"{}\", self.0)\n    }\n}\n\nimpl\u003cT: TropicalScalar\u003e From\u003cT\u003e for TropicalMaxMul\u003cT\u003e {\n    #[inline(always)]\n    fn from(value: T) -\u003e Self {\n        Self(value)\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_semiring_identity() {\n        let a = TropicalMaxMul::new(5.0f64);\n        let zero = TropicalMaxMul::tropical_zero();\n        let one = TropicalMaxMul::tropical_one();\n\n        // a ⊕ 0 = a\n        assert_eq!(a.tropical_add(zero), a);\n        // a ⊗ 1 = a\n        assert_eq!(a.tropical_mul(one), a);\n    }\n\n    #[test]\n    fn test_operations() {\n        let a = TropicalMaxMul::new(3.0f64);\n        let b = TropicalMaxMul::new(5.0f64);\n\n        // max(3, 5) = 5\n        assert_eq!(a.tropical_add(b).0, 5.0);\n        // 3 * 5 = 15\n        assert_eq!(a.tropical_mul(b).0, 15.0);\n    }\n\n    #[test]\n    fn test_absorbing_zero() {\n        let a = TropicalMaxMul::new(5.0f64);\n        let zero = TropicalMaxMul::tropical_zero();\n\n        // a ⊗ 0 = 0\n        assert_eq!(a.tropical_mul(zero), zero);\n    }\n\n    #[test]\n    fn test_operator_overloads() {\n        let a = TropicalMaxMul::new(3.0f64);\n        let b = TropicalMaxMul::new(5.0f64);\n\n        // Add operator (max)\n        assert_eq!((a + b).0, 5.0);\n        assert_eq!((b + a).0, 5.0);\n\n        // Mul operator (product)\n        assert_eq!((a * b).0, 15.0);\n        assert_eq!((b * a).0, 15.0);\n    }\n\n    #[test]\n    fn test_default() {\n        let d = TropicalMaxMul::\u003cf64\u003e::default();\n        assert_eq!(d.0, 0.0); // Zero is 0 for MaxMul\n        assert_eq!(d, TropicalMaxMul::tropical_zero());\n    }\n\n    #[test]\n    fn test_display_debug() {\n        let a = TropicalMaxMul::new(5.0f64);\n\n        assert_eq!(format!(\"{}\", a), \"5\");\n        assert_eq!(format!(\"{:?}\", a), \"TropicalMaxMul(5)\");\n    }\n\n    #[test]\n    fn test_from() {\n        let a: TropicalMaxMul\u003cf64\u003e = 5.0.into();\n        assert_eq!(a.0, 5.0);\n\n        let b = TropicalMaxMul::\u003cf64\u003e::from(3.0);\n        assert_eq!(b.0, 3.0);\n    }\n\n    #[test]\n    fn test_value_and_from_scalar() {\n        let a = TropicalMaxMul::new(5.0f64);\n        assert_eq!(a.value(), 5.0);\n\n        let b = TropicalMaxMul::\u003cf64\u003e::from_scalar(3.0);\n        assert_eq!(b.value(), 3.0);\n    }\n\n    #[test]\n    fn test_argmax_self_wins() {\n        let a = TropicalMaxMul::new(7.0f64);\n        let b = TropicalMaxMul::new(3.0f64);\n\n        let (result, idx) = a.tropical_add_argmax(1, b, 2);\n        assert_eq!(result.0, 7.0);\n        assert_eq!(idx, 1);\n    }\n\n    #[test]\n    fn test_argmax_rhs_wins() {\n        let a = TropicalMaxMul::new(3.0f64);\n        let b = TropicalMaxMul::new(7.0f64);\n\n        let (result, idx) = a.tropical_add_argmax(1, b, 2);\n        assert_eq!(result.0, 7.0);\n        assert_eq!(idx, 2);\n    }\n\n    #[test]\n    fn test_argmax_equal_self_wins() {\n        // When equal, self wins (\u003e= comparison)\n        let a = TropicalMaxMul::new(5.0f64);\n        let b = TropicalMaxMul::new(5.0f64);\n\n        let (result, idx) = a.tropical_add_argmax(1, b, 2);\n        assert_eq!(result.0, 5.0);\n        assert_eq!(idx, 1);\n    }\n\n    #[test]\n    fn test_argmax_chain() {\n        let mut acc = TropicalMaxMul::tropical_zero();\n        let mut idx = 0u32;\n\n        let values = [3.0, 7.0, 2.0, 5.0]; // Max at index 1\n        for (k, \u0026val) in values.iter().enumerate() {\n            let candidate = TropicalMaxMul::new(val);\n            (acc, idx) = acc.tropical_add_argmax(idx, candidate, k as u32);\n        }\n\n        assert_eq!(acc.0, 7.0);\n        assert_eq!(idx, 1);\n    }\n\n    #[test]\n    fn test_simd_tropical() {\n        assert!(TropicalMaxMul::\u003cf64\u003e::SIMD_AVAILABLE);\n        assert_eq!(TropicalMaxMul::\u003cf64\u003e::SIMD_WIDTH, 8);\n    }\n\n    #[test]\n    fn test_clone_copy() {\n        let a = TropicalMaxMul::new(5.0f64);\n        let a_copy = a;\n        let a_clone = a.clone();\n\n        assert_eq!(a, a_copy);\n        assert_eq!(a, a_clone);\n    }\n\n    #[test]\n    fn test_eq() {\n        let a1 = TropicalMaxMul::new(5.0f64);\n        let a2 = TropicalMaxMul::new(5.0f64);\n        let b = TropicalMaxMul::new(3.0f64);\n\n        assert_eq!(a1, a2);\n        assert_ne!(a1, b);\n    }\n\n    #[test]\n    fn test_f32() {\n        let a = TropicalMaxMul::new(3.0f32);\n        let b = TropicalMaxMul::new(5.0f32);\n\n        assert!((a.tropical_add(b).0 - 5.0).abs() \u003c 1e-6);\n        assert!((a.tropical_mul(b).0 - 15.0).abs() \u003c 1e-6);\n    }\n\n    #[test]\n    fn test_fuzzy_logic_example() {\n        // Fuzzy AND (product) and OR (max)\n        let high = TropicalMaxMul::new(0.9f64);\n        let medium = TropicalMaxMul::new(0.5f64);\n        let low = TropicalMaxMul::new(0.2f64);\n\n        // Fuzzy OR of high and low\n        let or_result = high.tropical_add(low);\n        assert_eq!(or_result.0, 0.9);\n\n        // Fuzzy AND of high and medium (product t-norm)\n        let and_result = high.tropical_mul(medium);\n        assert!((and_result.0 - 0.45).abs() \u003c 1e-10);\n    }\n}\n","traces":[{"line":23,"address":[],"length":0,"stats":{"Line":27}},{"line":24,"address":[],"length":0,"stats":{"Line":27}},{"line":32,"address":[],"length":0,"stats":{"Line":4}},{"line":33,"address":[],"length":0,"stats":{"Line":4}},{"line":37,"address":[],"length":0,"stats":{"Line":1}},{"line":38,"address":[],"length":0,"stats":{"Line":1}},{"line":42,"address":[],"length":0,"stats":{"Line":40}},{"line":43,"address":[],"length":0,"stats":{"Line":80}},{"line":47,"address":[],"length":0,"stats":{"Line":48}},{"line":48,"address":[],"length":0,"stats":{"Line":96}},{"line":52,"address":[],"length":0,"stats":{"Line":2}},{"line":53,"address":[],"length":0,"stats":{"Line":2}},{"line":57,"address":[],"length":0,"stats":{"Line":72}},{"line":58,"address":[],"length":0,"stats":{"Line":72}},{"line":66,"address":[],"length":0,"stats":{"Line":8}},{"line":67,"address":[],"length":0,"stats":{"Line":8}},{"line":68,"address":[],"length":0,"stats":{"Line":0}},{"line":70,"address":[],"length":0,"stats":{"Line":8}},{"line":84,"address":[],"length":0,"stats":{"Line":2}},{"line":85,"address":[],"length":0,"stats":{"Line":6}},{"line":93,"address":[],"length":0,"stats":{"Line":2}},{"line":94,"address":[],"length":0,"stats":{"Line":6}},{"line":100,"address":[],"length":0,"stats":{"Line":1}},{"line":101,"address":[],"length":0,"stats":{"Line":1}},{"line":106,"address":[],"length":0,"stats":{"Line":1}},{"line":107,"address":[],"length":0,"stats":{"Line":3}},{"line":112,"address":[],"length":0,"stats":{"Line":1}},{"line":113,"address":[],"length":0,"stats":{"Line":3}},{"line":119,"address":[],"length":0,"stats":{"Line":1}},{"line":120,"address":[],"length":0,"stats":{"Line":1}}],"covered":29,"coverable":30},{"path":["/","home","leo","rcode","cutropicalgemm","crates","tropical-gemm","src","types","max_plus.rs"],"content":"use super::scalar::TropicalScalar;\nuse super::traits::{SimdTropical, TropicalSemiring, TropicalWithArgmax};\nuse std::fmt;\nuse std::ops::{Add, Mul};\n\n/// TropicalMaxPlus semiring: (ℝ ∪ {-∞}, max, +)\n///\n/// - Addition (⊕) = max\n/// - Multiplication (⊗) = +\n/// - Zero = -∞\n/// - One = 0\n///\n/// This is the classic tropical semiring used in:\n/// - Viterbi algorithm\n/// - Shortest path algorithms (with negated weights)\n/// - Log-space probability computations\n#[derive(Copy, Clone, PartialEq)]\n#[repr(transparent)]\npub struct TropicalMaxPlus\u003cT: TropicalScalar\u003e(pub T);\n\nimpl\u003cT: TropicalScalar\u003e TropicalMaxPlus\u003cT\u003e {\n    /// Create a new TropicalMaxPlus value.\n    #[inline(always)]\n    pub fn new(value: T) -\u003e Self {\n        Self(value)\n    }\n}\n\nimpl\u003cT: TropicalScalar\u003e TropicalSemiring for TropicalMaxPlus\u003cT\u003e {\n    type Scalar = T;\n\n    #[inline(always)]\n    fn tropical_zero() -\u003e Self {\n        Self(T::neg_infinity())\n    }\n\n    #[inline(always)]\n    fn tropical_one() -\u003e Self {\n        Self(T::scalar_zero())\n    }\n\n    #[inline(always)]\n    fn tropical_add(self, rhs: Self) -\u003e Self {\n        Self(self.0.scalar_max(rhs.0))\n    }\n\n    #[inline(always)]\n    fn tropical_mul(self, rhs: Self) -\u003e Self {\n        Self(self.0.scalar_add(rhs.0))\n    }\n\n    #[inline(always)]\n    fn value(\u0026self) -\u003e T {\n        self.0\n    }\n\n    #[inline(always)]\n    fn from_scalar(s: T) -\u003e Self {\n        Self(s)\n    }\n}\n\nimpl\u003cT: TropicalScalar\u003e TropicalWithArgmax for TropicalMaxPlus\u003cT\u003e {\n    type Index = u32;\n\n    #[inline(always)]\n    fn tropical_add_argmax(self, self_idx: u32, rhs: Self, rhs_idx: u32) -\u003e (Self, u32) {\n        if self.0 \u003e= rhs.0 {\n            (self, self_idx)\n        } else {\n            (rhs, rhs_idx)\n        }\n    }\n}\n\nimpl\u003cT: TropicalScalar\u003e SimdTropical for TropicalMaxPlus\u003cT\u003e {\n    const SIMD_AVAILABLE: bool = true;\n    const SIMD_WIDTH: usize = 8; // f32x8 for AVX2\n}\n\nimpl\u003cT: TropicalScalar\u003e Add for TropicalMaxPlus\u003cT\u003e {\n    type Output = Self;\n\n    #[inline(always)]\n    fn add(self, rhs: Self) -\u003e Self::Output {\n        self.tropical_add(rhs)\n    }\n}\n\nimpl\u003cT: TropicalScalar\u003e Mul for TropicalMaxPlus\u003cT\u003e {\n    type Output = Self;\n\n    #[inline(always)]\n    fn mul(self, rhs: Self) -\u003e Self::Output {\n        self.tropical_mul(rhs)\n    }\n}\n\nimpl\u003cT: TropicalScalar\u003e Default for TropicalMaxPlus\u003cT\u003e {\n    #[inline(always)]\n    fn default() -\u003e Self {\n        Self::tropical_zero()\n    }\n}\n\nimpl\u003cT: TropicalScalar\u003e fmt::Debug for TropicalMaxPlus\u003cT\u003e {\n    fn fmt(\u0026self, f: \u0026mut fmt::Formatter\u003c'_\u003e) -\u003e fmt::Result {\n        write!(f, \"TropicalMaxPlus({})\", self.0)\n    }\n}\n\nimpl\u003cT: TropicalScalar\u003e fmt::Display for TropicalMaxPlus\u003cT\u003e {\n    fn fmt(\u0026self, f: \u0026mut fmt::Formatter\u003c'_\u003e) -\u003e fmt::Result {\n        write!(f, \"{}\", self.0)\n    }\n}\n\nimpl\u003cT: TropicalScalar\u003e From\u003cT\u003e for TropicalMaxPlus\u003cT\u003e {\n    #[inline(always)]\n    fn from(value: T) -\u003e Self {\n        Self(value)\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_semiring_identity() {\n        let a = TropicalMaxPlus::new(5.0f64);\n        let zero = TropicalMaxPlus::tropical_zero();\n        let one = TropicalMaxPlus::tropical_one();\n\n        // a ⊕ 0 = a\n        assert_eq!(a.tropical_add(zero), a);\n        // a ⊗ 1 = a\n        assert_eq!(a.tropical_mul(one), a);\n    }\n\n    #[test]\n    fn test_operations() {\n        let a = TropicalMaxPlus::new(3.0f64);\n        let b = TropicalMaxPlus::new(5.0f64);\n\n        // max(3, 5) = 5\n        assert_eq!(a.tropical_add(b).0, 5.0);\n        // 3 + 5 = 8\n        assert_eq!(a.tropical_mul(b).0, 8.0);\n    }\n\n    #[test]\n    fn test_argmax() {\n        let a = TropicalMaxPlus::new(3.0f64);\n        let b = TropicalMaxPlus::new(5.0f64);\n\n        let (result, idx) = a.tropical_add_argmax(0, b, 1);\n        assert_eq!(result.0, 5.0);\n        assert_eq!(idx, 1);\n    }\n\n    #[test]\n    fn test_argmax_left_wins() {\n        let a = TropicalMaxPlus::new(7.0f64);\n        let b = TropicalMaxPlus::new(3.0f64);\n\n        let (result, idx) = a.tropical_add_argmax(10, b, 20);\n        assert_eq!(result.0, 7.0);\n        assert_eq!(idx, 10); // Left wins, keep left index\n    }\n\n    #[test]\n    fn test_argmax_equal_values() {\n        // When values are equal, left (self) wins (\u003e= comparison)\n        let a = TropicalMaxPlus::new(5.0f64);\n        let b = TropicalMaxPlus::new(5.0f64);\n\n        let (result, idx) = a.tropical_add_argmax(1, b, 2);\n        assert_eq!(result.0, 5.0);\n        assert_eq!(idx, 1); // Equal, so left (self) wins\n    }\n\n    #[test]\n    fn test_argmax_chain() {\n        // Simulate accumulating through k iterations\n        let mut acc = TropicalMaxPlus::tropical_zero();\n        let mut idx = 0u32;\n\n        let values = [3.0, 7.0, 2.0, 5.0]; // Max is at index 1\n        for (k, \u0026val) in values.iter().enumerate() {\n            let candidate = TropicalMaxPlus::new(val);\n            (acc, idx) = acc.tropical_add_argmax(idx, candidate, k as u32);\n        }\n\n        assert_eq!(acc.0, 7.0);\n        assert_eq!(idx, 1); // Index where max occurred\n    }\n\n    #[test]\n    fn test_argmax_neg_infinity() {\n        let a = TropicalMaxPlus::tropical_zero(); // -inf\n        let b = TropicalMaxPlus::new(-100.0f64);\n\n        let (result, idx) = a.tropical_add_argmax(0, b, 1);\n        assert_eq!(result.0, -100.0);\n        assert_eq!(idx, 1); // -100 \u003e -inf\n    }\n\n    #[test]\n    fn test_absorbing_zero() {\n        let a = TropicalMaxPlus::new(5.0f64);\n        let zero = TropicalMaxPlus::tropical_zero();\n\n        // a ⊗ 0 = a + (-inf) = -inf\n        // In tropical max-plus, multiplying by zero (adding -inf) gives -inf\n        let result = a.tropical_mul(zero);\n        assert!(result.0.is_infinite() \u0026\u0026 result.0 \u003c 0.0);\n    }\n\n    #[test]\n    fn test_operator_overloads() {\n        let a = TropicalMaxPlus::new(3.0f64);\n        let b = TropicalMaxPlus::new(5.0f64);\n\n        // Add operator (max)\n        assert_eq!((a + b).0, 5.0);\n        assert_eq!((b + a).0, 5.0);\n\n        // Mul operator (add)\n        assert_eq!((a * b).0, 8.0);\n        assert_eq!((b * a).0, 8.0);\n    }\n\n    #[test]\n    fn test_default() {\n        let d = TropicalMaxPlus::\u003cf64\u003e::default();\n        assert!(d.0.is_infinite() \u0026\u0026 d.0 \u003c 0.0); // -inf\n        assert_eq!(d, TropicalMaxPlus::tropical_zero());\n    }\n\n    #[test]\n    fn test_display_debug() {\n        let a = TropicalMaxPlus::new(5.0f64);\n\n        assert_eq!(format!(\"{}\", a), \"5\");\n        assert_eq!(format!(\"{:?}\", a), \"TropicalMaxPlus(5)\");\n    }\n\n    #[test]\n    fn test_from() {\n        let a: TropicalMaxPlus\u003cf64\u003e = 5.0.into();\n        assert_eq!(a.0, 5.0);\n\n        let b = TropicalMaxPlus::\u003cf64\u003e::from(3.0);\n        assert_eq!(b.0, 3.0);\n    }\n\n    #[test]\n    fn test_value_and_from_scalar() {\n        let a = TropicalMaxPlus::new(5.0f64);\n        assert_eq!(a.value(), 5.0);\n\n        let b = TropicalMaxPlus::\u003cf64\u003e::from_scalar(3.0);\n        assert_eq!(b.value(), 3.0);\n    }\n\n    #[test]\n    fn test_simd_tropical() {\n        assert!(TropicalMaxPlus::\u003cf64\u003e::SIMD_AVAILABLE);\n        assert_eq!(TropicalMaxPlus::\u003cf64\u003e::SIMD_WIDTH, 8);\n    }\n\n    #[test]\n    fn test_clone_copy() {\n        let a = TropicalMaxPlus::new(5.0f64);\n        let a_copy = a;\n        let a_clone = a.clone();\n\n        assert_eq!(a, a_copy);\n        assert_eq!(a, a_clone);\n    }\n\n    #[test]\n    fn test_eq() {\n        let a1 = TropicalMaxPlus::new(5.0f64);\n        let a2 = TropicalMaxPlus::new(5.0f64);\n        let b = TropicalMaxPlus::new(3.0f64);\n\n        assert_eq!(a1, a2);\n        assert_ne!(a1, b);\n    }\n\n    #[test]\n    fn test_f32() {\n        let a = TropicalMaxPlus::new(3.0f32);\n        let b = TropicalMaxPlus::new(5.0f32);\n\n        assert!((a.tropical_add(b).0 - 5.0).abs() \u003c 1e-6);\n        assert!((a.tropical_mul(b).0 - 8.0).abs() \u003c 1e-6);\n    }\n}\n","traces":[{"line":24,"address":[],"length":0,"stats":{"Line":25}},{"line":25,"address":[],"length":0,"stats":{"Line":25}},{"line":33,"address":[],"length":0,"stats":{"Line":5}},{"line":34,"address":[],"length":0,"stats":{"Line":5}},{"line":38,"address":[],"length":0,"stats":{"Line":1}},{"line":39,"address":[],"length":0,"stats":{"Line":1}},{"line":43,"address":[],"length":0,"stats":{"Line":45}},{"line":44,"address":[],"length":0,"stats":{"Line":90}},{"line":48,"address":[],"length":0,"stats":{"Line":46}},{"line":49,"address":[],"length":0,"stats":{"Line":92}},{"line":53,"address":[],"length":0,"stats":{"Line":2}},{"line":54,"address":[],"length":0,"stats":{"Line":2}},{"line":58,"address":[],"length":0,"stats":{"Line":73}},{"line":59,"address":[],"length":0,"stats":{"Line":73}},{"line":67,"address":[],"length":0,"stats":{"Line":8}},{"line":68,"address":[],"length":0,"stats":{"Line":8}},{"line":69,"address":[],"length":0,"stats":{"Line":4}},{"line":71,"address":[],"length":0,"stats":{"Line":4}},{"line":85,"address":[],"length":0,"stats":{"Line":2}},{"line":86,"address":[],"length":0,"stats":{"Line":6}},{"line":94,"address":[],"length":0,"stats":{"Line":2}},{"line":95,"address":[],"length":0,"stats":{"Line":6}},{"line":101,"address":[],"length":0,"stats":{"Line":1}},{"line":102,"address":[],"length":0,"stats":{"Line":1}},{"line":107,"address":[],"length":0,"stats":{"Line":1}},{"line":108,"address":[],"length":0,"stats":{"Line":3}},{"line":113,"address":[],"length":0,"stats":{"Line":1}},{"line":114,"address":[],"length":0,"stats":{"Line":3}},{"line":120,"address":[],"length":0,"stats":{"Line":1}},{"line":121,"address":[],"length":0,"stats":{"Line":1}}],"covered":30,"coverable":30},{"path":["/","home","leo","rcode","cutropicalgemm","crates","tropical-gemm","src","types","min_plus.rs"],"content":"use super::scalar::TropicalScalar;\nuse super::traits::{SimdTropical, TropicalSemiring, TropicalWithArgmax};\nuse std::fmt;\nuse std::ops::{Add, Mul};\n\n/// TropicalMinPlus semiring: (ℝ ∪ {+∞}, min, +)\n///\n/// - Addition (⊕) = min\n/// - Multiplication (⊗) = +\n/// - Zero = +∞\n/// - One = 0\n///\n/// This is used for:\n/// - Shortest path algorithms (Dijkstra, Floyd-Warshall)\n/// - Dynamic programming with minimum cost\n#[derive(Copy, Clone, PartialEq)]\n#[repr(transparent)]\npub struct TropicalMinPlus\u003cT: TropicalScalar\u003e(pub T);\n\nimpl\u003cT: TropicalScalar\u003e TropicalMinPlus\u003cT\u003e {\n    /// Create a new TropicalMinPlus value.\n    #[inline(always)]\n    pub fn new(value: T) -\u003e Self {\n        Self(value)\n    }\n}\n\nimpl\u003cT: TropicalScalar\u003e TropicalSemiring for TropicalMinPlus\u003cT\u003e {\n    type Scalar = T;\n\n    #[inline(always)]\n    fn tropical_zero() -\u003e Self {\n        Self(T::pos_infinity())\n    }\n\n    #[inline(always)]\n    fn tropical_one() -\u003e Self {\n        Self(T::scalar_zero())\n    }\n\n    #[inline(always)]\n    fn tropical_add(self, rhs: Self) -\u003e Self {\n        Self(self.0.scalar_min(rhs.0))\n    }\n\n    #[inline(always)]\n    fn tropical_mul(self, rhs: Self) -\u003e Self {\n        Self(self.0.scalar_add(rhs.0))\n    }\n\n    #[inline(always)]\n    fn value(\u0026self) -\u003e T {\n        self.0\n    }\n\n    #[inline(always)]\n    fn from_scalar(s: T) -\u003e Self {\n        Self(s)\n    }\n}\n\nimpl\u003cT: TropicalScalar\u003e TropicalWithArgmax for TropicalMinPlus\u003cT\u003e {\n    type Index = u32;\n\n    #[inline(always)]\n    fn tropical_add_argmax(self, self_idx: u32, rhs: Self, rhs_idx: u32) -\u003e (Self, u32) {\n        // For min, we track argmin\n        if self.0 \u003c= rhs.0 {\n            (self, self_idx)\n        } else {\n            (rhs, rhs_idx)\n        }\n    }\n}\n\nimpl\u003cT: TropicalScalar\u003e SimdTropical for TropicalMinPlus\u003cT\u003e {\n    const SIMD_AVAILABLE: bool = true;\n    const SIMD_WIDTH: usize = 8;\n}\n\nimpl\u003cT: TropicalScalar\u003e Add for TropicalMinPlus\u003cT\u003e {\n    type Output = Self;\n\n    #[inline(always)]\n    fn add(self, rhs: Self) -\u003e Self::Output {\n        self.tropical_add(rhs)\n    }\n}\n\nimpl\u003cT: TropicalScalar\u003e Mul for TropicalMinPlus\u003cT\u003e {\n    type Output = Self;\n\n    #[inline(always)]\n    fn mul(self, rhs: Self) -\u003e Self::Output {\n        self.tropical_mul(rhs)\n    }\n}\n\nimpl\u003cT: TropicalScalar\u003e Default for TropicalMinPlus\u003cT\u003e {\n    #[inline(always)]\n    fn default() -\u003e Self {\n        Self::tropical_zero()\n    }\n}\n\nimpl\u003cT: TropicalScalar\u003e fmt::Debug for TropicalMinPlus\u003cT\u003e {\n    fn fmt(\u0026self, f: \u0026mut fmt::Formatter\u003c'_\u003e) -\u003e fmt::Result {\n        write!(f, \"TropicalMinPlus({})\", self.0)\n    }\n}\n\nimpl\u003cT: TropicalScalar\u003e fmt::Display for TropicalMinPlus\u003cT\u003e {\n    fn fmt(\u0026self, f: \u0026mut fmt::Formatter\u003c'_\u003e) -\u003e fmt::Result {\n        write!(f, \"{}\", self.0)\n    }\n}\n\nimpl\u003cT: TropicalScalar\u003e From\u003cT\u003e for TropicalMinPlus\u003cT\u003e {\n    #[inline(always)]\n    fn from(value: T) -\u003e Self {\n        Self(value)\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_semiring_identity() {\n        let a = TropicalMinPlus::new(5.0f64);\n        let zero = TropicalMinPlus::tropical_zero();\n        let one = TropicalMinPlus::tropical_one();\n\n        // a ⊕ 0 = a\n        assert_eq!(a.tropical_add(zero), a);\n        // a ⊗ 1 = a\n        assert_eq!(a.tropical_mul(one), a);\n    }\n\n    #[test]\n    fn test_operations() {\n        let a = TropicalMinPlus::new(3.0f64);\n        let b = TropicalMinPlus::new(5.0f64);\n\n        // min(3, 5) = 3\n        assert_eq!(a.tropical_add(b).0, 3.0);\n        // 3 + 5 = 8\n        assert_eq!(a.tropical_mul(b).0, 8.0);\n    }\n\n    #[test]\n    fn test_shortest_path_scenario() {\n        // Simulating: path cost a=10, path cost b=5, combine = min(10,5) = 5\n        let a = TropicalMinPlus::new(10.0f64);\n        let b = TropicalMinPlus::new(5.0f64);\n        assert_eq!(a.tropical_add(b).0, 5.0);\n\n        // Extending a path: cost=5, edge=3, total = 5+3 = 8\n        let path = TropicalMinPlus::new(5.0f64);\n        let edge = TropicalMinPlus::new(3.0f64);\n        assert_eq!(path.tropical_mul(edge).0, 8.0);\n    }\n\n    #[test]\n    fn test_argmin_right_wins() {\n        // For MinPlus, argmax actually tracks argmin\n        let a = TropicalMinPlus::new(5.0f64);\n        let b = TropicalMinPlus::new(3.0f64);\n\n        let (result, idx) = a.tropical_add_argmax(0, b, 1);\n        assert_eq!(result.0, 3.0);\n        assert_eq!(idx, 1); // Right has smaller value\n    }\n\n    #[test]\n    fn test_argmin_left_wins() {\n        let a = TropicalMinPlus::new(2.0f64);\n        let b = TropicalMinPlus::new(7.0f64);\n\n        let (result, idx) = a.tropical_add_argmax(10, b, 20);\n        assert_eq!(result.0, 2.0);\n        assert_eq!(idx, 10); // Left has smaller value\n    }\n\n    #[test]\n    fn test_argmin_equal_values() {\n        // When values are equal, left (self) wins (\u003c= comparison)\n        let a = TropicalMinPlus::new(5.0f64);\n        let b = TropicalMinPlus::new(5.0f64);\n\n        let (result, idx) = a.tropical_add_argmax(1, b, 2);\n        assert_eq!(result.0, 5.0);\n        assert_eq!(idx, 1); // Equal, so left (self) wins\n    }\n\n    #[test]\n    fn test_argmin_chain() {\n        // Simulate accumulating through k iterations - find minimum\n        let mut acc = TropicalMinPlus::tropical_zero(); // +inf\n        let mut idx = 0u32;\n\n        let values = [8.0, 3.0, 9.0, 5.0]; // Min is at index 1\n        for (k, \u0026val) in values.iter().enumerate() {\n            let candidate = TropicalMinPlus::new(val);\n            (acc, idx) = acc.tropical_add_argmax(idx, candidate, k as u32);\n        }\n\n        assert_eq!(acc.0, 3.0);\n        assert_eq!(idx, 1); // Index where min occurred\n    }\n\n    #[test]\n    fn test_argmin_pos_infinity() {\n        let a = TropicalMinPlus::tropical_zero(); // +inf\n        let b = TropicalMinPlus::new(100.0f64);\n\n        let (result, idx) = a.tropical_add_argmax(0, b, 1);\n        assert_eq!(result.0, 100.0);\n        assert_eq!(idx, 1); // 100 \u003c +inf\n    }\n\n    #[test]\n    fn test_absorbing_zero() {\n        let a = TropicalMinPlus::new(5.0f64);\n        let zero = TropicalMinPlus::tropical_zero();\n\n        // a ⊗ 0 = a + (+inf) = +inf\n        let result = a.tropical_mul(zero);\n        assert!(result.0.is_infinite() \u0026\u0026 result.0 \u003e 0.0);\n    }\n\n    #[test]\n    fn test_operator_overloads() {\n        let a = TropicalMinPlus::new(3.0f64);\n        let b = TropicalMinPlus::new(5.0f64);\n\n        // Add operator (min)\n        assert_eq!((a + b).0, 3.0);\n        assert_eq!((b + a).0, 3.0);\n\n        // Mul operator (add)\n        assert_eq!((a * b).0, 8.0);\n        assert_eq!((b * a).0, 8.0);\n    }\n\n    #[test]\n    fn test_default() {\n        let d = TropicalMinPlus::\u003cf64\u003e::default();\n        assert!(d.0.is_infinite() \u0026\u0026 d.0 \u003e 0.0); // +inf\n        assert_eq!(d, TropicalMinPlus::tropical_zero());\n    }\n\n    #[test]\n    fn test_display_debug() {\n        let a = TropicalMinPlus::new(5.0f64);\n\n        assert_eq!(format!(\"{}\", a), \"5\");\n        assert_eq!(format!(\"{:?}\", a), \"TropicalMinPlus(5)\");\n    }\n\n    #[test]\n    fn test_from() {\n        let a: TropicalMinPlus\u003cf64\u003e = 5.0.into();\n        assert_eq!(a.0, 5.0);\n\n        let b = TropicalMinPlus::\u003cf64\u003e::from(3.0);\n        assert_eq!(b.0, 3.0);\n    }\n\n    #[test]\n    fn test_value_and_from_scalar() {\n        let a = TropicalMinPlus::new(5.0f64);\n        assert_eq!(a.value(), 5.0);\n\n        let b = TropicalMinPlus::\u003cf64\u003e::from_scalar(3.0);\n        assert_eq!(b.value(), 3.0);\n    }\n\n    #[test]\n    fn test_simd_tropical() {\n        assert!(TropicalMinPlus::\u003cf64\u003e::SIMD_AVAILABLE);\n        assert_eq!(TropicalMinPlus::\u003cf64\u003e::SIMD_WIDTH, 8);\n    }\n\n    #[test]\n    fn test_clone_copy() {\n        let a = TropicalMinPlus::new(5.0f64);\n        let a_copy = a;\n        let a_clone = a.clone();\n\n        assert_eq!(a, a_copy);\n        assert_eq!(a, a_clone);\n    }\n\n    #[test]\n    fn test_eq() {\n        let a1 = TropicalMinPlus::new(5.0f64);\n        let a2 = TropicalMinPlus::new(5.0f64);\n        let b = TropicalMinPlus::new(3.0f64);\n\n        assert_eq!(a1, a2);\n        assert_ne!(a1, b);\n    }\n\n    #[test]\n    fn test_f32() {\n        let a = TropicalMinPlus::new(3.0f32);\n        let b = TropicalMinPlus::new(5.0f32);\n\n        assert!((a.tropical_add(b).0 - 3.0).abs() \u003c 1e-6);\n        assert!((a.tropical_mul(b).0 - 8.0).abs() \u003c 1e-6);\n    }\n}\n","traces":[{"line":23,"address":[],"length":0,"stats":{"Line":29}},{"line":24,"address":[],"length":0,"stats":{"Line":29}},{"line":32,"address":[],"length":0,"stats":{"Line":4}},{"line":33,"address":[],"length":0,"stats":{"Line":4}},{"line":37,"address":[],"length":0,"stats":{"Line":1}},{"line":38,"address":[],"length":0,"stats":{"Line":1}},{"line":42,"address":[],"length":0,"stats":{"Line":60}},{"line":43,"address":[],"length":0,"stats":{"Line":120}},{"line":47,"address":[],"length":0,"stats":{"Line":84}},{"line":48,"address":[],"length":0,"stats":{"Line":168}},{"line":52,"address":[],"length":0,"stats":{"Line":2}},{"line":53,"address":[],"length":0,"stats":{"Line":2}},{"line":57,"address":[],"length":0,"stats":{"Line":126}},{"line":58,"address":[],"length":0,"stats":{"Line":126}},{"line":66,"address":[],"length":0,"stats":{"Line":24}},{"line":68,"address":[],"length":0,"stats":{"Line":24}},{"line":69,"address":[],"length":0,"stats":{"Line":16}},{"line":71,"address":[],"length":0,"stats":{"Line":8}},{"line":85,"address":[],"length":0,"stats":{"Line":2}},{"line":86,"address":[],"length":0,"stats":{"Line":6}},{"line":94,"address":[],"length":0,"stats":{"Line":2}},{"line":95,"address":[],"length":0,"stats":{"Line":6}},{"line":101,"address":[],"length":0,"stats":{"Line":1}},{"line":102,"address":[],"length":0,"stats":{"Line":1}},{"line":107,"address":[],"length":0,"stats":{"Line":1}},{"line":108,"address":[],"length":0,"stats":{"Line":3}},{"line":113,"address":[],"length":0,"stats":{"Line":1}},{"line":114,"address":[],"length":0,"stats":{"Line":3}},{"line":120,"address":[],"length":0,"stats":{"Line":1}},{"line":121,"address":[],"length":0,"stats":{"Line":1}}],"covered":30,"coverable":30},{"path":["/","home","leo","rcode","cutropicalgemm","crates","tropical-gemm","src","types","mod.rs"],"content":"//! Tropical number types and semiring traits.\n//!\n//! This module provides the core type system for tropical algebra operations.\n\nmod and_or;\nmod counting;\nmod max_mul;\nmod max_plus;\nmod min_plus;\nmod scalar;\nmod traits;\n\npub use and_or::TropicalAndOr;\npub use counting::CountingTropical;\npub use max_mul::TropicalMaxMul;\npub use max_plus::TropicalMaxPlus;\npub use min_plus::TropicalMinPlus;\npub use scalar::TropicalScalar;\npub use traits::{SimdTropical, TropicalSemiring, TropicalWithArgmax};\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","leo","rcode","cutropicalgemm","crates","tropical-gemm","src","types","scalar.rs"],"content":"use std::fmt::{Debug, Display};\n\n/// Trait for scalar types that can be used as underlying values in tropical numbers.\npub trait TropicalScalar:\n    Copy + Clone + Send + Sync + Debug + Display + PartialOrd + 'static + Sized\n{\n    /// The additive identity (standard arithmetic).\n    fn scalar_zero() -\u003e Self;\n\n    /// The multiplicative identity (standard arithmetic).\n    fn scalar_one() -\u003e Self;\n\n    /// Standard arithmetic addition.\n    fn scalar_add(self, rhs: Self) -\u003e Self;\n\n    /// Standard arithmetic multiplication.\n    fn scalar_mul(self, rhs: Self) -\u003e Self;\n\n    /// Positive infinity (for MinPlus zero).\n    fn pos_infinity() -\u003e Self;\n\n    /// Negative infinity (for MaxPlus zero).\n    fn neg_infinity() -\u003e Self;\n\n    /// Maximum of two values.\n    fn scalar_max(self, rhs: Self) -\u003e Self;\n\n    /// Minimum of two values.\n    fn scalar_min(self, rhs: Self) -\u003e Self;\n}\n\nmacro_rules! impl_tropical_scalar_float {\n    ($($t:ty),*) =\u003e {\n        $(\n            impl TropicalScalar for $t {\n                #[inline(always)]\n                fn scalar_zero() -\u003e Self {\n                    0.0\n                }\n\n                #[inline(always)]\n                fn scalar_one() -\u003e Self {\n                    1.0\n                }\n\n                #[inline(always)]\n                fn scalar_add(self, rhs: Self) -\u003e Self {\n                    self + rhs\n                }\n\n                #[inline(always)]\n                fn scalar_mul(self, rhs: Self) -\u003e Self {\n                    self * rhs\n                }\n\n                #[inline(always)]\n                fn pos_infinity() -\u003e Self {\n                    \u003c$t\u003e::INFINITY\n                }\n\n                #[inline(always)]\n                fn neg_infinity() -\u003e Self {\n                    \u003c$t\u003e::NEG_INFINITY\n                }\n\n                #[inline(always)]\n                fn scalar_max(self, rhs: Self) -\u003e Self {\n                    if self \u003e= rhs { self } else { rhs }\n                }\n\n                #[inline(always)]\n                fn scalar_min(self, rhs: Self) -\u003e Self {\n                    if self \u003c= rhs { self } else { rhs }\n                }\n            }\n        )*\n    };\n}\n\nmacro_rules! impl_tropical_scalar_int {\n    ($($t:ty),*) =\u003e {\n        $(\n            impl TropicalScalar for $t {\n                #[inline(always)]\n                fn scalar_zero() -\u003e Self {\n                    0\n                }\n\n                #[inline(always)]\n                fn scalar_one() -\u003e Self {\n                    1\n                }\n\n                #[inline(always)]\n                fn scalar_add(self, rhs: Self) -\u003e Self {\n                    self + rhs\n                }\n\n                #[inline(always)]\n                fn scalar_mul(self, rhs: Self) -\u003e Self {\n                    self * rhs\n                }\n\n                #[inline(always)]\n                fn pos_infinity() -\u003e Self {\n                    \u003c$t\u003e::MAX\n                }\n\n                #[inline(always)]\n                fn neg_infinity() -\u003e Self {\n                    \u003c$t\u003e::MIN\n                }\n\n                #[inline(always)]\n                fn scalar_max(self, rhs: Self) -\u003e Self {\n                    if self \u003e= rhs { self } else { rhs }\n                }\n\n                #[inline(always)]\n                fn scalar_min(self, rhs: Self) -\u003e Self {\n                    if self \u003c= rhs { self } else { rhs }\n                }\n            }\n        )*\n    };\n}\n\nimpl_tropical_scalar_float!(f32, f64);\nimpl_tropical_scalar_int!(i32, i64, i8, i16, u8, u16, u32, u64);\n\nimpl TropicalScalar for bool {\n    #[inline(always)]\n    fn scalar_zero() -\u003e Self {\n        false\n    }\n\n    #[inline(always)]\n    fn scalar_one() -\u003e Self {\n        true\n    }\n\n    #[inline(always)]\n    fn scalar_add(self, rhs: Self) -\u003e Self {\n        self || rhs\n    }\n\n    #[inline(always)]\n    fn scalar_mul(self, rhs: Self) -\u003e Self {\n        self \u0026\u0026 rhs\n    }\n\n    #[inline(always)]\n    fn pos_infinity() -\u003e Self {\n        true\n    }\n\n    #[inline(always)]\n    fn neg_infinity() -\u003e Self {\n        false\n    }\n\n    #[inline(always)]\n    fn scalar_max(self, rhs: Self) -\u003e Self {\n        self || rhs\n    }\n\n    #[inline(always)]\n    fn scalar_min(self, rhs: Self) -\u003e Self {\n        self \u0026\u0026 rhs\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_f64_scalar() {\n        assert_eq!(f64::scalar_zero(), 0.0);\n        assert_eq!(f64::scalar_one(), 1.0);\n        assert_eq!(3.0f64.scalar_add(5.0), 8.0);\n        assert_eq!(3.0f64.scalar_mul(5.0), 15.0);\n        assert!(f64::pos_infinity().is_infinite() \u0026\u0026 f64::pos_infinity() \u003e 0.0);\n        assert!(f64::neg_infinity().is_infinite() \u0026\u0026 f64::neg_infinity() \u003c 0.0);\n        assert_eq!(3.0f64.scalar_max(5.0), 5.0);\n        assert_eq!(3.0f64.scalar_min(5.0), 3.0);\n    }\n\n    #[test]\n    fn test_f32_scalar() {\n        assert_eq!(f32::scalar_zero(), 0.0);\n        assert_eq!(f32::scalar_one(), 1.0);\n        assert!((3.0f32.scalar_add(5.0) - 8.0).abs() \u003c 1e-6);\n        assert!((3.0f32.scalar_mul(5.0) - 15.0).abs() \u003c 1e-6);\n        assert!(f32::pos_infinity().is_infinite() \u0026\u0026 f32::pos_infinity() \u003e 0.0);\n        assert!(f32::neg_infinity().is_infinite() \u0026\u0026 f32::neg_infinity() \u003c 0.0);\n        assert!((3.0f32.scalar_max(5.0) - 5.0).abs() \u003c 1e-6);\n        assert!((3.0f32.scalar_min(5.0) - 3.0).abs() \u003c 1e-6);\n    }\n\n    #[test]\n    fn test_i32_scalar() {\n        assert_eq!(i32::scalar_zero(), 0);\n        assert_eq!(i32::scalar_one(), 1);\n        assert_eq!(3i32.scalar_add(5), 8);\n        assert_eq!(3i32.scalar_mul(5), 15);\n        assert_eq!(i32::pos_infinity(), i32::MAX);\n        assert_eq!(i32::neg_infinity(), i32::MIN);\n        assert_eq!(3i32.scalar_max(5), 5);\n        assert_eq!(3i32.scalar_min(5), 3);\n    }\n\n    #[test]\n    fn test_i64_scalar() {\n        assert_eq!(i64::scalar_zero(), 0);\n        assert_eq!(i64::scalar_one(), 1);\n        assert_eq!(3i64.scalar_add(5), 8);\n        assert_eq!(3i64.scalar_mul(5), 15);\n        assert_eq!(i64::pos_infinity(), i64::MAX);\n        assert_eq!(i64::neg_infinity(), i64::MIN);\n        assert_eq!(3i64.scalar_max(5), 5);\n        assert_eq!(3i64.scalar_min(5), 3);\n    }\n\n    #[test]\n    fn test_i8_scalar() {\n        assert_eq!(i8::scalar_zero(), 0);\n        assert_eq!(i8::scalar_one(), 1);\n        assert_eq!(3i8.scalar_add(5), 8);\n        assert_eq!(3i8.scalar_mul(5), 15);\n        assert_eq!(i8::pos_infinity(), i8::MAX);\n        assert_eq!(i8::neg_infinity(), i8::MIN);\n        assert_eq!(3i8.scalar_max(5), 5);\n        assert_eq!(3i8.scalar_min(5), 3);\n    }\n\n    #[test]\n    fn test_i16_scalar() {\n        assert_eq!(i16::scalar_zero(), 0);\n        assert_eq!(i16::scalar_one(), 1);\n        assert_eq!(3i16.scalar_add(5), 8);\n        assert_eq!(3i16.scalar_mul(5), 15);\n        assert_eq!(i16::pos_infinity(), i16::MAX);\n        assert_eq!(i16::neg_infinity(), i16::MIN);\n        assert_eq!(3i16.scalar_max(5), 5);\n        assert_eq!(3i16.scalar_min(5), 3);\n    }\n\n    #[test]\n    fn test_u8_scalar() {\n        assert_eq!(u8::scalar_zero(), 0);\n        assert_eq!(u8::scalar_one(), 1);\n        assert_eq!(3u8.scalar_add(5), 8);\n        assert_eq!(3u8.scalar_mul(5), 15);\n        assert_eq!(u8::pos_infinity(), u8::MAX);\n        assert_eq!(u8::neg_infinity(), u8::MIN);\n        assert_eq!(3u8.scalar_max(5), 5);\n        assert_eq!(3u8.scalar_min(5), 3);\n    }\n\n    #[test]\n    fn test_u16_scalar() {\n        assert_eq!(u16::scalar_zero(), 0);\n        assert_eq!(u16::scalar_one(), 1);\n        assert_eq!(3u16.scalar_add(5), 8);\n        assert_eq!(3u16.scalar_mul(5), 15);\n        assert_eq!(u16::pos_infinity(), u16::MAX);\n        assert_eq!(u16::neg_infinity(), u16::MIN);\n        assert_eq!(3u16.scalar_max(5), 5);\n        assert_eq!(3u16.scalar_min(5), 3);\n    }\n\n    #[test]\n    fn test_u32_scalar() {\n        assert_eq!(u32::scalar_zero(), 0);\n        assert_eq!(u32::scalar_one(), 1);\n        assert_eq!(3u32.scalar_add(5), 8);\n        assert_eq!(3u32.scalar_mul(5), 15);\n        assert_eq!(u32::pos_infinity(), u32::MAX);\n        assert_eq!(u32::neg_infinity(), u32::MIN);\n        assert_eq!(3u32.scalar_max(5), 5);\n        assert_eq!(3u32.scalar_min(5), 3);\n    }\n\n    #[test]\n    fn test_u64_scalar() {\n        assert_eq!(u64::scalar_zero(), 0);\n        assert_eq!(u64::scalar_one(), 1);\n        assert_eq!(3u64.scalar_add(5), 8);\n        assert_eq!(3u64.scalar_mul(5), 15);\n        assert_eq!(u64::pos_infinity(), u64::MAX);\n        assert_eq!(u64::neg_infinity(), u64::MIN);\n        assert_eq!(3u64.scalar_max(5), 5);\n        assert_eq!(3u64.scalar_min(5), 3);\n    }\n\n    #[test]\n    fn test_bool_scalar() {\n        assert!(!bool::scalar_zero());\n        assert!(bool::scalar_one());\n        // scalar_add is OR\n        assert!(true.scalar_add(false));\n        assert!(false.scalar_add(true));\n        assert!(!false.scalar_add(false));\n        assert!(true.scalar_add(true));\n        // scalar_mul is AND\n        assert!(!true.scalar_mul(false));\n        assert!(!false.scalar_mul(true));\n        assert!(!false.scalar_mul(false));\n        assert!(true.scalar_mul(true));\n        // pos_infinity is true, neg_infinity is false\n        assert!(bool::pos_infinity());\n        assert!(!bool::neg_infinity());\n        // scalar_max is OR\n        assert!(true.scalar_max(false));\n        assert!(!false.scalar_max(false));\n        // scalar_min is AND\n        assert!(!true.scalar_min(false));\n        assert!(true.scalar_min(true));\n    }\n\n    #[test]\n    fn test_float_edge_cases() {\n        // Test max/min with equal values\n        assert_eq!(5.0f64.scalar_max(5.0), 5.0);\n        assert_eq!(5.0f64.scalar_min(5.0), 5.0);\n        assert_eq!(5.0f32.scalar_max(5.0), 5.0);\n        assert_eq!(5.0f32.scalar_min(5.0), 5.0);\n    }\n\n    #[test]\n    fn test_int_edge_cases() {\n        // Test max/min with equal values\n        assert_eq!(5i32.scalar_max(5), 5);\n        assert_eq!(5i32.scalar_min(5), 5);\n        // Test with negative numbers\n        assert_eq!((-3i32).scalar_max(-5), -3);\n        assert_eq!((-3i32).scalar_min(-5), -5);\n    }\n}\n","traces":[{"line":37,"address":[],"length":0,"stats":{"Line":2}},{"line":38,"address":[],"length":0,"stats":{"Line":2}},{"line":42,"address":[],"length":0,"stats":{"Line":2}},{"line":43,"address":[],"length":0,"stats":{"Line":2}},{"line":47,"address":[],"length":0,"stats":{"Line":6}},{"line":48,"address":[],"length":0,"stats":{"Line":6}},{"line":52,"address":[],"length":0,"stats":{"Line":32}},{"line":53,"address":[],"length":0,"stats":{"Line":32}},{"line":57,"address":[],"length":0,"stats":{"Line":2}},{"line":58,"address":[],"length":0,"stats":{"Line":2}},{"line":62,"address":[],"length":0,"stats":{"Line":3}},{"line":63,"address":[],"length":0,"stats":{"Line":3}},{"line":67,"address":[],"length":0,"stats":{"Line":5}},{"line":68,"address":[],"length":0,"stats":{"Line":10}},{"line":72,"address":[],"length":0,"stats":{"Line":32}},{"line":73,"address":[],"length":0,"stats":{"Line":64}},{"line":85,"address":[],"length":0,"stats":{"Line":8}},{"line":86,"address":[],"length":0,"stats":{"Line":8}},{"line":90,"address":[],"length":0,"stats":{"Line":8}},{"line":91,"address":[],"length":0,"stats":{"Line":8}},{"line":95,"address":[],"length":0,"stats":{"Line":74}},{"line":96,"address":[],"length":0,"stats":{"Line":74}},{"line":100,"address":[],"length":0,"stats":{"Line":22}},{"line":101,"address":[],"length":0,"stats":{"Line":22}},{"line":105,"address":[],"length":0,"stats":{"Line":8}},{"line":106,"address":[],"length":0,"stats":{"Line":8}},{"line":110,"address":[],"length":0,"stats":{"Line":8}},{"line":111,"address":[],"length":0,"stats":{"Line":8}},{"line":115,"address":[],"length":0,"stats":{"Line":62}},{"line":116,"address":[],"length":0,"stats":{"Line":124}},{"line":120,"address":[],"length":0,"stats":{"Line":34}},{"line":121,"address":[],"length":0,"stats":{"Line":68}},{"line":133,"address":[],"length":0,"stats":{"Line":1}},{"line":134,"address":[],"length":0,"stats":{"Line":1}},{"line":138,"address":[],"length":0,"stats":{"Line":1}},{"line":139,"address":[],"length":0,"stats":{"Line":1}},{"line":143,"address":[],"length":0,"stats":{"Line":4}},{"line":144,"address":[],"length":0,"stats":{"Line":6}},{"line":148,"address":[],"length":0,"stats":{"Line":4}},{"line":149,"address":[],"length":0,"stats":{"Line":6}},{"line":153,"address":[],"length":0,"stats":{"Line":1}},{"line":154,"address":[],"length":0,"stats":{"Line":1}},{"line":158,"address":[],"length":0,"stats":{"Line":1}},{"line":159,"address":[],"length":0,"stats":{"Line":1}},{"line":163,"address":[],"length":0,"stats":{"Line":2}},{"line":164,"address":[],"length":0,"stats":{"Line":3}},{"line":168,"address":[],"length":0,"stats":{"Line":2}},{"line":169,"address":[],"length":0,"stats":{"Line":4}}],"covered":48,"coverable":48},{"path":["/","home","leo","rcode","cutropicalgemm","crates","tropical-gemm","src","types","traits.rs"],"content":"use super::scalar::TropicalScalar;\nuse std::fmt::Debug;\n\n/// Core trait for tropical semiring operations.\n///\n/// A semiring (S, ⊕, ⊗) satisfies:\n/// - (S, ⊕) is a commutative monoid with identity `tropical_zero`\n/// - (S, ⊗) is a monoid with identity `tropical_one`\n/// - ⊗ distributes over ⊕\n/// - `tropical_zero` is absorbing: a ⊗ 0 = 0 ⊗ a = 0\npub trait TropicalSemiring: Copy + Clone + Send + Sync + Debug + PartialEq + 'static {\n    /// The underlying scalar type.\n    type Scalar: TropicalScalar;\n\n    /// Returns the additive identity (zero element for ⊕).\n    fn tropical_zero() -\u003e Self;\n\n    /// Returns the multiplicative identity (one element for ⊗).\n    fn tropical_one() -\u003e Self;\n\n    /// Tropical addition (⊕).\n    fn tropical_add(self, rhs: Self) -\u003e Self;\n\n    /// Tropical multiplication (⊗).\n    fn tropical_mul(self, rhs: Self) -\u003e Self;\n\n    /// Get the underlying scalar value.\n    fn value(\u0026self) -\u003e Self::Scalar;\n\n    /// Create from a scalar value.\n    fn from_scalar(s: Self::Scalar) -\u003e Self;\n}\n\n/// Extension trait for tropical types that support argmax tracking.\n///\n/// This is used for backpropagation: during matrix multiplication,\n/// we track which k index produced the optimal value for each C[i,j].\npub trait TropicalWithArgmax: TropicalSemiring {\n    /// The index type used for argmax tracking.\n    type Index: Copy + Default + Debug + Send + Sync + 'static;\n\n    /// Tropical addition with argmax tracking.\n    ///\n    /// Returns the result of `tropical_add` along with the index\n    /// corresponding to which operand \"won\" (produced the result).\n    fn tropical_add_argmax(\n        self,\n        self_idx: Self::Index,\n        rhs: Self,\n        rhs_idx: Self::Index,\n    ) -\u003e (Self, Self::Index);\n}\n\n/// Marker trait for tropical types that support SIMD acceleration.\npub trait SimdTropical: TropicalSemiring {\n    /// Whether SIMD operations are available for this type.\n    const SIMD_AVAILABLE: bool;\n\n    /// The SIMD width in elements.\n    const SIMD_WIDTH: usize;\n}\n","traces":[],"covered":0,"coverable":0}]};
    </script>
    <script crossorigin>/** @license React v16.13.1
 * react.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
'use strict';(function(d,r){"object"===typeof exports&&"undefined"!==typeof module?r(exports):"function"===typeof define&&define.amd?define(["exports"],r):(d=d||self,r(d.React={}))})(this,function(d){function r(a){for(var b="https://reactjs.org/docs/error-decoder.html?invariant="+a,c=1;c<arguments.length;c++)b+="&args[]="+encodeURIComponent(arguments[c]);return"Minified React error #"+a+"; visit "+b+" for the full message or use the non-minified dev environment for full errors and additional helpful warnings."}
function w(a,b,c){this.props=a;this.context=b;this.refs=ba;this.updater=c||ca}function da(){}function L(a,b,c){this.props=a;this.context=b;this.refs=ba;this.updater=c||ca}function ea(a,b,c){var g,e={},fa=null,d=null;if(null!=b)for(g in void 0!==b.ref&&(d=b.ref),void 0!==b.key&&(fa=""+b.key),b)ha.call(b,g)&&!ia.hasOwnProperty(g)&&(e[g]=b[g]);var h=arguments.length-2;if(1===h)e.children=c;else if(1<h){for(var k=Array(h),f=0;f<h;f++)k[f]=arguments[f+2];e.children=k}if(a&&a.defaultProps)for(g in h=a.defaultProps,
h)void 0===e[g]&&(e[g]=h[g]);return{$$typeof:x,type:a,key:fa,ref:d,props:e,_owner:M.current}}function va(a,b){return{$$typeof:x,type:a.type,key:b,ref:a.ref,props:a.props,_owner:a._owner}}function N(a){return"object"===typeof a&&null!==a&&a.$$typeof===x}function wa(a){var b={"=":"=0",":":"=2"};return"$"+(""+a).replace(/[=:]/g,function(a){return b[a]})}function ja(a,b,c,g){if(C.length){var e=C.pop();e.result=a;e.keyPrefix=b;e.func=c;e.context=g;e.count=0;return e}return{result:a,keyPrefix:b,func:c,
context:g,count:0}}function ka(a){a.result=null;a.keyPrefix=null;a.func=null;a.context=null;a.count=0;10>C.length&&C.push(a)}function O(a,b,c,g){var e=typeof a;if("undefined"===e||"boolean"===e)a=null;var d=!1;if(null===a)d=!0;else switch(e){case "string":case "number":d=!0;break;case "object":switch(a.$$typeof){case x:case xa:d=!0}}if(d)return c(g,a,""===b?"."+P(a,0):b),1;d=0;b=""===b?".":b+":";if(Array.isArray(a))for(var f=0;f<a.length;f++){e=a[f];var h=b+P(e,f);d+=O(e,h,c,g)}else if(null===a||
"object"!==typeof a?h=null:(h=la&&a[la]||a["@@iterator"],h="function"===typeof h?h:null),"function"===typeof h)for(a=h.call(a),f=0;!(e=a.next()).done;)e=e.value,h=b+P(e,f++),d+=O(e,h,c,g);else if("object"===e)throw c=""+a,Error(r(31,"[object Object]"===c?"object with keys {"+Object.keys(a).join(", ")+"}":c,""));return d}function Q(a,b,c){return null==a?0:O(a,"",b,c)}function P(a,b){return"object"===typeof a&&null!==a&&null!=a.key?wa(a.key):b.toString(36)}function ya(a,b,c){a.func.call(a.context,b,
a.count++)}function za(a,b,c){var g=a.result,e=a.keyPrefix;a=a.func.call(a.context,b,a.count++);Array.isArray(a)?R(a,g,c,function(a){return a}):null!=a&&(N(a)&&(a=va(a,e+(!a.key||b&&b.key===a.key?"":(""+a.key).replace(ma,"$&/")+"/")+c)),g.push(a))}function R(a,b,c,g,e){var d="";null!=c&&(d=(""+c).replace(ma,"$&/")+"/");b=ja(b,d,g,e);Q(a,za,b);ka(b)}function t(){var a=na.current;if(null===a)throw Error(r(321));return a}function S(a,b){var c=a.length;a.push(b);a:for(;;){var g=c-1>>>1,e=a[g];if(void 0!==
e&&0<D(e,b))a[g]=b,a[c]=e,c=g;else break a}}function n(a){a=a[0];return void 0===a?null:a}function E(a){var b=a[0];if(void 0!==b){var c=a.pop();if(c!==b){a[0]=c;a:for(var g=0,e=a.length;g<e;){var d=2*(g+1)-1,f=a[d],h=d+1,k=a[h];if(void 0!==f&&0>D(f,c))void 0!==k&&0>D(k,f)?(a[g]=k,a[h]=c,g=h):(a[g]=f,a[d]=c,g=d);else if(void 0!==k&&0>D(k,c))a[g]=k,a[h]=c,g=h;else break a}}return b}return null}function D(a,b){var c=a.sortIndex-b.sortIndex;return 0!==c?c:a.id-b.id}function F(a){for(var b=n(u);null!==
b;){if(null===b.callback)E(u);else if(b.startTime<=a)E(u),b.sortIndex=b.expirationTime,S(p,b);else break;b=n(u)}}function T(a){y=!1;F(a);if(!v)if(null!==n(p))v=!0,z(U);else{var b=n(u);null!==b&&G(T,b.startTime-a)}}function U(a,b){v=!1;y&&(y=!1,V());H=!0;var c=m;try{F(b);for(l=n(p);null!==l&&(!(l.expirationTime>b)||a&&!W());){var g=l.callback;if(null!==g){l.callback=null;m=l.priorityLevel;var e=g(l.expirationTime<=b);b=q();"function"===typeof e?l.callback=e:l===n(p)&&E(p);F(b)}else E(p);l=n(p)}if(null!==
l)var d=!0;else{var f=n(u);null!==f&&G(T,f.startTime-b);d=!1}return d}finally{l=null,m=c,H=!1}}function oa(a){switch(a){case 1:return-1;case 2:return 250;case 5:return 1073741823;case 4:return 1E4;default:return 5E3}}var f="function"===typeof Symbol&&Symbol.for,x=f?Symbol.for("react.element"):60103,xa=f?Symbol.for("react.portal"):60106,Aa=f?Symbol.for("react.fragment"):60107,Ba=f?Symbol.for("react.strict_mode"):60108,Ca=f?Symbol.for("react.profiler"):60114,Da=f?Symbol.for("react.provider"):60109,
Ea=f?Symbol.for("react.context"):60110,Fa=f?Symbol.for("react.forward_ref"):60112,Ga=f?Symbol.for("react.suspense"):60113,Ha=f?Symbol.for("react.memo"):60115,Ia=f?Symbol.for("react.lazy"):60116,la="function"===typeof Symbol&&Symbol.iterator,pa=Object.getOwnPropertySymbols,Ja=Object.prototype.hasOwnProperty,Ka=Object.prototype.propertyIsEnumerable,I=function(){try{if(!Object.assign)return!1;var a=new String("abc");a[5]="de";if("5"===Object.getOwnPropertyNames(a)[0])return!1;var b={};for(a=0;10>a;a++)b["_"+
String.fromCharCode(a)]=a;if("0123456789"!==Object.getOwnPropertyNames(b).map(function(a){return b[a]}).join(""))return!1;var c={};"abcdefghijklmnopqrst".split("").forEach(function(a){c[a]=a});return"abcdefghijklmnopqrst"!==Object.keys(Object.assign({},c)).join("")?!1:!0}catch(g){return!1}}()?Object.assign:function(a,b){if(null===a||void 0===a)throw new TypeError("Object.assign cannot be called with null or undefined");var c=Object(a);for(var g,e=1;e<arguments.length;e++){var d=Object(arguments[e]);
for(var f in d)Ja.call(d,f)&&(c[f]=d[f]);if(pa){g=pa(d);for(var h=0;h<g.length;h++)Ka.call(d,g[h])&&(c[g[h]]=d[g[h]])}}return c},ca={isMounted:function(a){return!1},enqueueForceUpdate:function(a,b,c){},enqueueReplaceState:function(a,b,c,d){},enqueueSetState:function(a,b,c,d){}},ba={};w.prototype.isReactComponent={};w.prototype.setState=function(a,b){if("object"!==typeof a&&"function"!==typeof a&&null!=a)throw Error(r(85));this.updater.enqueueSetState(this,a,b,"setState")};w.prototype.forceUpdate=
function(a){this.updater.enqueueForceUpdate(this,a,"forceUpdate")};da.prototype=w.prototype;f=L.prototype=new da;f.constructor=L;I(f,w.prototype);f.isPureReactComponent=!0;var M={current:null},ha=Object.prototype.hasOwnProperty,ia={key:!0,ref:!0,__self:!0,__source:!0},ma=/\/+/g,C=[],na={current:null},X;if("undefined"===typeof window||"function"!==typeof MessageChannel){var A=null,qa=null,ra=function(){if(null!==A)try{var a=q();A(!0,a);A=null}catch(b){throw setTimeout(ra,0),b;}},La=Date.now();var q=
function(){return Date.now()-La};var z=function(a){null!==A?setTimeout(z,0,a):(A=a,setTimeout(ra,0))};var G=function(a,b){qa=setTimeout(a,b)};var V=function(){clearTimeout(qa)};var W=function(){return!1};f=X=function(){}}else{var Y=window.performance,sa=window.Date,Ma=window.setTimeout,Na=window.clearTimeout;"undefined"!==typeof console&&(f=window.cancelAnimationFrame,"function"!==typeof window.requestAnimationFrame&&console.error("This browser doesn't support requestAnimationFrame. Make sure that you load a polyfill in older browsers. https://fb.me/react-polyfills"),
"function"!==typeof f&&console.error("This browser doesn't support cancelAnimationFrame. Make sure that you load a polyfill in older browsers. https://fb.me/react-polyfills"));if("object"===typeof Y&&"function"===typeof Y.now)q=function(){return Y.now()};else{var Oa=sa.now();q=function(){return sa.now()-Oa}}var J=!1,K=null,Z=-1,ta=5,ua=0;W=function(){return q()>=ua};f=function(){};X=function(a){0>a||125<a?console.error("forceFrameRate takes a positive int between 0 and 125, forcing framerates higher than 125 fps is not unsupported"):
ta=0<a?Math.floor(1E3/a):5};var B=new MessageChannel,aa=B.port2;B.port1.onmessage=function(){if(null!==K){var a=q();ua=a+ta;try{K(!0,a)?aa.postMessage(null):(J=!1,K=null)}catch(b){throw aa.postMessage(null),b;}}else J=!1};z=function(a){K=a;J||(J=!0,aa.postMessage(null))};G=function(a,b){Z=Ma(function(){a(q())},b)};V=function(){Na(Z);Z=-1}}var p=[],u=[],Pa=1,l=null,m=3,H=!1,v=!1,y=!1,Qa=0;B={ReactCurrentDispatcher:na,ReactCurrentOwner:M,IsSomeRendererActing:{current:!1},assign:I};I(B,{Scheduler:{__proto__:null,
unstable_ImmediatePriority:1,unstable_UserBlockingPriority:2,unstable_NormalPriority:3,unstable_IdlePriority:5,unstable_LowPriority:4,unstable_runWithPriority:function(a,b){switch(a){case 1:case 2:case 3:case 4:case 5:break;default:a=3}var c=m;m=a;try{return b()}finally{m=c}},unstable_next:function(a){switch(m){case 1:case 2:case 3:var b=3;break;default:b=m}var c=m;m=b;try{return a()}finally{m=c}},unstable_scheduleCallback:function(a,b,c){var d=q();if("object"===typeof c&&null!==c){var e=c.delay;
e="number"===typeof e&&0<e?d+e:d;c="number"===typeof c.timeout?c.timeout:oa(a)}else c=oa(a),e=d;c=e+c;a={id:Pa++,callback:b,priorityLevel:a,startTime:e,expirationTime:c,sortIndex:-1};e>d?(a.sortIndex=e,S(u,a),null===n(p)&&a===n(u)&&(y?V():y=!0,G(T,e-d))):(a.sortIndex=c,S(p,a),v||H||(v=!0,z(U)));return a},unstable_cancelCallback:function(a){a.callback=null},unstable_wrapCallback:function(a){var b=m;return function(){var c=m;m=b;try{return a.apply(this,arguments)}finally{m=c}}},unstable_getCurrentPriorityLevel:function(){return m},
unstable_shouldYield:function(){var a=q();F(a);var b=n(p);return b!==l&&null!==l&&null!==b&&null!==b.callback&&b.startTime<=a&&b.expirationTime<l.expirationTime||W()},unstable_requestPaint:f,unstable_continueExecution:function(){v||H||(v=!0,z(U))},unstable_pauseExecution:function(){},unstable_getFirstCallbackNode:function(){return n(p)},get unstable_now(){return q},get unstable_forceFrameRate(){return X},unstable_Profiling:null},SchedulerTracing:{__proto__:null,__interactionsRef:null,__subscriberRef:null,
unstable_clear:function(a){return a()},unstable_getCurrent:function(){return null},unstable_getThreadID:function(){return++Qa},unstable_trace:function(a,b,c){return c()},unstable_wrap:function(a){return a},unstable_subscribe:function(a){},unstable_unsubscribe:function(a){}}});d.Children={map:function(a,b,c){if(null==a)return a;var d=[];R(a,d,null,b,c);return d},forEach:function(a,b,c){if(null==a)return a;b=ja(null,null,b,c);Q(a,ya,b);ka(b)},count:function(a){return Q(a,function(){return null},null)},
toArray:function(a){var b=[];R(a,b,null,function(a){return a});return b},only:function(a){if(!N(a))throw Error(r(143));return a}};d.Component=w;d.Fragment=Aa;d.Profiler=Ca;d.PureComponent=L;d.StrictMode=Ba;d.Suspense=Ga;d.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED=B;d.cloneElement=function(a,b,c){if(null===a||void 0===a)throw Error(r(267,a));var d=I({},a.props),e=a.key,f=a.ref,m=a._owner;if(null!=b){void 0!==b.ref&&(f=b.ref,m=M.current);void 0!==b.key&&(e=""+b.key);if(a.type&&a.type.defaultProps)var h=
a.type.defaultProps;for(k in b)ha.call(b,k)&&!ia.hasOwnProperty(k)&&(d[k]=void 0===b[k]&&void 0!==h?h[k]:b[k])}var k=arguments.length-2;if(1===k)d.children=c;else if(1<k){h=Array(k);for(var l=0;l<k;l++)h[l]=arguments[l+2];d.children=h}return{$$typeof:x,type:a.type,key:e,ref:f,props:d,_owner:m}};d.createContext=function(a,b){void 0===b&&(b=null);a={$$typeof:Ea,_calculateChangedBits:b,_currentValue:a,_currentValue2:a,_threadCount:0,Provider:null,Consumer:null};a.Provider={$$typeof:Da,_context:a};return a.Consumer=
a};d.createElement=ea;d.createFactory=function(a){var b=ea.bind(null,a);b.type=a;return b};d.createRef=function(){return{current:null}};d.forwardRef=function(a){return{$$typeof:Fa,render:a}};d.isValidElement=N;d.lazy=function(a){return{$$typeof:Ia,_ctor:a,_status:-1,_result:null}};d.memo=function(a,b){return{$$typeof:Ha,type:a,compare:void 0===b?null:b}};d.useCallback=function(a,b){return t().useCallback(a,b)};d.useContext=function(a,b){return t().useContext(a,b)};d.useDebugValue=function(a,b){};
d.useEffect=function(a,b){return t().useEffect(a,b)};d.useImperativeHandle=function(a,b,c){return t().useImperativeHandle(a,b,c)};d.useLayoutEffect=function(a,b){return t().useLayoutEffect(a,b)};d.useMemo=function(a,b){return t().useMemo(a,b)};d.useReducer=function(a,b,c){return t().useReducer(a,b,c)};d.useRef=function(a){return t().useRef(a)};d.useState=function(a){return t().useState(a)};d.version="16.13.1"});
</script>
    <script crossorigin>/** @license React v16.13.1
 * react-dom.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
/*
 Modernizr 3.0.0pre (Custom Build) | MIT
*/
'use strict';(function(I,ea){"object"===typeof exports&&"undefined"!==typeof module?ea(exports,require("react")):"function"===typeof define&&define.amd?define(["exports","react"],ea):(I=I||self,ea(I.ReactDOM={},I.React))})(this,function(I,ea){function k(a){for(var b="https://reactjs.org/docs/error-decoder.html?invariant="+a,c=1;c<arguments.length;c++)b+="&args[]="+encodeURIComponent(arguments[c]);return"Minified React error #"+a+"; visit "+b+" for the full message or use the non-minified dev environment for full errors and additional helpful warnings."}
function ji(a,b,c,d,e,f,g,h,m){yb=!1;gc=null;ki.apply(li,arguments)}function mi(a,b,c,d,e,f,g,h,m){ji.apply(this,arguments);if(yb){if(yb){var n=gc;yb=!1;gc=null}else throw Error(k(198));hc||(hc=!0,pd=n)}}function lf(a,b,c){var d=a.type||"unknown-event";a.currentTarget=mf(c);mi(d,b,void 0,a);a.currentTarget=null}function nf(){if(ic)for(var a in cb){var b=cb[a],c=ic.indexOf(a);if(!(-1<c))throw Error(k(96,a));if(!jc[c]){if(!b.extractEvents)throw Error(k(97,a));jc[c]=b;c=b.eventTypes;for(var d in c){var e=
void 0;var f=c[d],g=b,h=d;if(qd.hasOwnProperty(h))throw Error(k(99,h));qd[h]=f;var m=f.phasedRegistrationNames;if(m){for(e in m)m.hasOwnProperty(e)&&of(m[e],g,h);e=!0}else f.registrationName?(of(f.registrationName,g,h),e=!0):e=!1;if(!e)throw Error(k(98,d,a));}}}}function of(a,b,c){if(db[a])throw Error(k(100,a));db[a]=b;rd[a]=b.eventTypes[c].dependencies}function pf(a){var b=!1,c;for(c in a)if(a.hasOwnProperty(c)){var d=a[c];if(!cb.hasOwnProperty(c)||cb[c]!==d){if(cb[c])throw Error(k(102,c));cb[c]=
d;b=!0}}b&&nf()}function qf(a){if(a=rf(a)){if("function"!==typeof sd)throw Error(k(280));var b=a.stateNode;b&&(b=td(b),sd(a.stateNode,a.type,b))}}function sf(a){eb?fb?fb.push(a):fb=[a]:eb=a}function tf(){if(eb){var a=eb,b=fb;fb=eb=null;qf(a);if(b)for(a=0;a<b.length;a++)qf(b[a])}}function ud(){if(null!==eb||null!==fb)vd(),tf()}function uf(a,b,c){if(wd)return a(b,c);wd=!0;try{return vf(a,b,c)}finally{wd=!1,ud()}}function ni(a){if(wf.call(xf,a))return!0;if(wf.call(yf,a))return!1;if(oi.test(a))return xf[a]=
!0;yf[a]=!0;return!1}function pi(a,b,c,d){if(null!==c&&0===c.type)return!1;switch(typeof b){case "function":case "symbol":return!0;case "boolean":if(d)return!1;if(null!==c)return!c.acceptsBooleans;a=a.toLowerCase().slice(0,5);return"data-"!==a&&"aria-"!==a;default:return!1}}function qi(a,b,c,d){if(null===b||"undefined"===typeof b||pi(a,b,c,d))return!0;if(d)return!1;if(null!==c)switch(c.type){case 3:return!b;case 4:return!1===b;case 5:return isNaN(b);case 6:return isNaN(b)||1>b}return!1}function L(a,
b,c,d,e,f){this.acceptsBooleans=2===b||3===b||4===b;this.attributeName=d;this.attributeNamespace=e;this.mustUseProperty=c;this.propertyName=a;this.type=b;this.sanitizeURL=f}function xd(a,b,c,d){var e=E.hasOwnProperty(b)?E[b]:null;var f=null!==e?0===e.type:d?!1:!(2<b.length)||"o"!==b[0]&&"O"!==b[0]||"n"!==b[1]&&"N"!==b[1]?!1:!0;f||(qi(b,c,e,d)&&(c=null),d||null===e?ni(b)&&(null===c?a.removeAttribute(b):a.setAttribute(b,""+c)):e.mustUseProperty?a[e.propertyName]=null===c?3===e.type?!1:"":c:(b=e.attributeName,
d=e.attributeNamespace,null===c?a.removeAttribute(b):(e=e.type,c=3===e||4===e&&!0===c?"":""+c,d?a.setAttributeNS(d,b,c):a.setAttribute(b,c))))}function zb(a){if(null===a||"object"!==typeof a)return null;a=zf&&a[zf]||a["@@iterator"];return"function"===typeof a?a:null}function ri(a){if(-1===a._status){a._status=0;var b=a._ctor;b=b();a._result=b;b.then(function(b){0===a._status&&(b=b.default,a._status=1,a._result=b)},function(b){0===a._status&&(a._status=2,a._result=b)})}}function na(a){if(null==a)return null;
if("function"===typeof a)return a.displayName||a.name||null;if("string"===typeof a)return a;switch(a){case Ma:return"Fragment";case gb:return"Portal";case kc:return"Profiler";case Af:return"StrictMode";case lc:return"Suspense";case yd:return"SuspenseList"}if("object"===typeof a)switch(a.$$typeof){case Bf:return"Context.Consumer";case Cf:return"Context.Provider";case zd:var b=a.render;b=b.displayName||b.name||"";return a.displayName||(""!==b?"ForwardRef("+b+")":"ForwardRef");case Ad:return na(a.type);
case Df:return na(a.render);case Ef:if(a=1===a._status?a._result:null)return na(a)}return null}function Bd(a){var b="";do{a:switch(a.tag){case 3:case 4:case 6:case 7:case 10:case 9:var c="";break a;default:var d=a._debugOwner,e=a._debugSource,f=na(a.type);c=null;d&&(c=na(d.type));d=f;f="";e?f=" (at "+e.fileName.replace(si,"")+":"+e.lineNumber+")":c&&(f=" (created by "+c+")");c="\n    in "+(d||"Unknown")+f}b+=c;a=a.return}while(a);return b}function va(a){switch(typeof a){case "boolean":case "number":case "object":case "string":case "undefined":return a;
default:return""}}function Ff(a){var b=a.type;return(a=a.nodeName)&&"input"===a.toLowerCase()&&("checkbox"===b||"radio"===b)}function ti(a){var b=Ff(a)?"checked":"value",c=Object.getOwnPropertyDescriptor(a.constructor.prototype,b),d=""+a[b];if(!a.hasOwnProperty(b)&&"undefined"!==typeof c&&"function"===typeof c.get&&"function"===typeof c.set){var e=c.get,f=c.set;Object.defineProperty(a,b,{configurable:!0,get:function(){return e.call(this)},set:function(a){d=""+a;f.call(this,a)}});Object.defineProperty(a,
b,{enumerable:c.enumerable});return{getValue:function(){return d},setValue:function(a){d=""+a},stopTracking:function(){a._valueTracker=null;delete a[b]}}}}function mc(a){a._valueTracker||(a._valueTracker=ti(a))}function Gf(a){if(!a)return!1;var b=a._valueTracker;if(!b)return!0;var c=b.getValue();var d="";a&&(d=Ff(a)?a.checked?"true":"false":a.value);a=d;return a!==c?(b.setValue(a),!0):!1}function Cd(a,b){var c=b.checked;return M({},b,{defaultChecked:void 0,defaultValue:void 0,value:void 0,checked:null!=
c?c:a._wrapperState.initialChecked})}function Hf(a,b){var c=null==b.defaultValue?"":b.defaultValue,d=null!=b.checked?b.checked:b.defaultChecked;c=va(null!=b.value?b.value:c);a._wrapperState={initialChecked:d,initialValue:c,controlled:"checkbox"===b.type||"radio"===b.type?null!=b.checked:null!=b.value}}function If(a,b){b=b.checked;null!=b&&xd(a,"checked",b,!1)}function Dd(a,b){If(a,b);var c=va(b.value),d=b.type;if(null!=c)if("number"===d){if(0===c&&""===a.value||a.value!=c)a.value=""+c}else a.value!==
""+c&&(a.value=""+c);else if("submit"===d||"reset"===d){a.removeAttribute("value");return}b.hasOwnProperty("value")?Ed(a,b.type,c):b.hasOwnProperty("defaultValue")&&Ed(a,b.type,va(b.defaultValue));null==b.checked&&null!=b.defaultChecked&&(a.defaultChecked=!!b.defaultChecked)}function Jf(a,b,c){if(b.hasOwnProperty("value")||b.hasOwnProperty("defaultValue")){var d=b.type;if(!("submit"!==d&&"reset"!==d||void 0!==b.value&&null!==b.value))return;b=""+a._wrapperState.initialValue;c||b===a.value||(a.value=
b);a.defaultValue=b}c=a.name;""!==c&&(a.name="");a.defaultChecked=!!a._wrapperState.initialChecked;""!==c&&(a.name=c)}function Ed(a,b,c){if("number"!==b||a.ownerDocument.activeElement!==a)null==c?a.defaultValue=""+a._wrapperState.initialValue:a.defaultValue!==""+c&&(a.defaultValue=""+c)}function ui(a){var b="";ea.Children.forEach(a,function(a){null!=a&&(b+=a)});return b}function Fd(a,b){a=M({children:void 0},b);if(b=ui(b.children))a.children=b;return a}function hb(a,b,c,d){a=a.options;if(b){b={};
for(var e=0;e<c.length;e++)b["$"+c[e]]=!0;for(c=0;c<a.length;c++)e=b.hasOwnProperty("$"+a[c].value),a[c].selected!==e&&(a[c].selected=e),e&&d&&(a[c].defaultSelected=!0)}else{c=""+va(c);b=null;for(e=0;e<a.length;e++){if(a[e].value===c){a[e].selected=!0;d&&(a[e].defaultSelected=!0);return}null!==b||a[e].disabled||(b=a[e])}null!==b&&(b.selected=!0)}}function Gd(a,b){if(null!=b.dangerouslySetInnerHTML)throw Error(k(91));return M({},b,{value:void 0,defaultValue:void 0,children:""+a._wrapperState.initialValue})}
function Kf(a,b){var c=b.value;if(null==c){c=b.children;b=b.defaultValue;if(null!=c){if(null!=b)throw Error(k(92));if(Array.isArray(c)){if(!(1>=c.length))throw Error(k(93));c=c[0]}b=c}null==b&&(b="");c=b}a._wrapperState={initialValue:va(c)}}function Lf(a,b){var c=va(b.value),d=va(b.defaultValue);null!=c&&(c=""+c,c!==a.value&&(a.value=c),null==b.defaultValue&&a.defaultValue!==c&&(a.defaultValue=c));null!=d&&(a.defaultValue=""+d)}function Mf(a,b){b=a.textContent;b===a._wrapperState.initialValue&&""!==
b&&null!==b&&(a.value=b)}function Nf(a){switch(a){case "svg":return"http://www.w3.org/2000/svg";case "math":return"http://www.w3.org/1998/Math/MathML";default:return"http://www.w3.org/1999/xhtml"}}function Hd(a,b){return null==a||"http://www.w3.org/1999/xhtml"===a?Nf(b):"http://www.w3.org/2000/svg"===a&&"foreignObject"===b?"http://www.w3.org/1999/xhtml":a}function nc(a,b){var c={};c[a.toLowerCase()]=b.toLowerCase();c["Webkit"+a]="webkit"+b;c["Moz"+a]="moz"+b;return c}function oc(a){if(Id[a])return Id[a];
if(!ib[a])return a;var b=ib[a],c;for(c in b)if(b.hasOwnProperty(c)&&c in Of)return Id[a]=b[c];return a}function Jd(a){var b=Pf.get(a);void 0===b&&(b=new Map,Pf.set(a,b));return b}function Na(a){var b=a,c=a;if(a.alternate)for(;b.return;)b=b.return;else{a=b;do b=a,0!==(b.effectTag&1026)&&(c=b.return),a=b.return;while(a)}return 3===b.tag?c:null}function Qf(a){if(13===a.tag){var b=a.memoizedState;null===b&&(a=a.alternate,null!==a&&(b=a.memoizedState));if(null!==b)return b.dehydrated}return null}function Rf(a){if(Na(a)!==
a)throw Error(k(188));}function vi(a){var b=a.alternate;if(!b){b=Na(a);if(null===b)throw Error(k(188));return b!==a?null:a}for(var c=a,d=b;;){var e=c.return;if(null===e)break;var f=e.alternate;if(null===f){d=e.return;if(null!==d){c=d;continue}break}if(e.child===f.child){for(f=e.child;f;){if(f===c)return Rf(e),a;if(f===d)return Rf(e),b;f=f.sibling}throw Error(k(188));}if(c.return!==d.return)c=e,d=f;else{for(var g=!1,h=e.child;h;){if(h===c){g=!0;c=e;d=f;break}if(h===d){g=!0;d=e;c=f;break}h=h.sibling}if(!g){for(h=
f.child;h;){if(h===c){g=!0;c=f;d=e;break}if(h===d){g=!0;d=f;c=e;break}h=h.sibling}if(!g)throw Error(k(189));}}if(c.alternate!==d)throw Error(k(190));}if(3!==c.tag)throw Error(k(188));return c.stateNode.current===c?a:b}function Sf(a){a=vi(a);if(!a)return null;for(var b=a;;){if(5===b.tag||6===b.tag)return b;if(b.child)b.child.return=b,b=b.child;else{if(b===a)break;for(;!b.sibling;){if(!b.return||b.return===a)return null;b=b.return}b.sibling.return=b.return;b=b.sibling}}return null}function jb(a,b){if(null==
b)throw Error(k(30));if(null==a)return b;if(Array.isArray(a)){if(Array.isArray(b))return a.push.apply(a,b),a;a.push(b);return a}return Array.isArray(b)?[a].concat(b):[a,b]}function Kd(a,b,c){Array.isArray(a)?a.forEach(b,c):a&&b.call(c,a)}function pc(a){null!==a&&(Ab=jb(Ab,a));a=Ab;Ab=null;if(a){Kd(a,wi);if(Ab)throw Error(k(95));if(hc)throw a=pd,hc=!1,pd=null,a;}}function Ld(a){a=a.target||a.srcElement||window;a.correspondingUseElement&&(a=a.correspondingUseElement);return 3===a.nodeType?a.parentNode:
a}function Tf(a){if(!wa)return!1;a="on"+a;var b=a in document;b||(b=document.createElement("div"),b.setAttribute(a,"return;"),b="function"===typeof b[a]);return b}function Uf(a){a.topLevelType=null;a.nativeEvent=null;a.targetInst=null;a.ancestors.length=0;10>qc.length&&qc.push(a)}function Vf(a,b,c,d){if(qc.length){var e=qc.pop();e.topLevelType=a;e.eventSystemFlags=d;e.nativeEvent=b;e.targetInst=c;return e}return{topLevelType:a,eventSystemFlags:d,nativeEvent:b,targetInst:c,ancestors:[]}}function Wf(a){var b=
a.targetInst,c=b;do{if(!c){a.ancestors.push(c);break}var d=c;if(3===d.tag)d=d.stateNode.containerInfo;else{for(;d.return;)d=d.return;d=3!==d.tag?null:d.stateNode.containerInfo}if(!d)break;b=c.tag;5!==b&&6!==b||a.ancestors.push(c);c=Bb(d)}while(c);for(c=0;c<a.ancestors.length;c++){b=a.ancestors[c];var e=Ld(a.nativeEvent);d=a.topLevelType;var f=a.nativeEvent,g=a.eventSystemFlags;0===c&&(g|=64);for(var h=null,m=0;m<jc.length;m++){var n=jc[m];n&&(n=n.extractEvents(d,b,f,e,g))&&(h=jb(h,n))}pc(h)}}function Md(a,
b,c){if(!c.has(a)){switch(a){case "scroll":Cb(b,"scroll",!0);break;case "focus":case "blur":Cb(b,"focus",!0);Cb(b,"blur",!0);c.set("blur",null);c.set("focus",null);break;case "cancel":case "close":Tf(a)&&Cb(b,a,!0);break;case "invalid":case "submit":case "reset":break;default:-1===Db.indexOf(a)&&w(a,b)}c.set(a,null)}}function xi(a,b){var c=Jd(b);Nd.forEach(function(a){Md(a,b,c)});yi.forEach(function(a){Md(a,b,c)})}function Od(a,b,c,d,e){return{blockedOn:a,topLevelType:b,eventSystemFlags:c|32,nativeEvent:e,
container:d}}function Xf(a,b){switch(a){case "focus":case "blur":xa=null;break;case "dragenter":case "dragleave":ya=null;break;case "mouseover":case "mouseout":za=null;break;case "pointerover":case "pointerout":Eb.delete(b.pointerId);break;case "gotpointercapture":case "lostpointercapture":Fb.delete(b.pointerId)}}function Gb(a,b,c,d,e,f){if(null===a||a.nativeEvent!==f)return a=Od(b,c,d,e,f),null!==b&&(b=Hb(b),null!==b&&Yf(b)),a;a.eventSystemFlags|=d;return a}function zi(a,b,c,d,e){switch(b){case "focus":return xa=
Gb(xa,a,b,c,d,e),!0;case "dragenter":return ya=Gb(ya,a,b,c,d,e),!0;case "mouseover":return za=Gb(za,a,b,c,d,e),!0;case "pointerover":var f=e.pointerId;Eb.set(f,Gb(Eb.get(f)||null,a,b,c,d,e));return!0;case "gotpointercapture":return f=e.pointerId,Fb.set(f,Gb(Fb.get(f)||null,a,b,c,d,e)),!0}return!1}function Ai(a){var b=Bb(a.target);if(null!==b){var c=Na(b);if(null!==c)if(b=c.tag,13===b){if(b=Qf(c),null!==b){a.blockedOn=b;Pd(a.priority,function(){Bi(c)});return}}else if(3===b&&c.stateNode.hydrate){a.blockedOn=
3===c.tag?c.stateNode.containerInfo:null;return}}a.blockedOn=null}function rc(a){if(null!==a.blockedOn)return!1;var b=Qd(a.topLevelType,a.eventSystemFlags,a.container,a.nativeEvent);if(null!==b){var c=Hb(b);null!==c&&Yf(c);a.blockedOn=b;return!1}return!0}function Zf(a,b,c){rc(a)&&c.delete(b)}function Ci(){for(Rd=!1;0<fa.length;){var a=fa[0];if(null!==a.blockedOn){a=Hb(a.blockedOn);null!==a&&Di(a);break}var b=Qd(a.topLevelType,a.eventSystemFlags,a.container,a.nativeEvent);null!==b?a.blockedOn=b:fa.shift()}null!==
xa&&rc(xa)&&(xa=null);null!==ya&&rc(ya)&&(ya=null);null!==za&&rc(za)&&(za=null);Eb.forEach(Zf);Fb.forEach(Zf)}function Ib(a,b){a.blockedOn===b&&(a.blockedOn=null,Rd||(Rd=!0,$f(ag,Ci)))}function bg(a){if(0<fa.length){Ib(fa[0],a);for(var b=1;b<fa.length;b++){var c=fa[b];c.blockedOn===a&&(c.blockedOn=null)}}null!==xa&&Ib(xa,a);null!==ya&&Ib(ya,a);null!==za&&Ib(za,a);b=function(b){return Ib(b,a)};Eb.forEach(b);Fb.forEach(b);for(b=0;b<Jb.length;b++)c=Jb[b],c.blockedOn===a&&(c.blockedOn=null);for(;0<Jb.length&&
(b=Jb[0],null===b.blockedOn);)Ai(b),null===b.blockedOn&&Jb.shift()}function Sd(a,b){for(var c=0;c<a.length;c+=2){var d=a[c],e=a[c+1],f="on"+(e[0].toUpperCase()+e.slice(1));f={phasedRegistrationNames:{bubbled:f,captured:f+"Capture"},dependencies:[d],eventPriority:b};Td.set(d,b);cg.set(d,f);dg[e]=f}}function w(a,b){Cb(b,a,!1)}function Cb(a,b,c){var d=Td.get(b);switch(void 0===d?2:d){case 0:d=Ei.bind(null,b,1,a);break;case 1:d=Fi.bind(null,b,1,a);break;default:d=sc.bind(null,b,1,a)}c?a.addEventListener(b,
d,!0):a.addEventListener(b,d,!1)}function Ei(a,b,c,d){Oa||vd();var e=sc,f=Oa;Oa=!0;try{eg(e,a,b,c,d)}finally{(Oa=f)||ud()}}function Fi(a,b,c,d){Gi(Hi,sc.bind(null,a,b,c,d))}function sc(a,b,c,d){if(tc)if(0<fa.length&&-1<Nd.indexOf(a))a=Od(null,a,b,c,d),fa.push(a);else{var e=Qd(a,b,c,d);if(null===e)Xf(a,d);else if(-1<Nd.indexOf(a))a=Od(e,a,b,c,d),fa.push(a);else if(!zi(e,a,b,c,d)){Xf(a,d);a=Vf(a,d,null,b);try{uf(Wf,a)}finally{Uf(a)}}}}function Qd(a,b,c,d){c=Ld(d);c=Bb(c);if(null!==c){var e=Na(c);if(null===
e)c=null;else{var f=e.tag;if(13===f){c=Qf(e);if(null!==c)return c;c=null}else if(3===f){if(e.stateNode.hydrate)return 3===e.tag?e.stateNode.containerInfo:null;c=null}else e!==c&&(c=null)}}a=Vf(a,d,c,b);try{uf(Wf,a)}finally{Uf(a)}return null}function fg(a,b,c){return null==b||"boolean"===typeof b||""===b?"":c||"number"!==typeof b||0===b||Kb.hasOwnProperty(a)&&Kb[a]?(""+b).trim():b+"px"}function gg(a,b){a=a.style;for(var c in b)if(b.hasOwnProperty(c)){var d=0===c.indexOf("--"),e=fg(c,b[c],d);"float"===
c&&(c="cssFloat");d?a.setProperty(c,e):a[c]=e}}function Ud(a,b){if(b){if(Ii[a]&&(null!=b.children||null!=b.dangerouslySetInnerHTML))throw Error(k(137,a,""));if(null!=b.dangerouslySetInnerHTML){if(null!=b.children)throw Error(k(60));if(!("object"===typeof b.dangerouslySetInnerHTML&&"__html"in b.dangerouslySetInnerHTML))throw Error(k(61));}if(null!=b.style&&"object"!==typeof b.style)throw Error(k(62,""));}}function Vd(a,b){if(-1===a.indexOf("-"))return"string"===typeof b.is;switch(a){case "annotation-xml":case "color-profile":case "font-face":case "font-face-src":case "font-face-uri":case "font-face-format":case "font-face-name":case "missing-glyph":return!1;
default:return!0}}function oa(a,b){a=9===a.nodeType||11===a.nodeType?a:a.ownerDocument;var c=Jd(a);b=rd[b];for(var d=0;d<b.length;d++)Md(b[d],a,c)}function uc(){}function Wd(a){a=a||("undefined"!==typeof document?document:void 0);if("undefined"===typeof a)return null;try{return a.activeElement||a.body}catch(b){return a.body}}function hg(a){for(;a&&a.firstChild;)a=a.firstChild;return a}function ig(a,b){var c=hg(a);a=0;for(var d;c;){if(3===c.nodeType){d=a+c.textContent.length;if(a<=b&&d>=b)return{node:c,
offset:b-a};a=d}a:{for(;c;){if(c.nextSibling){c=c.nextSibling;break a}c=c.parentNode}c=void 0}c=hg(c)}}function jg(a,b){return a&&b?a===b?!0:a&&3===a.nodeType?!1:b&&3===b.nodeType?jg(a,b.parentNode):"contains"in a?a.contains(b):a.compareDocumentPosition?!!(a.compareDocumentPosition(b)&16):!1:!1}function kg(){for(var a=window,b=Wd();b instanceof a.HTMLIFrameElement;){try{var c="string"===typeof b.contentWindow.location.href}catch(d){c=!1}if(c)a=b.contentWindow;else break;b=Wd(a.document)}return b}
function Xd(a){var b=a&&a.nodeName&&a.nodeName.toLowerCase();return b&&("input"===b&&("text"===a.type||"search"===a.type||"tel"===a.type||"url"===a.type||"password"===a.type)||"textarea"===b||"true"===a.contentEditable)}function lg(a,b){switch(a){case "button":case "input":case "select":case "textarea":return!!b.autoFocus}return!1}function Yd(a,b){return"textarea"===a||"option"===a||"noscript"===a||"string"===typeof b.children||"number"===typeof b.children||"object"===typeof b.dangerouslySetInnerHTML&&
null!==b.dangerouslySetInnerHTML&&null!=b.dangerouslySetInnerHTML.__html}function kb(a){for(;null!=a;a=a.nextSibling){var b=a.nodeType;if(1===b||3===b)break}return a}function mg(a){a=a.previousSibling;for(var b=0;a;){if(8===a.nodeType){var c=a.data;if(c===ng||c===Zd||c===$d){if(0===b)return a;b--}else c===og&&b++}a=a.previousSibling}return null}function Bb(a){var b=a[Aa];if(b)return b;for(var c=a.parentNode;c;){if(b=c[Lb]||c[Aa]){c=b.alternate;if(null!==b.child||null!==c&&null!==c.child)for(a=mg(a);null!==
a;){if(c=a[Aa])return c;a=mg(a)}return b}a=c;c=a.parentNode}return null}function Hb(a){a=a[Aa]||a[Lb];return!a||5!==a.tag&&6!==a.tag&&13!==a.tag&&3!==a.tag?null:a}function Pa(a){if(5===a.tag||6===a.tag)return a.stateNode;throw Error(k(33));}function ae(a){return a[vc]||null}function pa(a){do a=a.return;while(a&&5!==a.tag);return a?a:null}function pg(a,b){var c=a.stateNode;if(!c)return null;var d=td(c);if(!d)return null;c=d[b];a:switch(b){case "onClick":case "onClickCapture":case "onDoubleClick":case "onDoubleClickCapture":case "onMouseDown":case "onMouseDownCapture":case "onMouseMove":case "onMouseMoveCapture":case "onMouseUp":case "onMouseUpCapture":case "onMouseEnter":(d=
!d.disabled)||(a=a.type,d=!("button"===a||"input"===a||"select"===a||"textarea"===a));a=!d;break a;default:a=!1}if(a)return null;if(c&&"function"!==typeof c)throw Error(k(231,b,typeof c));return c}function qg(a,b,c){if(b=pg(a,c.dispatchConfig.phasedRegistrationNames[b]))c._dispatchListeners=jb(c._dispatchListeners,b),c._dispatchInstances=jb(c._dispatchInstances,a)}function Ji(a){if(a&&a.dispatchConfig.phasedRegistrationNames){for(var b=a._targetInst,c=[];b;)c.push(b),b=pa(b);for(b=c.length;0<b--;)qg(c[b],
"captured",a);for(b=0;b<c.length;b++)qg(c[b],"bubbled",a)}}function be(a,b,c){a&&c&&c.dispatchConfig.registrationName&&(b=pg(a,c.dispatchConfig.registrationName))&&(c._dispatchListeners=jb(c._dispatchListeners,b),c._dispatchInstances=jb(c._dispatchInstances,a))}function Ki(a){a&&a.dispatchConfig.registrationName&&be(a._targetInst,null,a)}function lb(a){Kd(a,Ji)}function rg(){if(wc)return wc;var a,b=ce,c=b.length,d,e="value"in Ba?Ba.value:Ba.textContent,f=e.length;for(a=0;a<c&&b[a]===e[a];a++);var g=
c-a;for(d=1;d<=g&&b[c-d]===e[f-d];d++);return wc=e.slice(a,1<d?1-d:void 0)}function xc(){return!0}function yc(){return!1}function R(a,b,c,d){this.dispatchConfig=a;this._targetInst=b;this.nativeEvent=c;a=this.constructor.Interface;for(var e in a)a.hasOwnProperty(e)&&((b=a[e])?this[e]=b(c):"target"===e?this.target=d:this[e]=c[e]);this.isDefaultPrevented=(null!=c.defaultPrevented?c.defaultPrevented:!1===c.returnValue)?xc:yc;this.isPropagationStopped=yc;return this}function Li(a,b,c,d){if(this.eventPool.length){var e=
this.eventPool.pop();this.call(e,a,b,c,d);return e}return new this(a,b,c,d)}function Mi(a){if(!(a instanceof this))throw Error(k(279));a.destructor();10>this.eventPool.length&&this.eventPool.push(a)}function sg(a){a.eventPool=[];a.getPooled=Li;a.release=Mi}function tg(a,b){switch(a){case "keyup":return-1!==Ni.indexOf(b.keyCode);case "keydown":return 229!==b.keyCode;case "keypress":case "mousedown":case "blur":return!0;default:return!1}}function ug(a){a=a.detail;return"object"===typeof a&&"data"in
a?a.data:null}function Oi(a,b){switch(a){case "compositionend":return ug(b);case "keypress":if(32!==b.which)return null;vg=!0;return wg;case "textInput":return a=b.data,a===wg&&vg?null:a;default:return null}}function Pi(a,b){if(mb)return"compositionend"===a||!de&&tg(a,b)?(a=rg(),wc=ce=Ba=null,mb=!1,a):null;switch(a){case "paste":return null;case "keypress":if(!(b.ctrlKey||b.altKey||b.metaKey)||b.ctrlKey&&b.altKey){if(b.char&&1<b.char.length)return b.char;if(b.which)return String.fromCharCode(b.which)}return null;
case "compositionend":return xg&&"ko"!==b.locale?null:b.data;default:return null}}function yg(a){var b=a&&a.nodeName&&a.nodeName.toLowerCase();return"input"===b?!!Qi[a.type]:"textarea"===b?!0:!1}function zg(a,b,c){a=R.getPooled(Ag.change,a,b,c);a.type="change";sf(c);lb(a);return a}function Ri(a){pc(a)}function zc(a){var b=Pa(a);if(Gf(b))return a}function Si(a,b){if("change"===a)return b}function Bg(){Mb&&(Mb.detachEvent("onpropertychange",Cg),Nb=Mb=null)}function Cg(a){if("value"===a.propertyName&&
zc(Nb))if(a=zg(Nb,a,Ld(a)),Oa)pc(a);else{Oa=!0;try{ee(Ri,a)}finally{Oa=!1,ud()}}}function Ti(a,b,c){"focus"===a?(Bg(),Mb=b,Nb=c,Mb.attachEvent("onpropertychange",Cg)):"blur"===a&&Bg()}function Ui(a,b){if("selectionchange"===a||"keyup"===a||"keydown"===a)return zc(Nb)}function Vi(a,b){if("click"===a)return zc(b)}function Wi(a,b){if("input"===a||"change"===a)return zc(b)}function Xi(a){var b=this.nativeEvent;return b.getModifierState?b.getModifierState(a):(a=Yi[a])?!!b[a]:!1}function fe(a){return Xi}
function Zi(a,b){return a===b&&(0!==a||1/a===1/b)||a!==a&&b!==b}function Ob(a,b){if(Qa(a,b))return!0;if("object"!==typeof a||null===a||"object"!==typeof b||null===b)return!1;var c=Object.keys(a),d=Object.keys(b);if(c.length!==d.length)return!1;for(d=0;d<c.length;d++)if(!$i.call(b,c[d])||!Qa(a[c[d]],b[c[d]]))return!1;return!0}function Dg(a,b){var c=b.window===b?b.document:9===b.nodeType?b:b.ownerDocument;if(ge||null==nb||nb!==Wd(c))return null;c=nb;"selectionStart"in c&&Xd(c)?c={start:c.selectionStart,
end:c.selectionEnd}:(c=(c.ownerDocument&&c.ownerDocument.defaultView||window).getSelection(),c={anchorNode:c.anchorNode,anchorOffset:c.anchorOffset,focusNode:c.focusNode,focusOffset:c.focusOffset});return Pb&&Ob(Pb,c)?null:(Pb=c,a=R.getPooled(Eg.select,he,a,b),a.type="select",a.target=nb,lb(a),a)}function Ac(a){var b=a.keyCode;"charCode"in a?(a=a.charCode,0===a&&13===b&&(a=13)):a=b;10===a&&(a=13);return 32<=a||13===a?a:0}function q(a,b){0>ob||(a.current=ie[ob],ie[ob]=null,ob--)}function y(a,b,c){ob++;
ie[ob]=a.current;a.current=b}function pb(a,b){var c=a.type.contextTypes;if(!c)return Ca;var d=a.stateNode;if(d&&d.__reactInternalMemoizedUnmaskedChildContext===b)return d.__reactInternalMemoizedMaskedChildContext;var e={},f;for(f in c)e[f]=b[f];d&&(a=a.stateNode,a.__reactInternalMemoizedUnmaskedChildContext=b,a.__reactInternalMemoizedMaskedChildContext=e);return e}function N(a){a=a.childContextTypes;return null!==a&&void 0!==a}function Fg(a,b,c){if(B.current!==Ca)throw Error(k(168));y(B,b);y(G,c)}
function Gg(a,b,c){var d=a.stateNode;a=b.childContextTypes;if("function"!==typeof d.getChildContext)return c;d=d.getChildContext();for(var e in d)if(!(e in a))throw Error(k(108,na(b)||"Unknown",e));return M({},c,{},d)}function Bc(a){a=(a=a.stateNode)&&a.__reactInternalMemoizedMergedChildContext||Ca;Ra=B.current;y(B,a);y(G,G.current);return!0}function Hg(a,b,c){var d=a.stateNode;if(!d)throw Error(k(169));c?(a=Gg(a,b,Ra),d.__reactInternalMemoizedMergedChildContext=a,q(G),q(B),y(B,a)):q(G);y(G,c)}function Cc(){switch(aj()){case Dc:return 99;
case Ig:return 98;case Jg:return 97;case Kg:return 96;case Lg:return 95;default:throw Error(k(332));}}function Mg(a){switch(a){case 99:return Dc;case 98:return Ig;case 97:return Jg;case 96:return Kg;case 95:return Lg;default:throw Error(k(332));}}function Da(a,b){a=Mg(a);return bj(a,b)}function Ng(a,b,c){a=Mg(a);return je(a,b,c)}function Og(a){null===qa?(qa=[a],Ec=je(Dc,Pg)):qa.push(a);return Qg}function ha(){if(null!==Ec){var a=Ec;Ec=null;Rg(a)}Pg()}function Pg(){if(!ke&&null!==qa){ke=!0;var a=0;
try{var b=qa;Da(99,function(){for(;a<b.length;a++){var c=b[a];do c=c(!0);while(null!==c)}});qa=null}catch(c){throw null!==qa&&(qa=qa.slice(a+1)),je(Dc,ha),c;}finally{ke=!1}}}function Fc(a,b,c){c/=10;return 1073741821-(((1073741821-a+b/10)/c|0)+1)*c}function aa(a,b){if(a&&a.defaultProps){b=M({},b);a=a.defaultProps;for(var c in a)void 0===b[c]&&(b[c]=a[c])}return b}function le(){Gc=qb=Hc=null}function me(a){var b=Ic.current;q(Ic);a.type._context._currentValue=b}function Sg(a,b){for(;null!==a;){var c=
a.alternate;if(a.childExpirationTime<b)a.childExpirationTime=b,null!==c&&c.childExpirationTime<b&&(c.childExpirationTime=b);else if(null!==c&&c.childExpirationTime<b)c.childExpirationTime=b;else break;a=a.return}}function rb(a,b){Hc=a;Gc=qb=null;a=a.dependencies;null!==a&&null!==a.firstContext&&(a.expirationTime>=b&&(ia=!0),a.firstContext=null)}function W(a,b){if(Gc!==a&&!1!==b&&0!==b){if("number"!==typeof b||1073741823===b)Gc=a,b=1073741823;b={context:a,observedBits:b,next:null};if(null===qb){if(null===
Hc)throw Error(k(308));qb=b;Hc.dependencies={expirationTime:0,firstContext:b,responders:null}}else qb=qb.next=b}return a._currentValue}function ne(a){a.updateQueue={baseState:a.memoizedState,baseQueue:null,shared:{pending:null},effects:null}}function oe(a,b){a=a.updateQueue;b.updateQueue===a&&(b.updateQueue={baseState:a.baseState,baseQueue:a.baseQueue,shared:a.shared,effects:a.effects})}function Ea(a,b){a={expirationTime:a,suspenseConfig:b,tag:Tg,payload:null,callback:null,next:null};return a.next=
a}function Fa(a,b){a=a.updateQueue;if(null!==a){a=a.shared;var c=a.pending;null===c?b.next=b:(b.next=c.next,c.next=b);a.pending=b}}function Ug(a,b){var c=a.alternate;null!==c&&oe(c,a);a=a.updateQueue;c=a.baseQueue;null===c?(a.baseQueue=b.next=b,b.next=b):(b.next=c.next,c.next=b)}function Qb(a,b,c,d){var e=a.updateQueue;Ga=!1;var f=e.baseQueue,g=e.shared.pending;if(null!==g){if(null!==f){var h=f.next;f.next=g.next;g.next=h}f=g;e.shared.pending=null;h=a.alternate;null!==h&&(h=h.updateQueue,null!==h&&
(h.baseQueue=g))}if(null!==f){h=f.next;var m=e.baseState,n=0,k=null,ba=null,l=null;if(null!==h){var p=h;do{g=p.expirationTime;if(g<d){var t={expirationTime:p.expirationTime,suspenseConfig:p.suspenseConfig,tag:p.tag,payload:p.payload,callback:p.callback,next:null};null===l?(ba=l=t,k=m):l=l.next=t;g>n&&(n=g)}else{null!==l&&(l=l.next={expirationTime:1073741823,suspenseConfig:p.suspenseConfig,tag:p.tag,payload:p.payload,callback:p.callback,next:null});Vg(g,p.suspenseConfig);a:{var q=a,r=p;g=b;t=c;switch(r.tag){case 1:q=
r.payload;if("function"===typeof q){m=q.call(t,m,g);break a}m=q;break a;case 3:q.effectTag=q.effectTag&-4097|64;case Tg:q=r.payload;g="function"===typeof q?q.call(t,m,g):q;if(null===g||void 0===g)break a;m=M({},m,g);break a;case Jc:Ga=!0}}null!==p.callback&&(a.effectTag|=32,g=e.effects,null===g?e.effects=[p]:g.push(p))}p=p.next;if(null===p||p===h)if(g=e.shared.pending,null===g)break;else p=f.next=g.next,g.next=h,e.baseQueue=f=g,e.shared.pending=null}while(1)}null===l?k=m:l.next=ba;e.baseState=k;e.baseQueue=
l;Kc(n);a.expirationTime=n;a.memoizedState=m}}function Wg(a,b,c){a=b.effects;b.effects=null;if(null!==a)for(b=0;b<a.length;b++){var d=a[b],e=d.callback;if(null!==e){d.callback=null;d=e;e=c;if("function"!==typeof d)throw Error(k(191,d));d.call(e)}}}function Lc(a,b,c,d){b=a.memoizedState;c=c(d,b);c=null===c||void 0===c?b:M({},b,c);a.memoizedState=c;0===a.expirationTime&&(a.updateQueue.baseState=c)}function Xg(a,b,c,d,e,f,g){a=a.stateNode;return"function"===typeof a.shouldComponentUpdate?a.shouldComponentUpdate(d,
f,g):b.prototype&&b.prototype.isPureReactComponent?!Ob(c,d)||!Ob(e,f):!0}function Yg(a,b,c){var d=!1,e=Ca;var f=b.contextType;"object"===typeof f&&null!==f?f=W(f):(e=N(b)?Ra:B.current,d=b.contextTypes,f=(d=null!==d&&void 0!==d)?pb(a,e):Ca);b=new b(c,f);a.memoizedState=null!==b.state&&void 0!==b.state?b.state:null;b.updater=Mc;a.stateNode=b;b._reactInternalFiber=a;d&&(a=a.stateNode,a.__reactInternalMemoizedUnmaskedChildContext=e,a.__reactInternalMemoizedMaskedChildContext=f);return b}function Zg(a,
b,c,d){a=b.state;"function"===typeof b.componentWillReceiveProps&&b.componentWillReceiveProps(c,d);"function"===typeof b.UNSAFE_componentWillReceiveProps&&b.UNSAFE_componentWillReceiveProps(c,d);b.state!==a&&Mc.enqueueReplaceState(b,b.state,null)}function pe(a,b,c,d){var e=a.stateNode;e.props=c;e.state=a.memoizedState;e.refs=$g;ne(a);var f=b.contextType;"object"===typeof f&&null!==f?e.context=W(f):(f=N(b)?Ra:B.current,e.context=pb(a,f));Qb(a,c,e,d);e.state=a.memoizedState;f=b.getDerivedStateFromProps;
"function"===typeof f&&(Lc(a,b,f,c),e.state=a.memoizedState);"function"===typeof b.getDerivedStateFromProps||"function"===typeof e.getSnapshotBeforeUpdate||"function"!==typeof e.UNSAFE_componentWillMount&&"function"!==typeof e.componentWillMount||(b=e.state,"function"===typeof e.componentWillMount&&e.componentWillMount(),"function"===typeof e.UNSAFE_componentWillMount&&e.UNSAFE_componentWillMount(),b!==e.state&&Mc.enqueueReplaceState(e,e.state,null),Qb(a,c,e,d),e.state=a.memoizedState);"function"===
typeof e.componentDidMount&&(a.effectTag|=4)}function Rb(a,b,c){a=c.ref;if(null!==a&&"function"!==typeof a&&"object"!==typeof a){if(c._owner){c=c._owner;if(c){if(1!==c.tag)throw Error(k(309));var d=c.stateNode}if(!d)throw Error(k(147,a));var e=""+a;if(null!==b&&null!==b.ref&&"function"===typeof b.ref&&b.ref._stringRef===e)return b.ref;b=function(a){var b=d.refs;b===$g&&(b=d.refs={});null===a?delete b[e]:b[e]=a};b._stringRef=e;return b}if("string"!==typeof a)throw Error(k(284));if(!c._owner)throw Error(k(290,
a));}return a}function Nc(a,b){if("textarea"!==a.type)throw Error(k(31,"[object Object]"===Object.prototype.toString.call(b)?"object with keys {"+Object.keys(b).join(", ")+"}":b,""));}function ah(a){function b(b,c){if(a){var d=b.lastEffect;null!==d?(d.nextEffect=c,b.lastEffect=c):b.firstEffect=b.lastEffect=c;c.nextEffect=null;c.effectTag=8}}function c(c,d){if(!a)return null;for(;null!==d;)b(c,d),d=d.sibling;return null}function d(a,b){for(a=new Map;null!==b;)null!==b.key?a.set(b.key,b):a.set(b.index,
b),b=b.sibling;return a}function e(a,b){a=Sa(a,b);a.index=0;a.sibling=null;return a}function f(b,c,d){b.index=d;if(!a)return c;d=b.alternate;if(null!==d)return d=d.index,d<c?(b.effectTag=2,c):d;b.effectTag=2;return c}function g(b){a&&null===b.alternate&&(b.effectTag=2);return b}function h(a,b,c,d){if(null===b||6!==b.tag)return b=qe(c,a.mode,d),b.return=a,b;b=e(b,c);b.return=a;return b}function m(a,b,c,d){if(null!==b&&b.elementType===c.type)return d=e(b,c.props),d.ref=Rb(a,b,c),d.return=a,d;d=Oc(c.type,
c.key,c.props,null,a.mode,d);d.ref=Rb(a,b,c);d.return=a;return d}function n(a,b,c,d){if(null===b||4!==b.tag||b.stateNode.containerInfo!==c.containerInfo||b.stateNode.implementation!==c.implementation)return b=re(c,a.mode,d),b.return=a,b;b=e(b,c.children||[]);b.return=a;return b}function l(a,b,c,d,f){if(null===b||7!==b.tag)return b=Ha(c,a.mode,d,f),b.return=a,b;b=e(b,c);b.return=a;return b}function ba(a,b,c){if("string"===typeof b||"number"===typeof b)return b=qe(""+b,a.mode,c),b.return=a,b;if("object"===
typeof b&&null!==b){switch(b.$$typeof){case Pc:return c=Oc(b.type,b.key,b.props,null,a.mode,c),c.ref=Rb(a,null,b),c.return=a,c;case gb:return b=re(b,a.mode,c),b.return=a,b}if(Qc(b)||zb(b))return b=Ha(b,a.mode,c,null),b.return=a,b;Nc(a,b)}return null}function p(a,b,c,d){var e=null!==b?b.key:null;if("string"===typeof c||"number"===typeof c)return null!==e?null:h(a,b,""+c,d);if("object"===typeof c&&null!==c){switch(c.$$typeof){case Pc:return c.key===e?c.type===Ma?l(a,b,c.props.children,d,e):m(a,b,c,
d):null;case gb:return c.key===e?n(a,b,c,d):null}if(Qc(c)||zb(c))return null!==e?null:l(a,b,c,d,null);Nc(a,c)}return null}function t(a,b,c,d,e){if("string"===typeof d||"number"===typeof d)return a=a.get(c)||null,h(b,a,""+d,e);if("object"===typeof d&&null!==d){switch(d.$$typeof){case Pc:return a=a.get(null===d.key?c:d.key)||null,d.type===Ma?l(b,a,d.props.children,e,d.key):m(b,a,d,e);case gb:return a=a.get(null===d.key?c:d.key)||null,n(b,a,d,e)}if(Qc(d)||zb(d))return a=a.get(c)||null,l(b,a,d,e,null);
Nc(b,d)}return null}function q(e,g,h,m){for(var n=null,k=null,l=g,r=g=0,C=null;null!==l&&r<h.length;r++){l.index>r?(C=l,l=null):C=l.sibling;var O=p(e,l,h[r],m);if(null===O){null===l&&(l=C);break}a&&l&&null===O.alternate&&b(e,l);g=f(O,g,r);null===k?n=O:k.sibling=O;k=O;l=C}if(r===h.length)return c(e,l),n;if(null===l){for(;r<h.length;r++)l=ba(e,h[r],m),null!==l&&(g=f(l,g,r),null===k?n=l:k.sibling=l,k=l);return n}for(l=d(e,l);r<h.length;r++)C=t(l,e,r,h[r],m),null!==C&&(a&&null!==C.alternate&&l.delete(null===
C.key?r:C.key),g=f(C,g,r),null===k?n=C:k.sibling=C,k=C);a&&l.forEach(function(a){return b(e,a)});return n}function w(e,g,h,n){var m=zb(h);if("function"!==typeof m)throw Error(k(150));h=m.call(h);if(null==h)throw Error(k(151));for(var l=m=null,r=g,C=g=0,O=null,v=h.next();null!==r&&!v.done;C++,v=h.next()){r.index>C?(O=r,r=null):O=r.sibling;var q=p(e,r,v.value,n);if(null===q){null===r&&(r=O);break}a&&r&&null===q.alternate&&b(e,r);g=f(q,g,C);null===l?m=q:l.sibling=q;l=q;r=O}if(v.done)return c(e,r),m;
if(null===r){for(;!v.done;C++,v=h.next())v=ba(e,v.value,n),null!==v&&(g=f(v,g,C),null===l?m=v:l.sibling=v,l=v);return m}for(r=d(e,r);!v.done;C++,v=h.next())v=t(r,e,C,v.value,n),null!==v&&(a&&null!==v.alternate&&r.delete(null===v.key?C:v.key),g=f(v,g,C),null===l?m=v:l.sibling=v,l=v);a&&r.forEach(function(a){return b(e,a)});return m}return function(a,d,f,h){var m="object"===typeof f&&null!==f&&f.type===Ma&&null===f.key;m&&(f=f.props.children);var n="object"===typeof f&&null!==f;if(n)switch(f.$$typeof){case Pc:a:{n=
f.key;for(m=d;null!==m;){if(m.key===n){switch(m.tag){case 7:if(f.type===Ma){c(a,m.sibling);d=e(m,f.props.children);d.return=a;a=d;break a}break;default:if(m.elementType===f.type){c(a,m.sibling);d=e(m,f.props);d.ref=Rb(a,m,f);d.return=a;a=d;break a}}c(a,m);break}else b(a,m);m=m.sibling}f.type===Ma?(d=Ha(f.props.children,a.mode,h,f.key),d.return=a,a=d):(h=Oc(f.type,f.key,f.props,null,a.mode,h),h.ref=Rb(a,d,f),h.return=a,a=h)}return g(a);case gb:a:{for(m=f.key;null!==d;){if(d.key===m)if(4===d.tag&&d.stateNode.containerInfo===
f.containerInfo&&d.stateNode.implementation===f.implementation){c(a,d.sibling);d=e(d,f.children||[]);d.return=a;a=d;break a}else{c(a,d);break}else b(a,d);d=d.sibling}d=re(f,a.mode,h);d.return=a;a=d}return g(a)}if("string"===typeof f||"number"===typeof f)return f=""+f,null!==d&&6===d.tag?(c(a,d.sibling),d=e(d,f),d.return=a,a=d):(c(a,d),d=qe(f,a.mode,h),d.return=a,a=d),g(a);if(Qc(f))return q(a,d,f,h);if(zb(f))return w(a,d,f,h);n&&Nc(a,f);if("undefined"===typeof f&&!m)switch(a.tag){case 1:case 0:throw a=
a.type,Error(k(152,a.displayName||a.name||"Component"));}return c(a,d)}}function Ta(a){if(a===Sb)throw Error(k(174));return a}function se(a,b){y(Tb,b);y(Ub,a);y(ja,Sb);a=b.nodeType;switch(a){case 9:case 11:b=(b=b.documentElement)?b.namespaceURI:Hd(null,"");break;default:a=8===a?b.parentNode:b,b=a.namespaceURI||null,a=a.tagName,b=Hd(b,a)}q(ja);y(ja,b)}function tb(a){q(ja);q(Ub);q(Tb)}function bh(a){Ta(Tb.current);var b=Ta(ja.current);var c=Hd(b,a.type);b!==c&&(y(Ub,a),y(ja,c))}function te(a){Ub.current===
a&&(q(ja),q(Ub))}function Rc(a){for(var b=a;null!==b;){if(13===b.tag){var c=b.memoizedState;if(null!==c&&(c=c.dehydrated,null===c||c.data===$d||c.data===Zd))return b}else if(19===b.tag&&void 0!==b.memoizedProps.revealOrder){if(0!==(b.effectTag&64))return b}else if(null!==b.child){b.child.return=b;b=b.child;continue}if(b===a)break;for(;null===b.sibling;){if(null===b.return||b.return===a)return null;b=b.return}b.sibling.return=b.return;b=b.sibling}return null}function ue(a,b){return{responder:a,props:b}}
function S(){throw Error(k(321));}function ve(a,b){if(null===b)return!1;for(var c=0;c<b.length&&c<a.length;c++)if(!Qa(a[c],b[c]))return!1;return!0}function we(a,b,c,d,e,f){Ia=f;z=b;b.memoizedState=null;b.updateQueue=null;b.expirationTime=0;Sc.current=null===a||null===a.memoizedState?dj:ej;a=c(d,e);if(b.expirationTime===Ia){f=0;do{b.expirationTime=0;if(!(25>f))throw Error(k(301));f+=1;J=K=null;b.updateQueue=null;Sc.current=fj;a=c(d,e)}while(b.expirationTime===Ia)}Sc.current=Tc;b=null!==K&&null!==K.next;
Ia=0;J=K=z=null;Uc=!1;if(b)throw Error(k(300));return a}function ub(){var a={memoizedState:null,baseState:null,baseQueue:null,queue:null,next:null};null===J?z.memoizedState=J=a:J=J.next=a;return J}function vb(){if(null===K){var a=z.alternate;a=null!==a?a.memoizedState:null}else a=K.next;var b=null===J?z.memoizedState:J.next;if(null!==b)J=b,K=a;else{if(null===a)throw Error(k(310));K=a;a={memoizedState:K.memoizedState,baseState:K.baseState,baseQueue:K.baseQueue,queue:K.queue,next:null};null===J?z.memoizedState=
J=a:J=J.next=a}return J}function Ua(a,b){return"function"===typeof b?b(a):b}function Vc(a,b,c){b=vb();c=b.queue;if(null===c)throw Error(k(311));c.lastRenderedReducer=a;var d=K,e=d.baseQueue,f=c.pending;if(null!==f){if(null!==e){var g=e.next;e.next=f.next;f.next=g}d.baseQueue=e=f;c.pending=null}if(null!==e){e=e.next;d=d.baseState;var h=g=f=null,m=e;do{var n=m.expirationTime;if(n<Ia){var l={expirationTime:m.expirationTime,suspenseConfig:m.suspenseConfig,action:m.action,eagerReducer:m.eagerReducer,eagerState:m.eagerState,
next:null};null===h?(g=h=l,f=d):h=h.next=l;n>z.expirationTime&&(z.expirationTime=n,Kc(n))}else null!==h&&(h=h.next={expirationTime:1073741823,suspenseConfig:m.suspenseConfig,action:m.action,eagerReducer:m.eagerReducer,eagerState:m.eagerState,next:null}),Vg(n,m.suspenseConfig),d=m.eagerReducer===a?m.eagerState:a(d,m.action);m=m.next}while(null!==m&&m!==e);null===h?f=d:h.next=g;Qa(d,b.memoizedState)||(ia=!0);b.memoizedState=d;b.baseState=f;b.baseQueue=h;c.lastRenderedState=d}return[b.memoizedState,
c.dispatch]}function Wc(a,b,c){b=vb();c=b.queue;if(null===c)throw Error(k(311));c.lastRenderedReducer=a;var d=c.dispatch,e=c.pending,f=b.memoizedState;if(null!==e){c.pending=null;var g=e=e.next;do f=a(f,g.action),g=g.next;while(g!==e);Qa(f,b.memoizedState)||(ia=!0);b.memoizedState=f;null===b.baseQueue&&(b.baseState=f);c.lastRenderedState=f}return[f,d]}function xe(a){var b=ub();"function"===typeof a&&(a=a());b.memoizedState=b.baseState=a;a=b.queue={pending:null,dispatch:null,lastRenderedReducer:Ua,
lastRenderedState:a};a=a.dispatch=ch.bind(null,z,a);return[b.memoizedState,a]}function ye(a,b,c,d){a={tag:a,create:b,destroy:c,deps:d,next:null};b=z.updateQueue;null===b?(b={lastEffect:null},z.updateQueue=b,b.lastEffect=a.next=a):(c=b.lastEffect,null===c?b.lastEffect=a.next=a:(d=c.next,c.next=a,a.next=d,b.lastEffect=a));return a}function dh(a){return vb().memoizedState}function ze(a,b,c,d){var e=ub();z.effectTag|=a;e.memoizedState=ye(1|b,c,void 0,void 0===d?null:d)}function Ae(a,b,c,d){var e=vb();
d=void 0===d?null:d;var f=void 0;if(null!==K){var g=K.memoizedState;f=g.destroy;if(null!==d&&ve(d,g.deps)){ye(b,c,f,d);return}}z.effectTag|=a;e.memoizedState=ye(1|b,c,f,d)}function eh(a,b){return ze(516,4,a,b)}function Xc(a,b){return Ae(516,4,a,b)}function fh(a,b){return Ae(4,2,a,b)}function gh(a,b){if("function"===typeof b)return a=a(),b(a),function(){b(null)};if(null!==b&&void 0!==b)return a=a(),b.current=a,function(){b.current=null}}function hh(a,b,c){c=null!==c&&void 0!==c?c.concat([a]):null;
return Ae(4,2,gh.bind(null,b,a),c)}function Be(a,b){}function ih(a,b){ub().memoizedState=[a,void 0===b?null:b];return a}function Yc(a,b){var c=vb();b=void 0===b?null:b;var d=c.memoizedState;if(null!==d&&null!==b&&ve(b,d[1]))return d[0];c.memoizedState=[a,b];return a}function jh(a,b){var c=vb();b=void 0===b?null:b;var d=c.memoizedState;if(null!==d&&null!==b&&ve(b,d[1]))return d[0];a=a();c.memoizedState=[a,b];return a}function Ce(a,b,c){var d=Cc();Da(98>d?98:d,function(){a(!0)});Da(97<d?97:d,function(){var d=
X.suspense;X.suspense=void 0===b?null:b;try{a(!1),c()}finally{X.suspense=d}})}function ch(a,b,c){var d=ka(),e=Vb.suspense;d=Va(d,a,e);e={expirationTime:d,suspenseConfig:e,action:c,eagerReducer:null,eagerState:null,next:null};var f=b.pending;null===f?e.next=e:(e.next=f.next,f.next=e);b.pending=e;f=a.alternate;if(a===z||null!==f&&f===z)Uc=!0,e.expirationTime=Ia,z.expirationTime=Ia;else{if(0===a.expirationTime&&(null===f||0===f.expirationTime)&&(f=b.lastRenderedReducer,null!==f))try{var g=b.lastRenderedState,
h=f(g,c);e.eagerReducer=f;e.eagerState=h;if(Qa(h,g))return}catch(m){}finally{}Ja(a,d)}}function kh(a,b){var c=la(5,null,null,0);c.elementType="DELETED";c.type="DELETED";c.stateNode=b;c.return=a;c.effectTag=8;null!==a.lastEffect?(a.lastEffect.nextEffect=c,a.lastEffect=c):a.firstEffect=a.lastEffect=c}function lh(a,b){switch(a.tag){case 5:var c=a.type;b=1!==b.nodeType||c.toLowerCase()!==b.nodeName.toLowerCase()?null:b;return null!==b?(a.stateNode=b,!0):!1;case 6:return b=""===a.pendingProps||3!==b.nodeType?
null:b,null!==b?(a.stateNode=b,!0):!1;case 13:return!1;default:return!1}}function De(a){if(Wa){var b=Ka;if(b){var c=b;if(!lh(a,b)){b=kb(c.nextSibling);if(!b||!lh(a,b)){a.effectTag=a.effectTag&-1025|2;Wa=!1;ra=a;return}kh(ra,c)}ra=a;Ka=kb(b.firstChild)}else a.effectTag=a.effectTag&-1025|2,Wa=!1,ra=a}}function mh(a){for(a=a.return;null!==a&&5!==a.tag&&3!==a.tag&&13!==a.tag;)a=a.return;ra=a}function Zc(a){if(a!==ra)return!1;if(!Wa)return mh(a),Wa=!0,!1;var b=a.type;if(5!==a.tag||"head"!==b&&"body"!==
b&&!Yd(b,a.memoizedProps))for(b=Ka;b;)kh(a,b),b=kb(b.nextSibling);mh(a);if(13===a.tag){a=a.memoizedState;a=null!==a?a.dehydrated:null;if(!a)throw Error(k(317));a:{a=a.nextSibling;for(b=0;a;){if(8===a.nodeType){var c=a.data;if(c===og){if(0===b){Ka=kb(a.nextSibling);break a}b--}else c!==ng&&c!==Zd&&c!==$d||b++}a=a.nextSibling}Ka=null}}else Ka=ra?kb(a.stateNode.nextSibling):null;return!0}function Ee(){Ka=ra=null;Wa=!1}function T(a,b,c,d){b.child=null===a?Fe(b,null,c,d):wb(b,a.child,c,d)}function nh(a,
b,c,d,e){c=c.render;var f=b.ref;rb(b,e);d=we(a,b,c,d,f,e);if(null!==a&&!ia)return b.updateQueue=a.updateQueue,b.effectTag&=-517,a.expirationTime<=e&&(a.expirationTime=0),sa(a,b,e);b.effectTag|=1;T(a,b,d,e);return b.child}function oh(a,b,c,d,e,f){if(null===a){var g=c.type;if("function"===typeof g&&!Ge(g)&&void 0===g.defaultProps&&null===c.compare&&void 0===c.defaultProps)return b.tag=15,b.type=g,ph(a,b,g,d,e,f);a=Oc(c.type,null,d,null,b.mode,f);a.ref=b.ref;a.return=b;return b.child=a}g=a.child;if(e<
f&&(e=g.memoizedProps,c=c.compare,c=null!==c?c:Ob,c(e,d)&&a.ref===b.ref))return sa(a,b,f);b.effectTag|=1;a=Sa(g,d);a.ref=b.ref;a.return=b;return b.child=a}function ph(a,b,c,d,e,f){return null!==a&&Ob(a.memoizedProps,d)&&a.ref===b.ref&&(ia=!1,e<f)?(b.expirationTime=a.expirationTime,sa(a,b,f)):He(a,b,c,d,f)}function qh(a,b){var c=b.ref;if(null===a&&null!==c||null!==a&&a.ref!==c)b.effectTag|=128}function He(a,b,c,d,e){var f=N(c)?Ra:B.current;f=pb(b,f);rb(b,e);c=we(a,b,c,d,f,e);if(null!==a&&!ia)return b.updateQueue=
a.updateQueue,b.effectTag&=-517,a.expirationTime<=e&&(a.expirationTime=0),sa(a,b,e);b.effectTag|=1;T(a,b,c,e);return b.child}function rh(a,b,c,d,e){if(N(c)){var f=!0;Bc(b)}else f=!1;rb(b,e);if(null===b.stateNode)null!==a&&(a.alternate=null,b.alternate=null,b.effectTag|=2),Yg(b,c,d),pe(b,c,d,e),d=!0;else if(null===a){var g=b.stateNode,h=b.memoizedProps;g.props=h;var m=g.context,n=c.contextType;"object"===typeof n&&null!==n?n=W(n):(n=N(c)?Ra:B.current,n=pb(b,n));var l=c.getDerivedStateFromProps,k="function"===
typeof l||"function"===typeof g.getSnapshotBeforeUpdate;k||"function"!==typeof g.UNSAFE_componentWillReceiveProps&&"function"!==typeof g.componentWillReceiveProps||(h!==d||m!==n)&&Zg(b,g,d,n);Ga=!1;var p=b.memoizedState;g.state=p;Qb(b,d,g,e);m=b.memoizedState;h!==d||p!==m||G.current||Ga?("function"===typeof l&&(Lc(b,c,l,d),m=b.memoizedState),(h=Ga||Xg(b,c,h,d,p,m,n))?(k||"function"!==typeof g.UNSAFE_componentWillMount&&"function"!==typeof g.componentWillMount||("function"===typeof g.componentWillMount&&
g.componentWillMount(),"function"===typeof g.UNSAFE_componentWillMount&&g.UNSAFE_componentWillMount()),"function"===typeof g.componentDidMount&&(b.effectTag|=4)):("function"===typeof g.componentDidMount&&(b.effectTag|=4),b.memoizedProps=d,b.memoizedState=m),g.props=d,g.state=m,g.context=n,d=h):("function"===typeof g.componentDidMount&&(b.effectTag|=4),d=!1)}else g=b.stateNode,oe(a,b),h=b.memoizedProps,g.props=b.type===b.elementType?h:aa(b.type,h),m=g.context,n=c.contextType,"object"===typeof n&&null!==
n?n=W(n):(n=N(c)?Ra:B.current,n=pb(b,n)),l=c.getDerivedStateFromProps,(k="function"===typeof l||"function"===typeof g.getSnapshotBeforeUpdate)||"function"!==typeof g.UNSAFE_componentWillReceiveProps&&"function"!==typeof g.componentWillReceiveProps||(h!==d||m!==n)&&Zg(b,g,d,n),Ga=!1,m=b.memoizedState,g.state=m,Qb(b,d,g,e),p=b.memoizedState,h!==d||m!==p||G.current||Ga?("function"===typeof l&&(Lc(b,c,l,d),p=b.memoizedState),(l=Ga||Xg(b,c,h,d,m,p,n))?(k||"function"!==typeof g.UNSAFE_componentWillUpdate&&
"function"!==typeof g.componentWillUpdate||("function"===typeof g.componentWillUpdate&&g.componentWillUpdate(d,p,n),"function"===typeof g.UNSAFE_componentWillUpdate&&g.UNSAFE_componentWillUpdate(d,p,n)),"function"===typeof g.componentDidUpdate&&(b.effectTag|=4),"function"===typeof g.getSnapshotBeforeUpdate&&(b.effectTag|=256)):("function"!==typeof g.componentDidUpdate||h===a.memoizedProps&&m===a.memoizedState||(b.effectTag|=4),"function"!==typeof g.getSnapshotBeforeUpdate||h===a.memoizedProps&&m===
a.memoizedState||(b.effectTag|=256),b.memoizedProps=d,b.memoizedState=p),g.props=d,g.state=p,g.context=n,d=l):("function"!==typeof g.componentDidUpdate||h===a.memoizedProps&&m===a.memoizedState||(b.effectTag|=4),"function"!==typeof g.getSnapshotBeforeUpdate||h===a.memoizedProps&&m===a.memoizedState||(b.effectTag|=256),d=!1);return Ie(a,b,c,d,f,e)}function Ie(a,b,c,d,e,f){qh(a,b);var g=0!==(b.effectTag&64);if(!d&&!g)return e&&Hg(b,c,!1),sa(a,b,f);d=b.stateNode;gj.current=b;var h=g&&"function"!==typeof c.getDerivedStateFromError?
null:d.render();b.effectTag|=1;null!==a&&g?(b.child=wb(b,a.child,null,f),b.child=wb(b,null,h,f)):T(a,b,h,f);b.memoizedState=d.state;e&&Hg(b,c,!0);return b.child}function sh(a){var b=a.stateNode;b.pendingContext?Fg(a,b.pendingContext,b.pendingContext!==b.context):b.context&&Fg(a,b.context,!1);se(a,b.containerInfo)}function th(a,b,c){var d=b.mode,e=b.pendingProps,f=D.current,g=!1,h;(h=0!==(b.effectTag&64))||(h=0!==(f&2)&&(null===a||null!==a.memoizedState));h?(g=!0,b.effectTag&=-65):null!==a&&null===
a.memoizedState||void 0===e.fallback||!0===e.unstable_avoidThisFallback||(f|=1);y(D,f&1);if(null===a){void 0!==e.fallback&&De(b);if(g){g=e.fallback;e=Ha(null,d,0,null);e.return=b;if(0===(b.mode&2))for(a=null!==b.memoizedState?b.child.child:b.child,e.child=a;null!==a;)a.return=e,a=a.sibling;c=Ha(g,d,c,null);c.return=b;e.sibling=c;b.memoizedState=Je;b.child=e;return c}d=e.children;b.memoizedState=null;return b.child=Fe(b,null,d,c)}if(null!==a.memoizedState){a=a.child;d=a.sibling;if(g){e=e.fallback;
c=Sa(a,a.pendingProps);c.return=b;if(0===(b.mode&2)&&(g=null!==b.memoizedState?b.child.child:b.child,g!==a.child))for(c.child=g;null!==g;)g.return=c,g=g.sibling;d=Sa(d,e);d.return=b;c.sibling=d;c.childExpirationTime=0;b.memoizedState=Je;b.child=c;return d}c=wb(b,a.child,e.children,c);b.memoizedState=null;return b.child=c}a=a.child;if(g){g=e.fallback;e=Ha(null,d,0,null);e.return=b;e.child=a;null!==a&&(a.return=e);if(0===(b.mode&2))for(a=null!==b.memoizedState?b.child.child:b.child,e.child=a;null!==
a;)a.return=e,a=a.sibling;c=Ha(g,d,c,null);c.return=b;e.sibling=c;c.effectTag|=2;e.childExpirationTime=0;b.memoizedState=Je;b.child=e;return c}b.memoizedState=null;return b.child=wb(b,a,e.children,c)}function uh(a,b){a.expirationTime<b&&(a.expirationTime=b);var c=a.alternate;null!==c&&c.expirationTime<b&&(c.expirationTime=b);Sg(a.return,b)}function Ke(a,b,c,d,e,f){var g=a.memoizedState;null===g?a.memoizedState={isBackwards:b,rendering:null,renderingStartTime:0,last:d,tail:c,tailExpiration:0,tailMode:e,
lastEffect:f}:(g.isBackwards=b,g.rendering=null,g.renderingStartTime=0,g.last=d,g.tail=c,g.tailExpiration=0,g.tailMode=e,g.lastEffect=f)}function vh(a,b,c){var d=b.pendingProps,e=d.revealOrder,f=d.tail;T(a,b,d.children,c);d=D.current;if(0!==(d&2))d=d&1|2,b.effectTag|=64;else{if(null!==a&&0!==(a.effectTag&64))a:for(a=b.child;null!==a;){if(13===a.tag)null!==a.memoizedState&&uh(a,c);else if(19===a.tag)uh(a,c);else if(null!==a.child){a.child.return=a;a=a.child;continue}if(a===b)break a;for(;null===a.sibling;){if(null===
a.return||a.return===b)break a;a=a.return}a.sibling.return=a.return;a=a.sibling}d&=1}y(D,d);if(0===(b.mode&2))b.memoizedState=null;else switch(e){case "forwards":c=b.child;for(e=null;null!==c;)a=c.alternate,null!==a&&null===Rc(a)&&(e=c),c=c.sibling;c=e;null===c?(e=b.child,b.child=null):(e=c.sibling,c.sibling=null);Ke(b,!1,e,c,f,b.lastEffect);break;case "backwards":c=null;e=b.child;for(b.child=null;null!==e;){a=e.alternate;if(null!==a&&null===Rc(a)){b.child=e;break}a=e.sibling;e.sibling=c;c=e;e=a}Ke(b,
!0,c,null,f,b.lastEffect);break;case "together":Ke(b,!1,null,null,void 0,b.lastEffect);break;default:b.memoizedState=null}return b.child}function sa(a,b,c){null!==a&&(b.dependencies=a.dependencies);var d=b.expirationTime;0!==d&&Kc(d);if(b.childExpirationTime<c)return null;if(null!==a&&b.child!==a.child)throw Error(k(153));if(null!==b.child){a=b.child;c=Sa(a,a.pendingProps);b.child=c;for(c.return=b;null!==a.sibling;)a=a.sibling,c=c.sibling=Sa(a,a.pendingProps),c.return=b;c.sibling=null}return b.child}
function $c(a,b){switch(a.tailMode){case "hidden":b=a.tail;for(var c=null;null!==b;)null!==b.alternate&&(c=b),b=b.sibling;null===c?a.tail=null:c.sibling=null;break;case "collapsed":c=a.tail;for(var d=null;null!==c;)null!==c.alternate&&(d=c),c=c.sibling;null===d?b||null===a.tail?a.tail=null:a.tail.sibling=null:d.sibling=null}}function hj(a,b,c){var d=b.pendingProps;switch(b.tag){case 2:case 16:case 15:case 0:case 11:case 7:case 8:case 12:case 9:case 14:return null;case 1:return N(b.type)&&(q(G),q(B)),
null;case 3:return tb(),q(G),q(B),c=b.stateNode,c.pendingContext&&(c.context=c.pendingContext,c.pendingContext=null),null!==a&&null!==a.child||!Zc(b)||(b.effectTag|=4),wh(b),null;case 5:te(b);c=Ta(Tb.current);var e=b.type;if(null!==a&&null!=b.stateNode)ij(a,b,e,d,c),a.ref!==b.ref&&(b.effectTag|=128);else{if(!d){if(null===b.stateNode)throw Error(k(166));return null}a=Ta(ja.current);if(Zc(b)){d=b.stateNode;e=b.type;var f=b.memoizedProps;d[Aa]=b;d[vc]=f;switch(e){case "iframe":case "object":case "embed":w("load",
d);break;case "video":case "audio":for(a=0;a<Db.length;a++)w(Db[a],d);break;case "source":w("error",d);break;case "img":case "image":case "link":w("error",d);w("load",d);break;case "form":w("reset",d);w("submit",d);break;case "details":w("toggle",d);break;case "input":Hf(d,f);w("invalid",d);oa(c,"onChange");break;case "select":d._wrapperState={wasMultiple:!!f.multiple};w("invalid",d);oa(c,"onChange");break;case "textarea":Kf(d,f),w("invalid",d),oa(c,"onChange")}Ud(e,f);a=null;for(var g in f)if(f.hasOwnProperty(g)){var h=
f[g];"children"===g?"string"===typeof h?d.textContent!==h&&(a=["children",h]):"number"===typeof h&&d.textContent!==""+h&&(a=["children",""+h]):db.hasOwnProperty(g)&&null!=h&&oa(c,g)}switch(e){case "input":mc(d);Jf(d,f,!0);break;case "textarea":mc(d);Mf(d);break;case "select":case "option":break;default:"function"===typeof f.onClick&&(d.onclick=uc)}c=a;b.updateQueue=c;null!==c&&(b.effectTag|=4)}else{g=9===c.nodeType?c:c.ownerDocument;"http://www.w3.org/1999/xhtml"===a&&(a=Nf(e));"http://www.w3.org/1999/xhtml"===
a?"script"===e?(a=g.createElement("div"),a.innerHTML="<script>\x3c/script>",a=a.removeChild(a.firstChild)):"string"===typeof d.is?a=g.createElement(e,{is:d.is}):(a=g.createElement(e),"select"===e&&(g=a,d.multiple?g.multiple=!0:d.size&&(g.size=d.size))):a=g.createElementNS(a,e);a[Aa]=b;a[vc]=d;jj(a,b,!1,!1);b.stateNode=a;g=Vd(e,d);switch(e){case "iframe":case "object":case "embed":w("load",a);h=d;break;case "video":case "audio":for(h=0;h<Db.length;h++)w(Db[h],a);h=d;break;case "source":w("error",a);
h=d;break;case "img":case "image":case "link":w("error",a);w("load",a);h=d;break;case "form":w("reset",a);w("submit",a);h=d;break;case "details":w("toggle",a);h=d;break;case "input":Hf(a,d);h=Cd(a,d);w("invalid",a);oa(c,"onChange");break;case "option":h=Fd(a,d);break;case "select":a._wrapperState={wasMultiple:!!d.multiple};h=M({},d,{value:void 0});w("invalid",a);oa(c,"onChange");break;case "textarea":Kf(a,d);h=Gd(a,d);w("invalid",a);oa(c,"onChange");break;default:h=d}Ud(e,h);var m=h;for(f in m)if(m.hasOwnProperty(f)){var n=
m[f];"style"===f?gg(a,n):"dangerouslySetInnerHTML"===f?(n=n?n.__html:void 0,null!=n&&xh(a,n)):"children"===f?"string"===typeof n?("textarea"!==e||""!==n)&&Wb(a,n):"number"===typeof n&&Wb(a,""+n):"suppressContentEditableWarning"!==f&&"suppressHydrationWarning"!==f&&"autoFocus"!==f&&(db.hasOwnProperty(f)?null!=n&&oa(c,f):null!=n&&xd(a,f,n,g))}switch(e){case "input":mc(a);Jf(a,d,!1);break;case "textarea":mc(a);Mf(a);break;case "option":null!=d.value&&a.setAttribute("value",""+va(d.value));break;case "select":a.multiple=
!!d.multiple;c=d.value;null!=c?hb(a,!!d.multiple,c,!1):null!=d.defaultValue&&hb(a,!!d.multiple,d.defaultValue,!0);break;default:"function"===typeof h.onClick&&(a.onclick=uc)}lg(e,d)&&(b.effectTag|=4)}null!==b.ref&&(b.effectTag|=128)}return null;case 6:if(a&&null!=b.stateNode)kj(a,b,a.memoizedProps,d);else{if("string"!==typeof d&&null===b.stateNode)throw Error(k(166));c=Ta(Tb.current);Ta(ja.current);Zc(b)?(c=b.stateNode,d=b.memoizedProps,c[Aa]=b,c.nodeValue!==d&&(b.effectTag|=4)):(c=(9===c.nodeType?
c:c.ownerDocument).createTextNode(d),c[Aa]=b,b.stateNode=c)}return null;case 13:q(D);d=b.memoizedState;if(0!==(b.effectTag&64))return b.expirationTime=c,b;c=null!==d;d=!1;null===a?void 0!==b.memoizedProps.fallback&&Zc(b):(e=a.memoizedState,d=null!==e,c||null===e||(e=a.child.sibling,null!==e&&(f=b.firstEffect,null!==f?(b.firstEffect=e,e.nextEffect=f):(b.firstEffect=b.lastEffect=e,e.nextEffect=null),e.effectTag=8)));if(c&&!d&&0!==(b.mode&2))if(null===a&&!0!==b.memoizedProps.unstable_avoidThisFallback||
0!==(D.current&1))F===Xa&&(F=ad);else{if(F===Xa||F===ad)F=bd;0!==Xb&&null!==U&&(Ya(U,P),yh(U,Xb))}if(c||d)b.effectTag|=4;return null;case 4:return tb(),wh(b),null;case 10:return me(b),null;case 17:return N(b.type)&&(q(G),q(B)),null;case 19:q(D);d=b.memoizedState;if(null===d)return null;e=0!==(b.effectTag&64);f=d.rendering;if(null===f)if(e)$c(d,!1);else{if(F!==Xa||null!==a&&0!==(a.effectTag&64))for(f=b.child;null!==f;){a=Rc(f);if(null!==a){b.effectTag|=64;$c(d,!1);e=a.updateQueue;null!==e&&(b.updateQueue=
e,b.effectTag|=4);null===d.lastEffect&&(b.firstEffect=null);b.lastEffect=d.lastEffect;for(d=b.child;null!==d;)e=d,f=c,e.effectTag&=2,e.nextEffect=null,e.firstEffect=null,e.lastEffect=null,a=e.alternate,null===a?(e.childExpirationTime=0,e.expirationTime=f,e.child=null,e.memoizedProps=null,e.memoizedState=null,e.updateQueue=null,e.dependencies=null):(e.childExpirationTime=a.childExpirationTime,e.expirationTime=a.expirationTime,e.child=a.child,e.memoizedProps=a.memoizedProps,e.memoizedState=a.memoizedState,
e.updateQueue=a.updateQueue,f=a.dependencies,e.dependencies=null===f?null:{expirationTime:f.expirationTime,firstContext:f.firstContext,responders:f.responders}),d=d.sibling;y(D,D.current&1|2);return b.child}f=f.sibling}}else{if(!e)if(a=Rc(f),null!==a){if(b.effectTag|=64,e=!0,c=a.updateQueue,null!==c&&(b.updateQueue=c,b.effectTag|=4),$c(d,!0),null===d.tail&&"hidden"===d.tailMode&&!f.alternate)return b=b.lastEffect=d.lastEffect,null!==b&&(b.nextEffect=null),null}else 2*Y()-d.renderingStartTime>d.tailExpiration&&
1<c&&(b.effectTag|=64,e=!0,$c(d,!1),b.expirationTime=b.childExpirationTime=c-1);d.isBackwards?(f.sibling=b.child,b.child=f):(c=d.last,null!==c?c.sibling=f:b.child=f,d.last=f)}return null!==d.tail?(0===d.tailExpiration&&(d.tailExpiration=Y()+500),c=d.tail,d.rendering=c,d.tail=c.sibling,d.lastEffect=b.lastEffect,d.renderingStartTime=Y(),c.sibling=null,b=D.current,y(D,e?b&1|2:b&1),c):null}throw Error(k(156,b.tag));}function lj(a,b){switch(a.tag){case 1:return N(a.type)&&(q(G),q(B)),b=a.effectTag,b&4096?
(a.effectTag=b&-4097|64,a):null;case 3:tb();q(G);q(B);b=a.effectTag;if(0!==(b&64))throw Error(k(285));a.effectTag=b&-4097|64;return a;case 5:return te(a),null;case 13:return q(D),b=a.effectTag,b&4096?(a.effectTag=b&-4097|64,a):null;case 19:return q(D),null;case 4:return tb(),null;case 10:return me(a),null;default:return null}}function Le(a,b){return{value:a,source:b,stack:Bd(b)}}function Me(a,b){var c=b.source,d=b.stack;null===d&&null!==c&&(d=Bd(c));null!==c&&na(c.type);b=b.value;null!==a&&1===a.tag&&
na(a.type);try{console.error(b)}catch(e){setTimeout(function(){throw e;})}}function mj(a,b){try{b.props=a.memoizedProps,b.state=a.memoizedState,b.componentWillUnmount()}catch(c){Za(a,c)}}function zh(a){var b=a.ref;if(null!==b)if("function"===typeof b)try{b(null)}catch(c){Za(a,c)}else b.current=null}function nj(a,b){switch(b.tag){case 0:case 11:case 15:case 22:return;case 1:if(b.effectTag&256&&null!==a){var c=a.memoizedProps,d=a.memoizedState;a=b.stateNode;b=a.getSnapshotBeforeUpdate(b.elementType===
b.type?c:aa(b.type,c),d);a.__reactInternalSnapshotBeforeUpdate=b}return;case 3:case 5:case 6:case 4:case 17:return}throw Error(k(163));}function Ah(a,b){b=b.updateQueue;b=null!==b?b.lastEffect:null;if(null!==b){var c=b=b.next;do{if((c.tag&a)===a){var d=c.destroy;c.destroy=void 0;void 0!==d&&d()}c=c.next}while(c!==b)}}function Bh(a,b){b=b.updateQueue;b=null!==b?b.lastEffect:null;if(null!==b){var c=b=b.next;do{if((c.tag&a)===a){var d=c.create;c.destroy=d()}c=c.next}while(c!==b)}}function oj(a,b,c,d){switch(c.tag){case 0:case 11:case 15:case 22:Bh(3,
c);return;case 1:a=c.stateNode;c.effectTag&4&&(null===b?a.componentDidMount():(d=c.elementType===c.type?b.memoizedProps:aa(c.type,b.memoizedProps),a.componentDidUpdate(d,b.memoizedState,a.__reactInternalSnapshotBeforeUpdate)));b=c.updateQueue;null!==b&&Wg(c,b,a);return;case 3:b=c.updateQueue;if(null!==b){a=null;if(null!==c.child)switch(c.child.tag){case 5:a=c.child.stateNode;break;case 1:a=c.child.stateNode}Wg(c,b,a)}return;case 5:a=c.stateNode;null===b&&c.effectTag&4&&lg(c.type,c.memoizedProps)&&
a.focus();return;case 6:return;case 4:return;case 12:return;case 13:null===c.memoizedState&&(c=c.alternate,null!==c&&(c=c.memoizedState,null!==c&&(c=c.dehydrated,null!==c&&bg(c))));return;case 19:case 17:case 20:case 21:return}throw Error(k(163));}function Ch(a,b,c){"function"===typeof Ne&&Ne(b);switch(b.tag){case 0:case 11:case 14:case 15:case 22:a=b.updateQueue;if(null!==a&&(a=a.lastEffect,null!==a)){var d=a.next;Da(97<c?97:c,function(){var a=d;do{var c=a.destroy;if(void 0!==c){var g=b;try{c()}catch(h){Za(g,
h)}}a=a.next}while(a!==d)})}break;case 1:zh(b);c=b.stateNode;"function"===typeof c.componentWillUnmount&&mj(b,c);break;case 5:zh(b);break;case 4:Dh(a,b,c)}}function Eh(a){var b=a.alternate;a.return=null;a.child=null;a.memoizedState=null;a.updateQueue=null;a.dependencies=null;a.alternate=null;a.firstEffect=null;a.lastEffect=null;a.pendingProps=null;a.memoizedProps=null;a.stateNode=null;null!==b&&Eh(b)}function Fh(a){return 5===a.tag||3===a.tag||4===a.tag}function Gh(a){a:{for(var b=a.return;null!==
b;){if(Fh(b)){var c=b;break a}b=b.return}throw Error(k(160));}b=c.stateNode;switch(c.tag){case 5:var d=!1;break;case 3:b=b.containerInfo;d=!0;break;case 4:b=b.containerInfo;d=!0;break;default:throw Error(k(161));}c.effectTag&16&&(Wb(b,""),c.effectTag&=-17);a:b:for(c=a;;){for(;null===c.sibling;){if(null===c.return||Fh(c.return)){c=null;break a}c=c.return}c.sibling.return=c.return;for(c=c.sibling;5!==c.tag&&6!==c.tag&&18!==c.tag;){if(c.effectTag&2)continue b;if(null===c.child||4===c.tag)continue b;
else c.child.return=c,c=c.child}if(!(c.effectTag&2)){c=c.stateNode;break a}}d?Oe(a,c,b):Pe(a,c,b)}function Oe(a,b,c){var d=a.tag,e=5===d||6===d;if(e)a=e?a.stateNode:a.stateNode.instance,b?8===c.nodeType?c.parentNode.insertBefore(a,b):c.insertBefore(a,b):(8===c.nodeType?(b=c.parentNode,b.insertBefore(a,c)):(b=c,b.appendChild(a)),c=c._reactRootContainer,null!==c&&void 0!==c||null!==b.onclick||(b.onclick=uc));else if(4!==d&&(a=a.child,null!==a))for(Oe(a,b,c),a=a.sibling;null!==a;)Oe(a,b,c),a=a.sibling}
function Pe(a,b,c){var d=a.tag,e=5===d||6===d;if(e)a=e?a.stateNode:a.stateNode.instance,b?c.insertBefore(a,b):c.appendChild(a);else if(4!==d&&(a=a.child,null!==a))for(Pe(a,b,c),a=a.sibling;null!==a;)Pe(a,b,c),a=a.sibling}function Dh(a,b,c){for(var d=b,e=!1,f,g;;){if(!e){e=d.return;a:for(;;){if(null===e)throw Error(k(160));f=e.stateNode;switch(e.tag){case 5:g=!1;break a;case 3:f=f.containerInfo;g=!0;break a;case 4:f=f.containerInfo;g=!0;break a}e=e.return}e=!0}if(5===d.tag||6===d.tag){a:for(var h=
a,m=d,n=c,l=m;;)if(Ch(h,l,n),null!==l.child&&4!==l.tag)l.child.return=l,l=l.child;else{if(l===m)break a;for(;null===l.sibling;){if(null===l.return||l.return===m)break a;l=l.return}l.sibling.return=l.return;l=l.sibling}g?(h=f,m=d.stateNode,8===h.nodeType?h.parentNode.removeChild(m):h.removeChild(m)):f.removeChild(d.stateNode)}else if(4===d.tag){if(null!==d.child){f=d.stateNode.containerInfo;g=!0;d.child.return=d;d=d.child;continue}}else if(Ch(a,d,c),null!==d.child){d.child.return=d;d=d.child;continue}if(d===
b)break;for(;null===d.sibling;){if(null===d.return||d.return===b)return;d=d.return;4===d.tag&&(e=!1)}d.sibling.return=d.return;d=d.sibling}}function Qe(a,b){switch(b.tag){case 0:case 11:case 14:case 15:case 22:Ah(3,b);return;case 1:return;case 5:var c=b.stateNode;if(null!=c){var d=b.memoizedProps,e=null!==a?a.memoizedProps:d;a=b.type;var f=b.updateQueue;b.updateQueue=null;if(null!==f){c[vc]=d;"input"===a&&"radio"===d.type&&null!=d.name&&If(c,d);Vd(a,e);b=Vd(a,d);for(e=0;e<f.length;e+=2){var g=f[e],
h=f[e+1];"style"===g?gg(c,h):"dangerouslySetInnerHTML"===g?xh(c,h):"children"===g?Wb(c,h):xd(c,g,h,b)}switch(a){case "input":Dd(c,d);break;case "textarea":Lf(c,d);break;case "select":b=c._wrapperState.wasMultiple,c._wrapperState.wasMultiple=!!d.multiple,a=d.value,null!=a?hb(c,!!d.multiple,a,!1):b!==!!d.multiple&&(null!=d.defaultValue?hb(c,!!d.multiple,d.defaultValue,!0):hb(c,!!d.multiple,d.multiple?[]:"",!1))}}}return;case 6:if(null===b.stateNode)throw Error(k(162));b.stateNode.nodeValue=b.memoizedProps;
return;case 3:b=b.stateNode;b.hydrate&&(b.hydrate=!1,bg(b.containerInfo));return;case 12:return;case 13:c=b;null===b.memoizedState?d=!1:(d=!0,c=b.child,Re=Y());if(null!==c)a:for(a=c;;){if(5===a.tag)f=a.stateNode,d?(f=f.style,"function"===typeof f.setProperty?f.setProperty("display","none","important"):f.display="none"):(f=a.stateNode,e=a.memoizedProps.style,e=void 0!==e&&null!==e&&e.hasOwnProperty("display")?e.display:null,f.style.display=fg("display",e));else if(6===a.tag)a.stateNode.nodeValue=d?
"":a.memoizedProps;else if(13===a.tag&&null!==a.memoizedState&&null===a.memoizedState.dehydrated){f=a.child.sibling;f.return=a;a=f;continue}else if(null!==a.child){a.child.return=a;a=a.child;continue}if(a===c)break;for(;null===a.sibling;){if(null===a.return||a.return===c)break a;a=a.return}a.sibling.return=a.return;a=a.sibling}Hh(b);return;case 19:Hh(b);return;case 17:return}throw Error(k(163));}function Hh(a){var b=a.updateQueue;if(null!==b){a.updateQueue=null;var c=a.stateNode;null===c&&(c=a.stateNode=
new pj);b.forEach(function(b){var d=qj.bind(null,a,b);c.has(b)||(c.add(b),b.then(d,d))})}}function Ih(a,b,c){c=Ea(c,null);c.tag=3;c.payload={element:null};var d=b.value;c.callback=function(){cd||(cd=!0,Se=d);Me(a,b)};return c}function Jh(a,b,c){c=Ea(c,null);c.tag=3;var d=a.type.getDerivedStateFromError;if("function"===typeof d){var e=b.value;c.payload=function(){Me(a,b);return d(e)}}var f=a.stateNode;null!==f&&"function"===typeof f.componentDidCatch&&(c.callback=function(){"function"!==typeof d&&
(null===La?La=new Set([this]):La.add(this),Me(a,b));var c=b.stack;this.componentDidCatch(b.value,{componentStack:null!==c?c:""})});return c}function ka(){return(p&(ca|ma))!==H?1073741821-(Y()/10|0):0!==dd?dd:dd=1073741821-(Y()/10|0)}function Va(a,b,c){b=b.mode;if(0===(b&2))return 1073741823;var d=Cc();if(0===(b&4))return 99===d?1073741823:1073741822;if((p&ca)!==H)return P;if(null!==c)a=Fc(a,c.timeoutMs|0||5E3,250);else switch(d){case 99:a=1073741823;break;case 98:a=Fc(a,150,100);break;case 97:case 96:a=
Fc(a,5E3,250);break;case 95:a=2;break;default:throw Error(k(326));}null!==U&&a===P&&--a;return a}function ed(a,b){a.expirationTime<b&&(a.expirationTime=b);var c=a.alternate;null!==c&&c.expirationTime<b&&(c.expirationTime=b);var d=a.return,e=null;if(null===d&&3===a.tag)e=a.stateNode;else for(;null!==d;){c=d.alternate;d.childExpirationTime<b&&(d.childExpirationTime=b);null!==c&&c.childExpirationTime<b&&(c.childExpirationTime=b);if(null===d.return&&3===d.tag){e=d.stateNode;break}d=d.return}null!==e&&
(U===e&&(Kc(b),F===bd&&Ya(e,P)),yh(e,b));return e}function fd(a){var b=a.lastExpiredTime;if(0!==b)return b;b=a.firstPendingTime;if(!Kh(a,b))return b;var c=a.lastPingedTime;a=a.nextKnownPendingLevel;a=c>a?c:a;return 2>=a&&b!==a?0:a}function V(a){if(0!==a.lastExpiredTime)a.callbackExpirationTime=1073741823,a.callbackPriority=99,a.callbackNode=Og(Te.bind(null,a));else{var b=fd(a),c=a.callbackNode;if(0===b)null!==c&&(a.callbackNode=null,a.callbackExpirationTime=0,a.callbackPriority=90);else{var d=ka();
1073741823===b?d=99:1===b||2===b?d=95:(d=10*(1073741821-b)-10*(1073741821-d),d=0>=d?99:250>=d?98:5250>=d?97:95);if(null!==c){var e=a.callbackPriority;if(a.callbackExpirationTime===b&&e>=d)return;c!==Qg&&Rg(c)}a.callbackExpirationTime=b;a.callbackPriority=d;b=1073741823===b?Og(Te.bind(null,a)):Ng(d,Lh.bind(null,a),{timeout:10*(1073741821-b)-Y()});a.callbackNode=b}}}function Lh(a,b){dd=0;if(b)return b=ka(),Ue(a,b),V(a),null;var c=fd(a);if(0!==c){b=a.callbackNode;if((p&(ca|ma))!==H)throw Error(k(327));
xb();a===U&&c===P||$a(a,c);if(null!==t){var d=p;p|=ca;var e=Mh();do try{rj();break}catch(h){Nh(a,h)}while(1);le();p=d;gd.current=e;if(F===hd)throw b=id,$a(a,c),Ya(a,c),V(a),b;if(null===t)switch(e=a.finishedWork=a.current.alternate,a.finishedExpirationTime=c,d=F,U=null,d){case Xa:case hd:throw Error(k(345));case Oh:Ue(a,2<c?2:c);break;case ad:Ya(a,c);d=a.lastSuspendedTime;c===d&&(a.nextKnownPendingLevel=Ve(e));if(1073741823===ta&&(e=Re+Ph-Y(),10<e)){if(jd){var f=a.lastPingedTime;if(0===f||f>=c){a.lastPingedTime=
c;$a(a,c);break}}f=fd(a);if(0!==f&&f!==c)break;if(0!==d&&d!==c){a.lastPingedTime=d;break}a.timeoutHandle=We(ab.bind(null,a),e);break}ab(a);break;case bd:Ya(a,c);d=a.lastSuspendedTime;c===d&&(a.nextKnownPendingLevel=Ve(e));if(jd&&(e=a.lastPingedTime,0===e||e>=c)){a.lastPingedTime=c;$a(a,c);break}e=fd(a);if(0!==e&&e!==c)break;if(0!==d&&d!==c){a.lastPingedTime=d;break}1073741823!==Yb?d=10*(1073741821-Yb)-Y():1073741823===ta?d=0:(d=10*(1073741821-ta)-5E3,e=Y(),c=10*(1073741821-c)-e,d=e-d,0>d&&(d=0),d=
(120>d?120:480>d?480:1080>d?1080:1920>d?1920:3E3>d?3E3:4320>d?4320:1960*sj(d/1960))-d,c<d&&(d=c));if(10<d){a.timeoutHandle=We(ab.bind(null,a),d);break}ab(a);break;case Xe:if(1073741823!==ta&&null!==kd){f=ta;var g=kd;d=g.busyMinDurationMs|0;0>=d?d=0:(e=g.busyDelayMs|0,f=Y()-(10*(1073741821-f)-(g.timeoutMs|0||5E3)),d=f<=e?0:e+d-f);if(10<d){Ya(a,c);a.timeoutHandle=We(ab.bind(null,a),d);break}}ab(a);break;default:throw Error(k(329));}V(a);if(a.callbackNode===b)return Lh.bind(null,a)}}return null}function Te(a){var b=
a.lastExpiredTime;b=0!==b?b:1073741823;if((p&(ca|ma))!==H)throw Error(k(327));xb();a===U&&b===P||$a(a,b);if(null!==t){var c=p;p|=ca;var d=Mh();do try{tj();break}catch(e){Nh(a,e)}while(1);le();p=c;gd.current=d;if(F===hd)throw c=id,$a(a,b),Ya(a,b),V(a),c;if(null!==t)throw Error(k(261));a.finishedWork=a.current.alternate;a.finishedExpirationTime=b;U=null;ab(a);V(a)}return null}function uj(){if(null!==bb){var a=bb;bb=null;a.forEach(function(a,c){Ue(c,a);V(c)});ha()}}function Qh(a,b){var c=p;p|=1;try{return a(b)}finally{p=
c,p===H&&ha()}}function Rh(a,b){var c=p;p&=-2;p|=Ye;try{return a(b)}finally{p=c,p===H&&ha()}}function $a(a,b){a.finishedWork=null;a.finishedExpirationTime=0;var c=a.timeoutHandle;-1!==c&&(a.timeoutHandle=-1,vj(c));if(null!==t)for(c=t.return;null!==c;){var d=c;switch(d.tag){case 1:d=d.type.childContextTypes;null!==d&&void 0!==d&&(q(G),q(B));break;case 3:tb();q(G);q(B);break;case 5:te(d);break;case 4:tb();break;case 13:q(D);break;case 19:q(D);break;case 10:me(d)}c=c.return}U=a;t=Sa(a.current,null);
P=b;F=Xa;id=null;Yb=ta=1073741823;kd=null;Xb=0;jd=!1}function Nh(a,b){do{try{le();Sc.current=Tc;if(Uc)for(var c=z.memoizedState;null!==c;){var d=c.queue;null!==d&&(d.pending=null);c=c.next}Ia=0;J=K=z=null;Uc=!1;if(null===t||null===t.return)return F=hd,id=b,t=null;a:{var e=a,f=t.return,g=t,h=b;b=P;g.effectTag|=2048;g.firstEffect=g.lastEffect=null;if(null!==h&&"object"===typeof h&&"function"===typeof h.then){var m=h;if(0===(g.mode&2)){var n=g.alternate;n?(g.updateQueue=n.updateQueue,g.memoizedState=
n.memoizedState,g.expirationTime=n.expirationTime):(g.updateQueue=null,g.memoizedState=null)}var l=0!==(D.current&1),k=f;do{var p;if(p=13===k.tag){var q=k.memoizedState;if(null!==q)p=null!==q.dehydrated?!0:!1;else{var w=k.memoizedProps;p=void 0===w.fallback?!1:!0!==w.unstable_avoidThisFallback?!0:l?!1:!0}}if(p){var y=k.updateQueue;if(null===y){var r=new Set;r.add(m);k.updateQueue=r}else y.add(m);if(0===(k.mode&2)){k.effectTag|=64;g.effectTag&=-2981;if(1===g.tag)if(null===g.alternate)g.tag=17;else{var O=
Ea(1073741823,null);O.tag=Jc;Fa(g,O)}g.expirationTime=1073741823;break a}h=void 0;g=b;var v=e.pingCache;null===v?(v=e.pingCache=new wj,h=new Set,v.set(m,h)):(h=v.get(m),void 0===h&&(h=new Set,v.set(m,h)));if(!h.has(g)){h.add(g);var x=xj.bind(null,e,m,g);m.then(x,x)}k.effectTag|=4096;k.expirationTime=b;break a}k=k.return}while(null!==k);h=Error((na(g.type)||"A React component")+" suspended while rendering, but no fallback UI was specified.\n\nAdd a <Suspense fallback=...> component higher in the tree to provide a loading indicator or placeholder to display."+
Bd(g))}F!==Xe&&(F=Oh);h=Le(h,g);k=f;do{switch(k.tag){case 3:m=h;k.effectTag|=4096;k.expirationTime=b;var A=Ih(k,m,b);Ug(k,A);break a;case 1:m=h;var u=k.type,B=k.stateNode;if(0===(k.effectTag&64)&&("function"===typeof u.getDerivedStateFromError||null!==B&&"function"===typeof B.componentDidCatch&&(null===La||!La.has(B)))){k.effectTag|=4096;k.expirationTime=b;var H=Jh(k,m,b);Ug(k,H);break a}}k=k.return}while(null!==k)}t=Sh(t)}catch(cj){b=cj;continue}break}while(1)}function Mh(a){a=gd.current;gd.current=
Tc;return null===a?Tc:a}function Vg(a,b){a<ta&&2<a&&(ta=a);null!==b&&a<Yb&&2<a&&(Yb=a,kd=b)}function Kc(a){a>Xb&&(Xb=a)}function tj(){for(;null!==t;)t=Th(t)}function rj(){for(;null!==t&&!yj();)t=Th(t)}function Th(a){var b=zj(a.alternate,a,P);a.memoizedProps=a.pendingProps;null===b&&(b=Sh(a));Uh.current=null;return b}function Sh(a){t=a;do{var b=t.alternate;a=t.return;if(0===(t.effectTag&2048)){b=hj(b,t,P);if(1===P||1!==t.childExpirationTime){for(var c=0,d=t.child;null!==d;){var e=d.expirationTime,
f=d.childExpirationTime;e>c&&(c=e);f>c&&(c=f);d=d.sibling}t.childExpirationTime=c}if(null!==b)return b;null!==a&&0===(a.effectTag&2048)&&(null===a.firstEffect&&(a.firstEffect=t.firstEffect),null!==t.lastEffect&&(null!==a.lastEffect&&(a.lastEffect.nextEffect=t.firstEffect),a.lastEffect=t.lastEffect),1<t.effectTag&&(null!==a.lastEffect?a.lastEffect.nextEffect=t:a.firstEffect=t,a.lastEffect=t))}else{b=lj(t);if(null!==b)return b.effectTag&=2047,b;null!==a&&(a.firstEffect=a.lastEffect=null,a.effectTag|=
2048)}b=t.sibling;if(null!==b)return b;t=a}while(null!==t);F===Xa&&(F=Xe);return null}function Ve(a){var b=a.expirationTime;a=a.childExpirationTime;return b>a?b:a}function ab(a){var b=Cc();Da(99,Aj.bind(null,a,b));return null}function Aj(a,b){do xb();while(null!==Zb);if((p&(ca|ma))!==H)throw Error(k(327));var c=a.finishedWork,d=a.finishedExpirationTime;if(null===c)return null;a.finishedWork=null;a.finishedExpirationTime=0;if(c===a.current)throw Error(k(177));a.callbackNode=null;a.callbackExpirationTime=
0;a.callbackPriority=90;a.nextKnownPendingLevel=0;var e=Ve(c);a.firstPendingTime=e;d<=a.lastSuspendedTime?a.firstSuspendedTime=a.lastSuspendedTime=a.nextKnownPendingLevel=0:d<=a.firstSuspendedTime&&(a.firstSuspendedTime=d-1);d<=a.lastPingedTime&&(a.lastPingedTime=0);d<=a.lastExpiredTime&&(a.lastExpiredTime=0);a===U&&(t=U=null,P=0);1<c.effectTag?null!==c.lastEffect?(c.lastEffect.nextEffect=c,e=c.firstEffect):e=c:e=c.firstEffect;if(null!==e){var f=p;p|=ma;Uh.current=null;Ze=tc;var g=kg();if(Xd(g)){if("selectionStart"in
g)var h={start:g.selectionStart,end:g.selectionEnd};else a:{h=(h=g.ownerDocument)&&h.defaultView||window;var m=h.getSelection&&h.getSelection();if(m&&0!==m.rangeCount){h=m.anchorNode;var n=m.anchorOffset,q=m.focusNode;m=m.focusOffset;try{h.nodeType,q.nodeType}catch(sb){h=null;break a}var ba=0,w=-1,y=-1,B=0,D=0,r=g,z=null;b:for(;;){for(var v;;){r!==h||0!==n&&3!==r.nodeType||(w=ba+n);r!==q||0!==m&&3!==r.nodeType||(y=ba+m);3===r.nodeType&&(ba+=r.nodeValue.length);if(null===(v=r.firstChild))break;z=r;
r=v}for(;;){if(r===g)break b;z===h&&++B===n&&(w=ba);z===q&&++D===m&&(y=ba);if(null!==(v=r.nextSibling))break;r=z;z=r.parentNode}r=v}h=-1===w||-1===y?null:{start:w,end:y}}else h=null}h=h||{start:0,end:0}}else h=null;$e={activeElementDetached:null,focusedElem:g,selectionRange:h};tc=!1;l=e;do try{Bj()}catch(sb){if(null===l)throw Error(k(330));Za(l,sb);l=l.nextEffect}while(null!==l);l=e;do try{for(g=a,h=b;null!==l;){var x=l.effectTag;x&16&&Wb(l.stateNode,"");if(x&128){var A=l.alternate;if(null!==A){var u=
A.ref;null!==u&&("function"===typeof u?u(null):u.current=null)}}switch(x&1038){case 2:Gh(l);l.effectTag&=-3;break;case 6:Gh(l);l.effectTag&=-3;Qe(l.alternate,l);break;case 1024:l.effectTag&=-1025;break;case 1028:l.effectTag&=-1025;Qe(l.alternate,l);break;case 4:Qe(l.alternate,l);break;case 8:n=l,Dh(g,n,h),Eh(n)}l=l.nextEffect}}catch(sb){if(null===l)throw Error(k(330));Za(l,sb);l=l.nextEffect}while(null!==l);u=$e;A=kg();x=u.focusedElem;h=u.selectionRange;if(A!==x&&x&&x.ownerDocument&&jg(x.ownerDocument.documentElement,
x)){null!==h&&Xd(x)&&(A=h.start,u=h.end,void 0===u&&(u=A),"selectionStart"in x?(x.selectionStart=A,x.selectionEnd=Math.min(u,x.value.length)):(u=(A=x.ownerDocument||document)&&A.defaultView||window,u.getSelection&&(u=u.getSelection(),n=x.textContent.length,g=Math.min(h.start,n),h=void 0===h.end?g:Math.min(h.end,n),!u.extend&&g>h&&(n=h,h=g,g=n),n=ig(x,g),q=ig(x,h),n&&q&&(1!==u.rangeCount||u.anchorNode!==n.node||u.anchorOffset!==n.offset||u.focusNode!==q.node||u.focusOffset!==q.offset)&&(A=A.createRange(),
A.setStart(n.node,n.offset),u.removeAllRanges(),g>h?(u.addRange(A),u.extend(q.node,q.offset)):(A.setEnd(q.node,q.offset),u.addRange(A))))));A=[];for(u=x;u=u.parentNode;)1===u.nodeType&&A.push({element:u,left:u.scrollLeft,top:u.scrollTop});"function"===typeof x.focus&&x.focus();for(x=0;x<A.length;x++)u=A[x],u.element.scrollLeft=u.left,u.element.scrollTop=u.top}tc=!!Ze;$e=Ze=null;a.current=c;l=e;do try{for(x=a;null!==l;){var F=l.effectTag;F&36&&oj(x,l.alternate,l);if(F&128){A=void 0;var E=l.ref;if(null!==
E){var G=l.stateNode;switch(l.tag){case 5:A=G;break;default:A=G}"function"===typeof E?E(A):E.current=A}}l=l.nextEffect}}catch(sb){if(null===l)throw Error(k(330));Za(l,sb);l=l.nextEffect}while(null!==l);l=null;Cj();p=f}else a.current=c;if(ld)ld=!1,Zb=a,$b=b;else for(l=e;null!==l;)b=l.nextEffect,l.nextEffect=null,l=b;b=a.firstPendingTime;0===b&&(La=null);1073741823===b?a===af?ac++:(ac=0,af=a):ac=0;"function"===typeof bf&&bf(c.stateNode,d);V(a);if(cd)throw cd=!1,a=Se,Se=null,a;if((p&Ye)!==H)return null;
ha();return null}function Bj(){for(;null!==l;){var a=l.effectTag;0!==(a&256)&&nj(l.alternate,l);0===(a&512)||ld||(ld=!0,Ng(97,function(){xb();return null}));l=l.nextEffect}}function xb(){if(90!==$b){var a=97<$b?97:$b;$b=90;return Da(a,Dj)}}function Dj(){if(null===Zb)return!1;var a=Zb;Zb=null;if((p&(ca|ma))!==H)throw Error(k(331));var b=p;p|=ma;for(a=a.current.firstEffect;null!==a;){try{var c=a;if(0!==(c.effectTag&512))switch(c.tag){case 0:case 11:case 15:case 22:Ah(5,c),Bh(5,c)}}catch(d){if(null===
a)throw Error(k(330));Za(a,d)}c=a.nextEffect;a.nextEffect=null;a=c}p=b;ha();return!0}function Vh(a,b,c){b=Le(c,b);b=Ih(a,b,1073741823);Fa(a,b);a=ed(a,1073741823);null!==a&&V(a)}function Za(a,b){if(3===a.tag)Vh(a,a,b);else for(var c=a.return;null!==c;){if(3===c.tag){Vh(c,a,b);break}else if(1===c.tag){var d=c.stateNode;if("function"===typeof c.type.getDerivedStateFromError||"function"===typeof d.componentDidCatch&&(null===La||!La.has(d))){a=Le(b,a);a=Jh(c,a,1073741823);Fa(c,a);c=ed(c,1073741823);null!==
c&&V(c);break}}c=c.return}}function xj(a,b,c){var d=a.pingCache;null!==d&&d.delete(b);U===a&&P===c?F===bd||F===ad&&1073741823===ta&&Y()-Re<Ph?$a(a,P):jd=!0:Kh(a,c)&&(b=a.lastPingedTime,0!==b&&b<c||(a.lastPingedTime=c,V(a)))}function qj(a,b){var c=a.stateNode;null!==c&&c.delete(b);b=0;0===b&&(b=ka(),b=Va(b,a,null));a=ed(a,b);null!==a&&V(a)}function Ej(a){if("undefined"===typeof __REACT_DEVTOOLS_GLOBAL_HOOK__)return!1;var b=__REACT_DEVTOOLS_GLOBAL_HOOK__;if(b.isDisabled||!b.supportsFiber)return!0;try{var c=
b.inject(a);bf=function(a,e){try{b.onCommitFiberRoot(c,a,void 0,64===(a.current.effectTag&64))}catch(f){}};Ne=function(a){try{b.onCommitFiberUnmount(c,a)}catch(e){}}}catch(d){}return!0}function Fj(a,b,c,d){this.tag=a;this.key=c;this.sibling=this.child=this.return=this.stateNode=this.type=this.elementType=null;this.index=0;this.ref=null;this.pendingProps=b;this.dependencies=this.memoizedState=this.updateQueue=this.memoizedProps=null;this.mode=d;this.effectTag=0;this.lastEffect=this.firstEffect=this.nextEffect=
null;this.childExpirationTime=this.expirationTime=0;this.alternate=null}function Ge(a){a=a.prototype;return!(!a||!a.isReactComponent)}function Gj(a){if("function"===typeof a)return Ge(a)?1:0;if(void 0!==a&&null!==a){a=a.$$typeof;if(a===zd)return 11;if(a===Ad)return 14}return 2}function Sa(a,b){var c=a.alternate;null===c?(c=la(a.tag,b,a.key,a.mode),c.elementType=a.elementType,c.type=a.type,c.stateNode=a.stateNode,c.alternate=a,a.alternate=c):(c.pendingProps=b,c.effectTag=0,c.nextEffect=null,c.firstEffect=
null,c.lastEffect=null);c.childExpirationTime=a.childExpirationTime;c.expirationTime=a.expirationTime;c.child=a.child;c.memoizedProps=a.memoizedProps;c.memoizedState=a.memoizedState;c.updateQueue=a.updateQueue;b=a.dependencies;c.dependencies=null===b?null:{expirationTime:b.expirationTime,firstContext:b.firstContext,responders:b.responders};c.sibling=a.sibling;c.index=a.index;c.ref=a.ref;return c}function Oc(a,b,c,d,e,f){var g=2;d=a;if("function"===typeof a)Ge(a)&&(g=1);else if("string"===typeof a)g=
5;else a:switch(a){case Ma:return Ha(c.children,e,f,b);case Hj:g=8;e|=7;break;case Af:g=8;e|=1;break;case kc:return a=la(12,c,b,e|8),a.elementType=kc,a.type=kc,a.expirationTime=f,a;case lc:return a=la(13,c,b,e),a.type=lc,a.elementType=lc,a.expirationTime=f,a;case yd:return a=la(19,c,b,e),a.elementType=yd,a.expirationTime=f,a;default:if("object"===typeof a&&null!==a)switch(a.$$typeof){case Cf:g=10;break a;case Bf:g=9;break a;case zd:g=11;break a;case Ad:g=14;break a;case Ef:g=16;d=null;break a;case Df:g=
22;break a}throw Error(k(130,null==a?a:typeof a,""));}b=la(g,c,b,e);b.elementType=a;b.type=d;b.expirationTime=f;return b}function Ha(a,b,c,d){a=la(7,a,d,b);a.expirationTime=c;return a}function qe(a,b,c){a=la(6,a,null,b);a.expirationTime=c;return a}function re(a,b,c){b=la(4,null!==a.children?a.children:[],a.key,b);b.expirationTime=c;b.stateNode={containerInfo:a.containerInfo,pendingChildren:null,implementation:a.implementation};return b}function Ij(a,b,c){this.tag=b;this.current=null;this.containerInfo=
a;this.pingCache=this.pendingChildren=null;this.finishedExpirationTime=0;this.finishedWork=null;this.timeoutHandle=-1;this.pendingContext=this.context=null;this.hydrate=c;this.callbackNode=null;this.callbackPriority=90;this.lastExpiredTime=this.lastPingedTime=this.nextKnownPendingLevel=this.lastSuspendedTime=this.firstSuspendedTime=this.firstPendingTime=0}function Kh(a,b){var c=a.firstSuspendedTime;a=a.lastSuspendedTime;return 0!==c&&c>=b&&a<=b}function Ya(a,b){var c=a.firstSuspendedTime,d=a.lastSuspendedTime;
c<b&&(a.firstSuspendedTime=b);if(d>b||0===c)a.lastSuspendedTime=b;b<=a.lastPingedTime&&(a.lastPingedTime=0);b<=a.lastExpiredTime&&(a.lastExpiredTime=0)}function yh(a,b){b>a.firstPendingTime&&(a.firstPendingTime=b);var c=a.firstSuspendedTime;0!==c&&(b>=c?a.firstSuspendedTime=a.lastSuspendedTime=a.nextKnownPendingLevel=0:b>=a.lastSuspendedTime&&(a.lastSuspendedTime=b+1),b>a.nextKnownPendingLevel&&(a.nextKnownPendingLevel=b))}function Ue(a,b){var c=a.lastExpiredTime;if(0===c||c>b)a.lastExpiredTime=b}
function md(a,b,c,d){var e=b.current,f=ka(),g=Vb.suspense;f=Va(f,e,g);a:if(c){c=c._reactInternalFiber;b:{if(Na(c)!==c||1!==c.tag)throw Error(k(170));var h=c;do{switch(h.tag){case 3:h=h.stateNode.context;break b;case 1:if(N(h.type)){h=h.stateNode.__reactInternalMemoizedMergedChildContext;break b}}h=h.return}while(null!==h);throw Error(k(171));}if(1===c.tag){var m=c.type;if(N(m)){c=Gg(c,m,h);break a}}c=h}else c=Ca;null===b.context?b.context=c:b.pendingContext=c;b=Ea(f,g);b.payload={element:a};d=void 0===
d?null:d;null!==d&&(b.callback=d);Fa(e,b);Ja(e,f);return f}function cf(a){a=a.current;if(!a.child)return null;switch(a.child.tag){case 5:return a.child.stateNode;default:return a.child.stateNode}}function Wh(a,b){a=a.memoizedState;null!==a&&null!==a.dehydrated&&a.retryTime<b&&(a.retryTime=b)}function df(a,b){Wh(a,b);(a=a.alternate)&&Wh(a,b)}function ef(a,b,c){c=null!=c&&!0===c.hydrate;var d=new Ij(a,b,c),e=la(3,null,null,2===b?7:1===b?3:0);d.current=e;e.stateNode=d;ne(e);a[Lb]=d.current;c&&0!==b&&
xi(a,9===a.nodeType?a:a.ownerDocument);this._internalRoot=d}function bc(a){return!(!a||1!==a.nodeType&&9!==a.nodeType&&11!==a.nodeType&&(8!==a.nodeType||" react-mount-point-unstable "!==a.nodeValue))}function Jj(a,b){b||(b=a?9===a.nodeType?a.documentElement:a.firstChild:null,b=!(!b||1!==b.nodeType||!b.hasAttribute("data-reactroot")));if(!b)for(var c;c=a.lastChild;)a.removeChild(c);return new ef(a,0,b?{hydrate:!0}:void 0)}function nd(a,b,c,d,e){var f=c._reactRootContainer;if(f){var g=f._internalRoot;
if("function"===typeof e){var h=e;e=function(){var a=cf(g);h.call(a)}}md(b,g,a,e)}else{f=c._reactRootContainer=Jj(c,d);g=f._internalRoot;if("function"===typeof e){var m=e;e=function(){var a=cf(g);m.call(a)}}Rh(function(){md(b,g,a,e)})}return cf(g)}function Kj(a,b,c){var d=3<arguments.length&&void 0!==arguments[3]?arguments[3]:null;return{$$typeof:gb,key:null==d?null:""+d,children:a,containerInfo:b,implementation:c}}function Xh(a,b){var c=2<arguments.length&&void 0!==arguments[2]?arguments[2]:null;
if(!bc(b))throw Error(k(200));return Kj(a,b,null,c)}if(!ea)throw Error(k(227));var ki=function(a,b,c,d,e,f,g,h,m){var n=Array.prototype.slice.call(arguments,3);try{b.apply(c,n)}catch(C){this.onError(C)}},yb=!1,gc=null,hc=!1,pd=null,li={onError:function(a){yb=!0;gc=a}},td=null,rf=null,mf=null,ic=null,cb={},jc=[],qd={},db={},rd={},wa=!("undefined"===typeof window||"undefined"===typeof window.document||"undefined"===typeof window.document.createElement),M=ea.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.assign,
sd=null,eb=null,fb=null,ee=function(a,b){return a(b)},eg=function(a,b,c,d,e){return a(b,c,d,e)},vd=function(){},vf=ee,Oa=!1,wd=!1,Z=ea.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.Scheduler,Lj=Z.unstable_cancelCallback,ff=Z.unstable_now,$f=Z.unstable_scheduleCallback,Mj=Z.unstable_shouldYield,Yh=Z.unstable_requestPaint,Pd=Z.unstable_runWithPriority,Nj=Z.unstable_getCurrentPriorityLevel,Oj=Z.unstable_ImmediatePriority,Zh=Z.unstable_UserBlockingPriority,ag=Z.unstable_NormalPriority,Pj=Z.unstable_LowPriority,
Qj=Z.unstable_IdlePriority,oi=/^[:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD][:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD\-.0-9\u00B7\u0300-\u036F\u203F-\u2040]*$/,wf=Object.prototype.hasOwnProperty,yf={},xf={},E={};"children dangerouslySetInnerHTML defaultValue defaultChecked innerHTML suppressContentEditableWarning suppressHydrationWarning style".split(" ").forEach(function(a){E[a]=
new L(a,0,!1,a,null,!1)});[["acceptCharset","accept-charset"],["className","class"],["htmlFor","for"],["httpEquiv","http-equiv"]].forEach(function(a){var b=a[0];E[b]=new L(b,1,!1,a[1],null,!1)});["contentEditable","draggable","spellCheck","value"].forEach(function(a){E[a]=new L(a,2,!1,a.toLowerCase(),null,!1)});["autoReverse","externalResourcesRequired","focusable","preserveAlpha"].forEach(function(a){E[a]=new L(a,2,!1,a,null,!1)});"allowFullScreen async autoFocus autoPlay controls default defer disabled disablePictureInPicture formNoValidate hidden loop noModule noValidate open playsInline readOnly required reversed scoped seamless itemScope".split(" ").forEach(function(a){E[a]=
new L(a,3,!1,a.toLowerCase(),null,!1)});["checked","multiple","muted","selected"].forEach(function(a){E[a]=new L(a,3,!0,a,null,!1)});["capture","download"].forEach(function(a){E[a]=new L(a,4,!1,a,null,!1)});["cols","rows","size","span"].forEach(function(a){E[a]=new L(a,6,!1,a,null,!1)});["rowSpan","start"].forEach(function(a){E[a]=new L(a,5,!1,a.toLowerCase(),null,!1)});var gf=/[\-:]([a-z])/g,hf=function(a){return a[1].toUpperCase()};"accent-height alignment-baseline arabic-form baseline-shift cap-height clip-path clip-rule color-interpolation color-interpolation-filters color-profile color-rendering dominant-baseline enable-background fill-opacity fill-rule flood-color flood-opacity font-family font-size font-size-adjust font-stretch font-style font-variant font-weight glyph-name glyph-orientation-horizontal glyph-orientation-vertical horiz-adv-x horiz-origin-x image-rendering letter-spacing lighting-color marker-end marker-mid marker-start overline-position overline-thickness paint-order panose-1 pointer-events rendering-intent shape-rendering stop-color stop-opacity strikethrough-position strikethrough-thickness stroke-dasharray stroke-dashoffset stroke-linecap stroke-linejoin stroke-miterlimit stroke-opacity stroke-width text-anchor text-decoration text-rendering underline-position underline-thickness unicode-bidi unicode-range units-per-em v-alphabetic v-hanging v-ideographic v-mathematical vector-effect vert-adv-y vert-origin-x vert-origin-y word-spacing writing-mode xmlns:xlink x-height".split(" ").forEach(function(a){var b=
a.replace(gf,hf);E[b]=new L(b,1,!1,a,null,!1)});"xlink:actuate xlink:arcrole xlink:role xlink:show xlink:title xlink:type".split(" ").forEach(function(a){var b=a.replace(gf,hf);E[b]=new L(b,1,!1,a,"http://www.w3.org/1999/xlink",!1)});["xml:base","xml:lang","xml:space"].forEach(function(a){var b=a.replace(gf,hf);E[b]=new L(b,1,!1,a,"http://www.w3.org/XML/1998/namespace",!1)});["tabIndex","crossOrigin"].forEach(function(a){E[a]=new L(a,1,!1,a.toLowerCase(),null,!1)});E.xlinkHref=new L("xlinkHref",1,
!1,"xlink:href","http://www.w3.org/1999/xlink",!0);["src","href","action","formAction"].forEach(function(a){E[a]=new L(a,1,!1,a.toLowerCase(),null,!0)});var da=ea.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;da.hasOwnProperty("ReactCurrentDispatcher")||(da.ReactCurrentDispatcher={current:null});da.hasOwnProperty("ReactCurrentBatchConfig")||(da.ReactCurrentBatchConfig={suspense:null});var si=/^(.*)[\\\/]/,Q="function"===typeof Symbol&&Symbol.for,Pc=Q?Symbol.for("react.element"):60103,gb=Q?Symbol.for("react.portal"):
60106,Ma=Q?Symbol.for("react.fragment"):60107,Af=Q?Symbol.for("react.strict_mode"):60108,kc=Q?Symbol.for("react.profiler"):60114,Cf=Q?Symbol.for("react.provider"):60109,Bf=Q?Symbol.for("react.context"):60110,Hj=Q?Symbol.for("react.concurrent_mode"):60111,zd=Q?Symbol.for("react.forward_ref"):60112,lc=Q?Symbol.for("react.suspense"):60113,yd=Q?Symbol.for("react.suspense_list"):60120,Ad=Q?Symbol.for("react.memo"):60115,Ef=Q?Symbol.for("react.lazy"):60116,Df=Q?Symbol.for("react.block"):60121,zf="function"===
typeof Symbol&&Symbol.iterator,od,xh=function(a){return"undefined"!==typeof MSApp&&MSApp.execUnsafeLocalFunction?function(b,c,d,e){MSApp.execUnsafeLocalFunction(function(){return a(b,c,d,e)})}:a}(function(a,b){if("http://www.w3.org/2000/svg"!==a.namespaceURI||"innerHTML"in a)a.innerHTML=b;else{od=od||document.createElement("div");od.innerHTML="<svg>"+b.valueOf().toString()+"</svg>";for(b=od.firstChild;a.firstChild;)a.removeChild(a.firstChild);for(;b.firstChild;)a.appendChild(b.firstChild)}}),Wb=function(a,
b){if(b){var c=a.firstChild;if(c&&c===a.lastChild&&3===c.nodeType){c.nodeValue=b;return}}a.textContent=b},ib={animationend:nc("Animation","AnimationEnd"),animationiteration:nc("Animation","AnimationIteration"),animationstart:nc("Animation","AnimationStart"),transitionend:nc("Transition","TransitionEnd")},Id={},Of={};wa&&(Of=document.createElement("div").style,"AnimationEvent"in window||(delete ib.animationend.animation,delete ib.animationiteration.animation,delete ib.animationstart.animation),"TransitionEvent"in
window||delete ib.transitionend.transition);var $h=oc("animationend"),ai=oc("animationiteration"),bi=oc("animationstart"),ci=oc("transitionend"),Db="abort canplay canplaythrough durationchange emptied encrypted ended error loadeddata loadedmetadata loadstart pause play playing progress ratechange seeked seeking stalled suspend timeupdate volumechange waiting".split(" "),Pf=new ("function"===typeof WeakMap?WeakMap:Map),Ab=null,wi=function(a){if(a){var b=a._dispatchListeners,c=a._dispatchInstances;
if(Array.isArray(b))for(var d=0;d<b.length&&!a.isPropagationStopped();d++)lf(a,b[d],c[d]);else b&&lf(a,b,c);a._dispatchListeners=null;a._dispatchInstances=null;a.isPersistent()||a.constructor.release(a)}},qc=[],Rd=!1,fa=[],xa=null,ya=null,za=null,Eb=new Map,Fb=new Map,Jb=[],Nd="mousedown mouseup touchcancel touchend touchstart auxclick dblclick pointercancel pointerdown pointerup dragend dragstart drop compositionend compositionstart keydown keypress keyup input textInput close cancel copy cut paste click change contextmenu reset submit".split(" "),
yi="focus blur dragenter dragleave mouseover mouseout pointerover pointerout gotpointercapture lostpointercapture".split(" "),dg={},cg=new Map,Td=new Map,Rj=["abort","abort",$h,"animationEnd",ai,"animationIteration",bi,"animationStart","canplay","canPlay","canplaythrough","canPlayThrough","durationchange","durationChange","emptied","emptied","encrypted","encrypted","ended","ended","error","error","gotpointercapture","gotPointerCapture","load","load","loadeddata","loadedData","loadedmetadata","loadedMetadata",
"loadstart","loadStart","lostpointercapture","lostPointerCapture","playing","playing","progress","progress","seeking","seeking","stalled","stalled","suspend","suspend","timeupdate","timeUpdate",ci,"transitionEnd","waiting","waiting"];Sd("blur blur cancel cancel click click close close contextmenu contextMenu copy copy cut cut auxclick auxClick dblclick doubleClick dragend dragEnd dragstart dragStart drop drop focus focus input input invalid invalid keydown keyDown keypress keyPress keyup keyUp mousedown mouseDown mouseup mouseUp paste paste pause pause play play pointercancel pointerCancel pointerdown pointerDown pointerup pointerUp ratechange rateChange reset reset seeked seeked submit submit touchcancel touchCancel touchend touchEnd touchstart touchStart volumechange volumeChange".split(" "),
0);Sd("drag drag dragenter dragEnter dragexit dragExit dragleave dragLeave dragover dragOver mousemove mouseMove mouseout mouseOut mouseover mouseOver pointermove pointerMove pointerout pointerOut pointerover pointerOver scroll scroll toggle toggle touchmove touchMove wheel wheel".split(" "),1);Sd(Rj,2);(function(a,b){for(var c=0;c<a.length;c++)Td.set(a[c],b)})("change selectionchange textInput compositionstart compositionend compositionupdate".split(" "),0);var Hi=Zh,Gi=Pd,tc=!0,Kb={animationIterationCount:!0,
borderImageOutset:!0,borderImageSlice:!0,borderImageWidth:!0,boxFlex:!0,boxFlexGroup:!0,boxOrdinalGroup:!0,columnCount:!0,columns:!0,flex:!0,flexGrow:!0,flexPositive:!0,flexShrink:!0,flexNegative:!0,flexOrder:!0,gridArea:!0,gridRow:!0,gridRowEnd:!0,gridRowSpan:!0,gridRowStart:!0,gridColumn:!0,gridColumnEnd:!0,gridColumnSpan:!0,gridColumnStart:!0,fontWeight:!0,lineClamp:!0,lineHeight:!0,opacity:!0,order:!0,orphans:!0,tabSize:!0,widows:!0,zIndex:!0,zoom:!0,fillOpacity:!0,floodOpacity:!0,stopOpacity:!0,
strokeDasharray:!0,strokeDashoffset:!0,strokeMiterlimit:!0,strokeOpacity:!0,strokeWidth:!0},Sj=["Webkit","ms","Moz","O"];Object.keys(Kb).forEach(function(a){Sj.forEach(function(b){b=b+a.charAt(0).toUpperCase()+a.substring(1);Kb[b]=Kb[a]})});var Ii=M({menuitem:!0},{area:!0,base:!0,br:!0,col:!0,embed:!0,hr:!0,img:!0,input:!0,keygen:!0,link:!0,meta:!0,param:!0,source:!0,track:!0,wbr:!0}),ng="$",og="/$",$d="$?",Zd="$!",Ze=null,$e=null,We="function"===typeof setTimeout?setTimeout:void 0,vj="function"===
typeof clearTimeout?clearTimeout:void 0,jf=Math.random().toString(36).slice(2),Aa="__reactInternalInstance$"+jf,vc="__reactEventHandlers$"+jf,Lb="__reactContainere$"+jf,Ba=null,ce=null,wc=null;M(R.prototype,{preventDefault:function(){this.defaultPrevented=!0;var a=this.nativeEvent;a&&(a.preventDefault?a.preventDefault():"unknown"!==typeof a.returnValue&&(a.returnValue=!1),this.isDefaultPrevented=xc)},stopPropagation:function(){var a=this.nativeEvent;a&&(a.stopPropagation?a.stopPropagation():"unknown"!==
typeof a.cancelBubble&&(a.cancelBubble=!0),this.isPropagationStopped=xc)},persist:function(){this.isPersistent=xc},isPersistent:yc,destructor:function(){var a=this.constructor.Interface,b;for(b in a)this[b]=null;this.nativeEvent=this._targetInst=this.dispatchConfig=null;this.isPropagationStopped=this.isDefaultPrevented=yc;this._dispatchInstances=this._dispatchListeners=null}});R.Interface={type:null,target:null,currentTarget:function(){return null},eventPhase:null,bubbles:null,cancelable:null,timeStamp:function(a){return a.timeStamp||
Date.now()},defaultPrevented:null,isTrusted:null};R.extend=function(a){function b(){return c.apply(this,arguments)}var c=this,d=function(){};d.prototype=c.prototype;d=new d;M(d,b.prototype);b.prototype=d;b.prototype.constructor=b;b.Interface=M({},c.Interface,a);b.extend=c.extend;sg(b);return b};sg(R);var Tj=R.extend({data:null}),Uj=R.extend({data:null}),Ni=[9,13,27,32],de=wa&&"CompositionEvent"in window,cc=null;wa&&"documentMode"in document&&(cc=document.documentMode);var Vj=wa&&"TextEvent"in window&&
!cc,xg=wa&&(!de||cc&&8<cc&&11>=cc),wg=String.fromCharCode(32),ua={beforeInput:{phasedRegistrationNames:{bubbled:"onBeforeInput",captured:"onBeforeInputCapture"},dependencies:["compositionend","keypress","textInput","paste"]},compositionEnd:{phasedRegistrationNames:{bubbled:"onCompositionEnd",captured:"onCompositionEndCapture"},dependencies:"blur compositionend keydown keypress keyup mousedown".split(" ")},compositionStart:{phasedRegistrationNames:{bubbled:"onCompositionStart",captured:"onCompositionStartCapture"},
dependencies:"blur compositionstart keydown keypress keyup mousedown".split(" ")},compositionUpdate:{phasedRegistrationNames:{bubbled:"onCompositionUpdate",captured:"onCompositionUpdateCapture"},dependencies:"blur compositionupdate keydown keypress keyup mousedown".split(" ")}},vg=!1,mb=!1,Wj={eventTypes:ua,extractEvents:function(a,b,c,d,e){var f;if(de)b:{switch(a){case "compositionstart":var g=ua.compositionStart;break b;case "compositionend":g=ua.compositionEnd;break b;case "compositionupdate":g=
ua.compositionUpdate;break b}g=void 0}else mb?tg(a,c)&&(g=ua.compositionEnd):"keydown"===a&&229===c.keyCode&&(g=ua.compositionStart);g?(xg&&"ko"!==c.locale&&(mb||g!==ua.compositionStart?g===ua.compositionEnd&&mb&&(f=rg()):(Ba=d,ce="value"in Ba?Ba.value:Ba.textContent,mb=!0)),e=Tj.getPooled(g,b,c,d),f?e.data=f:(f=ug(c),null!==f&&(e.data=f)),lb(e),f=e):f=null;(a=Vj?Oi(a,c):Pi(a,c))?(b=Uj.getPooled(ua.beforeInput,b,c,d),b.data=a,lb(b)):b=null;return null===f?b:null===b?f:[f,b]}},Qi={color:!0,date:!0,
datetime:!0,"datetime-local":!0,email:!0,month:!0,number:!0,password:!0,range:!0,search:!0,tel:!0,text:!0,time:!0,url:!0,week:!0},Ag={change:{phasedRegistrationNames:{bubbled:"onChange",captured:"onChangeCapture"},dependencies:"blur change click focus input keydown keyup selectionchange".split(" ")}},Mb=null,Nb=null,kf=!1;wa&&(kf=Tf("input")&&(!document.documentMode||9<document.documentMode));var Xj={eventTypes:Ag,_isInputEventSupported:kf,extractEvents:function(a,b,c,d,e){e=b?Pa(b):window;var f=
e.nodeName&&e.nodeName.toLowerCase();if("select"===f||"input"===f&&"file"===e.type)var g=Si;else if(yg(e))if(kf)g=Wi;else{g=Ui;var h=Ti}else(f=e.nodeName)&&"input"===f.toLowerCase()&&("checkbox"===e.type||"radio"===e.type)&&(g=Vi);if(g&&(g=g(a,b)))return zg(g,c,d);h&&h(a,e,b);"blur"===a&&(a=e._wrapperState)&&a.controlled&&"number"===e.type&&Ed(e,"number",e.value)}},dc=R.extend({view:null,detail:null}),Yi={Alt:"altKey",Control:"ctrlKey",Meta:"metaKey",Shift:"shiftKey"},di=0,ei=0,fi=!1,gi=!1,ec=dc.extend({screenX:null,
screenY:null,clientX:null,clientY:null,pageX:null,pageY:null,ctrlKey:null,shiftKey:null,altKey:null,metaKey:null,getModifierState:fe,button:null,buttons:null,relatedTarget:function(a){return a.relatedTarget||(a.fromElement===a.srcElement?a.toElement:a.fromElement)},movementX:function(a){if("movementX"in a)return a.movementX;var b=di;di=a.screenX;return fi?"mousemove"===a.type?a.screenX-b:0:(fi=!0,0)},movementY:function(a){if("movementY"in a)return a.movementY;var b=ei;ei=a.screenY;return gi?"mousemove"===
a.type?a.screenY-b:0:(gi=!0,0)}}),hi=ec.extend({pointerId:null,width:null,height:null,pressure:null,tangentialPressure:null,tiltX:null,tiltY:null,twist:null,pointerType:null,isPrimary:null}),fc={mouseEnter:{registrationName:"onMouseEnter",dependencies:["mouseout","mouseover"]},mouseLeave:{registrationName:"onMouseLeave",dependencies:["mouseout","mouseover"]},pointerEnter:{registrationName:"onPointerEnter",dependencies:["pointerout","pointerover"]},pointerLeave:{registrationName:"onPointerLeave",dependencies:["pointerout",
"pointerover"]}},Yj={eventTypes:fc,extractEvents:function(a,b,c,d,e){var f="mouseover"===a||"pointerover"===a,g="mouseout"===a||"pointerout"===a;if(f&&0===(e&32)&&(c.relatedTarget||c.fromElement)||!g&&!f)return null;f=d.window===d?d:(f=d.ownerDocument)?f.defaultView||f.parentWindow:window;if(g){if(g=b,b=(b=c.relatedTarget||c.toElement)?Bb(b):null,null!==b){var h=Na(b);if(b!==h||5!==b.tag&&6!==b.tag)b=null}}else g=null;if(g===b)return null;if("mouseout"===a||"mouseover"===a){var m=ec;var n=fc.mouseLeave;
var l=fc.mouseEnter;var k="mouse"}else if("pointerout"===a||"pointerover"===a)m=hi,n=fc.pointerLeave,l=fc.pointerEnter,k="pointer";a=null==g?f:Pa(g);f=null==b?f:Pa(b);n=m.getPooled(n,g,c,d);n.type=k+"leave";n.target=a;n.relatedTarget=f;c=m.getPooled(l,b,c,d);c.type=k+"enter";c.target=f;c.relatedTarget=a;d=g;k=b;if(d&&k)a:{m=d;l=k;g=0;for(a=m;a;a=pa(a))g++;a=0;for(b=l;b;b=pa(b))a++;for(;0<g-a;)m=pa(m),g--;for(;0<a-g;)l=pa(l),a--;for(;g--;){if(m===l||m===l.alternate)break a;m=pa(m);l=pa(l)}m=null}else m=
null;l=m;for(m=[];d&&d!==l;){g=d.alternate;if(null!==g&&g===l)break;m.push(d);d=pa(d)}for(d=[];k&&k!==l;){g=k.alternate;if(null!==g&&g===l)break;d.push(k);k=pa(k)}for(k=0;k<m.length;k++)be(m[k],"bubbled",n);for(k=d.length;0<k--;)be(d[k],"captured",c);return 0===(e&64)?[n]:[n,c]}},Qa="function"===typeof Object.is?Object.is:Zi,$i=Object.prototype.hasOwnProperty,Zj=wa&&"documentMode"in document&&11>=document.documentMode,Eg={select:{phasedRegistrationNames:{bubbled:"onSelect",captured:"onSelectCapture"},
dependencies:"blur contextmenu dragend focus keydown keyup mousedown mouseup selectionchange".split(" ")}},nb=null,he=null,Pb=null,ge=!1,ak={eventTypes:Eg,extractEvents:function(a,b,c,d,e,f){e=f||(d.window===d?d.document:9===d.nodeType?d:d.ownerDocument);if(!(f=!e)){a:{e=Jd(e);f=rd.onSelect;for(var g=0;g<f.length;g++)if(!e.has(f[g])){e=!1;break a}e=!0}f=!e}if(f)return null;e=b?Pa(b):window;switch(a){case "focus":if(yg(e)||"true"===e.contentEditable)nb=e,he=b,Pb=null;break;case "blur":Pb=he=nb=null;
break;case "mousedown":ge=!0;break;case "contextmenu":case "mouseup":case "dragend":return ge=!1,Dg(c,d);case "selectionchange":if(Zj)break;case "keydown":case "keyup":return Dg(c,d)}return null}},bk=R.extend({animationName:null,elapsedTime:null,pseudoElement:null}),ck=R.extend({clipboardData:function(a){return"clipboardData"in a?a.clipboardData:window.clipboardData}}),dk=dc.extend({relatedTarget:null}),ek={Esc:"Escape",Spacebar:" ",Left:"ArrowLeft",Up:"ArrowUp",Right:"ArrowRight",Down:"ArrowDown",
Del:"Delete",Win:"OS",Menu:"ContextMenu",Apps:"ContextMenu",Scroll:"ScrollLock",MozPrintableKey:"Unidentified"},fk={8:"Backspace",9:"Tab",12:"Clear",13:"Enter",16:"Shift",17:"Control",18:"Alt",19:"Pause",20:"CapsLock",27:"Escape",32:" ",33:"PageUp",34:"PageDown",35:"End",36:"Home",37:"ArrowLeft",38:"ArrowUp",39:"ArrowRight",40:"ArrowDown",45:"Insert",46:"Delete",112:"F1",113:"F2",114:"F3",115:"F4",116:"F5",117:"F6",118:"F7",119:"F8",120:"F9",121:"F10",122:"F11",123:"F12",144:"NumLock",145:"ScrollLock",
224:"Meta"},gk=dc.extend({key:function(a){if(a.key){var b=ek[a.key]||a.key;if("Unidentified"!==b)return b}return"keypress"===a.type?(a=Ac(a),13===a?"Enter":String.fromCharCode(a)):"keydown"===a.type||"keyup"===a.type?fk[a.keyCode]||"Unidentified":""},location:null,ctrlKey:null,shiftKey:null,altKey:null,metaKey:null,repeat:null,locale:null,getModifierState:fe,charCode:function(a){return"keypress"===a.type?Ac(a):0},keyCode:function(a){return"keydown"===a.type||"keyup"===a.type?a.keyCode:0},which:function(a){return"keypress"===
a.type?Ac(a):"keydown"===a.type||"keyup"===a.type?a.keyCode:0}}),hk=ec.extend({dataTransfer:null}),ik=dc.extend({touches:null,targetTouches:null,changedTouches:null,altKey:null,metaKey:null,ctrlKey:null,shiftKey:null,getModifierState:fe}),jk=R.extend({propertyName:null,elapsedTime:null,pseudoElement:null}),kk=ec.extend({deltaX:function(a){return"deltaX"in a?a.deltaX:"wheelDeltaX"in a?-a.wheelDeltaX:0},deltaY:function(a){return"deltaY"in a?a.deltaY:"wheelDeltaY"in a?-a.wheelDeltaY:"wheelDelta"in a?
-a.wheelDelta:0},deltaZ:null,deltaMode:null}),lk={eventTypes:dg,extractEvents:function(a,b,c,d,e){e=cg.get(a);if(!e)return null;switch(a){case "keypress":if(0===Ac(c))return null;case "keydown":case "keyup":a=gk;break;case "blur":case "focus":a=dk;break;case "click":if(2===c.button)return null;case "auxclick":case "dblclick":case "mousedown":case "mousemove":case "mouseup":case "mouseout":case "mouseover":case "contextmenu":a=ec;break;case "drag":case "dragend":case "dragenter":case "dragexit":case "dragleave":case "dragover":case "dragstart":case "drop":a=
hk;break;case "touchcancel":case "touchend":case "touchmove":case "touchstart":a=ik;break;case $h:case ai:case bi:a=bk;break;case ci:a=jk;break;case "scroll":a=dc;break;case "wheel":a=kk;break;case "copy":case "cut":case "paste":a=ck;break;case "gotpointercapture":case "lostpointercapture":case "pointercancel":case "pointerdown":case "pointermove":case "pointerout":case "pointerover":case "pointerup":a=hi;break;default:a=R}b=a.getPooled(e,b,c,d);lb(b);return b}};(function(a){if(ic)throw Error(k(101));
ic=Array.prototype.slice.call(a);nf()})("ResponderEventPlugin SimpleEventPlugin EnterLeaveEventPlugin ChangeEventPlugin SelectEventPlugin BeforeInputEventPlugin".split(" "));(function(a,b,c){td=a;rf=b;mf=c})(ae,Hb,Pa);pf({SimpleEventPlugin:lk,EnterLeaveEventPlugin:Yj,ChangeEventPlugin:Xj,SelectEventPlugin:ak,BeforeInputEventPlugin:Wj});var ie=[],ob=-1,Ca={},B={current:Ca},G={current:!1},Ra=Ca,bj=Pd,je=$f,Rg=Lj,aj=Nj,Dc=Oj,Ig=Zh,Jg=ag,Kg=Pj,Lg=Qj,Qg={},yj=Mj,Cj=void 0!==Yh?Yh:function(){},qa=null,
Ec=null,ke=!1,ii=ff(),Y=1E4>ii?ff:function(){return ff()-ii},Ic={current:null},Hc=null,qb=null,Gc=null,Tg=0,Jc=2,Ga=!1,Vb=da.ReactCurrentBatchConfig,$g=(new ea.Component).refs,Mc={isMounted:function(a){return(a=a._reactInternalFiber)?Na(a)===a:!1},enqueueSetState:function(a,b,c){a=a._reactInternalFiber;var d=ka(),e=Vb.suspense;d=Va(d,a,e);e=Ea(d,e);e.payload=b;void 0!==c&&null!==c&&(e.callback=c);Fa(a,e);Ja(a,d)},enqueueReplaceState:function(a,b,c){a=a._reactInternalFiber;var d=ka(),e=Vb.suspense;
d=Va(d,a,e);e=Ea(d,e);e.tag=1;e.payload=b;void 0!==c&&null!==c&&(e.callback=c);Fa(a,e);Ja(a,d)},enqueueForceUpdate:function(a,b){a=a._reactInternalFiber;var c=ka(),d=Vb.suspense;c=Va(c,a,d);d=Ea(c,d);d.tag=Jc;void 0!==b&&null!==b&&(d.callback=b);Fa(a,d);Ja(a,c)}},Qc=Array.isArray,wb=ah(!0),Fe=ah(!1),Sb={},ja={current:Sb},Ub={current:Sb},Tb={current:Sb},D={current:0},Sc=da.ReactCurrentDispatcher,X=da.ReactCurrentBatchConfig,Ia=0,z=null,K=null,J=null,Uc=!1,Tc={readContext:W,useCallback:S,useContext:S,
useEffect:S,useImperativeHandle:S,useLayoutEffect:S,useMemo:S,useReducer:S,useRef:S,useState:S,useDebugValue:S,useResponder:S,useDeferredValue:S,useTransition:S},dj={readContext:W,useCallback:ih,useContext:W,useEffect:eh,useImperativeHandle:function(a,b,c){c=null!==c&&void 0!==c?c.concat([a]):null;return ze(4,2,gh.bind(null,b,a),c)},useLayoutEffect:function(a,b){return ze(4,2,a,b)},useMemo:function(a,b){var c=ub();b=void 0===b?null:b;a=a();c.memoizedState=[a,b];return a},useReducer:function(a,b,c){var d=
ub();b=void 0!==c?c(b):b;d.memoizedState=d.baseState=b;a=d.queue={pending:null,dispatch:null,lastRenderedReducer:a,lastRenderedState:b};a=a.dispatch=ch.bind(null,z,a);return[d.memoizedState,a]},useRef:function(a){var b=ub();a={current:a};return b.memoizedState=a},useState:xe,useDebugValue:Be,useResponder:ue,useDeferredValue:function(a,b){var c=xe(a),d=c[0],e=c[1];eh(function(){var c=X.suspense;X.suspense=void 0===b?null:b;try{e(a)}finally{X.suspense=c}},[a,b]);return d},useTransition:function(a){var b=
xe(!1),c=b[0];b=b[1];return[ih(Ce.bind(null,b,a),[b,a]),c]}},ej={readContext:W,useCallback:Yc,useContext:W,useEffect:Xc,useImperativeHandle:hh,useLayoutEffect:fh,useMemo:jh,useReducer:Vc,useRef:dh,useState:function(a){return Vc(Ua)},useDebugValue:Be,useResponder:ue,useDeferredValue:function(a,b){var c=Vc(Ua),d=c[0],e=c[1];Xc(function(){var c=X.suspense;X.suspense=void 0===b?null:b;try{e(a)}finally{X.suspense=c}},[a,b]);return d},useTransition:function(a){var b=Vc(Ua),c=b[0];b=b[1];return[Yc(Ce.bind(null,
b,a),[b,a]),c]}},fj={readContext:W,useCallback:Yc,useContext:W,useEffect:Xc,useImperativeHandle:hh,useLayoutEffect:fh,useMemo:jh,useReducer:Wc,useRef:dh,useState:function(a){return Wc(Ua)},useDebugValue:Be,useResponder:ue,useDeferredValue:function(a,b){var c=Wc(Ua),d=c[0],e=c[1];Xc(function(){var c=X.suspense;X.suspense=void 0===b?null:b;try{e(a)}finally{X.suspense=c}},[a,b]);return d},useTransition:function(a){var b=Wc(Ua),c=b[0];b=b[1];return[Yc(Ce.bind(null,b,a),[b,a]),c]}},ra=null,Ka=null,Wa=
!1,gj=da.ReactCurrentOwner,ia=!1,Je={dehydrated:null,retryTime:0};var jj=function(a,b,c,d){for(c=b.child;null!==c;){if(5===c.tag||6===c.tag)a.appendChild(c.stateNode);else if(4!==c.tag&&null!==c.child){c.child.return=c;c=c.child;continue}if(c===b)break;for(;null===c.sibling;){if(null===c.return||c.return===b)return;c=c.return}c.sibling.return=c.return;c=c.sibling}};var wh=function(a){};var ij=function(a,b,c,d,e){var f=a.memoizedProps;if(f!==d){var g=b.stateNode;Ta(ja.current);a=null;switch(c){case "input":f=
Cd(g,f);d=Cd(g,d);a=[];break;case "option":f=Fd(g,f);d=Fd(g,d);a=[];break;case "select":f=M({},f,{value:void 0});d=M({},d,{value:void 0});a=[];break;case "textarea":f=Gd(g,f);d=Gd(g,d);a=[];break;default:"function"!==typeof f.onClick&&"function"===typeof d.onClick&&(g.onclick=uc)}Ud(c,d);var h,m;c=null;for(h in f)if(!d.hasOwnProperty(h)&&f.hasOwnProperty(h)&&null!=f[h])if("style"===h)for(m in g=f[h],g)g.hasOwnProperty(m)&&(c||(c={}),c[m]="");else"dangerouslySetInnerHTML"!==h&&"children"!==h&&"suppressContentEditableWarning"!==
h&&"suppressHydrationWarning"!==h&&"autoFocus"!==h&&(db.hasOwnProperty(h)?a||(a=[]):(a=a||[]).push(h,null));for(h in d){var k=d[h];g=null!=f?f[h]:void 0;if(d.hasOwnProperty(h)&&k!==g&&(null!=k||null!=g))if("style"===h)if(g){for(m in g)!g.hasOwnProperty(m)||k&&k.hasOwnProperty(m)||(c||(c={}),c[m]="");for(m in k)k.hasOwnProperty(m)&&g[m]!==k[m]&&(c||(c={}),c[m]=k[m])}else c||(a||(a=[]),a.push(h,c)),c=k;else"dangerouslySetInnerHTML"===h?(k=k?k.__html:void 0,g=g?g.__html:void 0,null!=k&&g!==k&&(a=a||
[]).push(h,k)):"children"===h?g===k||"string"!==typeof k&&"number"!==typeof k||(a=a||[]).push(h,""+k):"suppressContentEditableWarning"!==h&&"suppressHydrationWarning"!==h&&(db.hasOwnProperty(h)?(null!=k&&oa(e,h),a||g===k||(a=[])):(a=a||[]).push(h,k))}c&&(a=a||[]).push("style",c);e=a;if(b.updateQueue=e)b.effectTag|=4}};var kj=function(a,b,c,d){c!==d&&(b.effectTag|=4)};var pj="function"===typeof WeakSet?WeakSet:Set,wj="function"===typeof WeakMap?WeakMap:Map,sj=Math.ceil,gd=da.ReactCurrentDispatcher,
Uh=da.ReactCurrentOwner,H=0,Ye=8,ca=16,ma=32,Xa=0,hd=1,Oh=2,ad=3,bd=4,Xe=5,p=H,U=null,t=null,P=0,F=Xa,id=null,ta=1073741823,Yb=1073741823,kd=null,Xb=0,jd=!1,Re=0,Ph=500,l=null,cd=!1,Se=null,La=null,ld=!1,Zb=null,$b=90,bb=null,ac=0,af=null,dd=0,Ja=function(a,b){if(50<ac)throw ac=0,af=null,Error(k(185));a=ed(a,b);if(null!==a){var c=Cc();1073741823===b?(p&Ye)!==H&&(p&(ca|ma))===H?Te(a):(V(a),p===H&&ha()):V(a);(p&4)===H||98!==c&&99!==c||(null===bb?bb=new Map([[a,b]]):(c=bb.get(a),(void 0===c||c>b)&&bb.set(a,
b)))}};var zj=function(a,b,c){var d=b.expirationTime;if(null!==a){var e=b.pendingProps;if(a.memoizedProps!==e||G.current)ia=!0;else{if(d<c){ia=!1;switch(b.tag){case 3:sh(b);Ee();break;case 5:bh(b);if(b.mode&4&&1!==c&&e.hidden)return b.expirationTime=b.childExpirationTime=1,null;break;case 1:N(b.type)&&Bc(b);break;case 4:se(b,b.stateNode.containerInfo);break;case 10:d=b.memoizedProps.value;e=b.type._context;y(Ic,e._currentValue);e._currentValue=d;break;case 13:if(null!==b.memoizedState){d=b.child.childExpirationTime;
if(0!==d&&d>=c)return th(a,b,c);y(D,D.current&1);b=sa(a,b,c);return null!==b?b.sibling:null}y(D,D.current&1);break;case 19:d=b.childExpirationTime>=c;if(0!==(a.effectTag&64)){if(d)return vh(a,b,c);b.effectTag|=64}e=b.memoizedState;null!==e&&(e.rendering=null,e.tail=null);y(D,D.current);if(!d)return null}return sa(a,b,c)}ia=!1}}else ia=!1;b.expirationTime=0;switch(b.tag){case 2:d=b.type;null!==a&&(a.alternate=null,b.alternate=null,b.effectTag|=2);a=b.pendingProps;e=pb(b,B.current);rb(b,c);e=we(null,
b,d,a,e,c);b.effectTag|=1;if("object"===typeof e&&null!==e&&"function"===typeof e.render&&void 0===e.$$typeof){b.tag=1;b.memoizedState=null;b.updateQueue=null;if(N(d)){var f=!0;Bc(b)}else f=!1;b.memoizedState=null!==e.state&&void 0!==e.state?e.state:null;ne(b);var g=d.getDerivedStateFromProps;"function"===typeof g&&Lc(b,d,g,a);e.updater=Mc;b.stateNode=e;e._reactInternalFiber=b;pe(b,d,a,c);b=Ie(null,b,d,!0,f,c)}else b.tag=0,T(null,b,e,c),b=b.child;return b;case 16:a:{e=b.elementType;null!==a&&(a.alternate=
null,b.alternate=null,b.effectTag|=2);a=b.pendingProps;ri(e);if(1!==e._status)throw e._result;e=e._result;b.type=e;f=b.tag=Gj(e);a=aa(e,a);switch(f){case 0:b=He(null,b,e,a,c);break a;case 1:b=rh(null,b,e,a,c);break a;case 11:b=nh(null,b,e,a,c);break a;case 14:b=oh(null,b,e,aa(e.type,a),d,c);break a}throw Error(k(306,e,""));}return b;case 0:return d=b.type,e=b.pendingProps,e=b.elementType===d?e:aa(d,e),He(a,b,d,e,c);case 1:return d=b.type,e=b.pendingProps,e=b.elementType===d?e:aa(d,e),rh(a,b,d,e,c);
case 3:sh(b);d=b.updateQueue;if(null===a||null===d)throw Error(k(282));d=b.pendingProps;e=b.memoizedState;e=null!==e?e.element:null;oe(a,b);Qb(b,d,null,c);d=b.memoizedState.element;if(d===e)Ee(),b=sa(a,b,c);else{if(e=b.stateNode.hydrate)Ka=kb(b.stateNode.containerInfo.firstChild),ra=b,e=Wa=!0;if(e)for(c=Fe(b,null,d,c),b.child=c;c;)c.effectTag=c.effectTag&-3|1024,c=c.sibling;else T(a,b,d,c),Ee();b=b.child}return b;case 5:return bh(b),null===a&&De(b),d=b.type,e=b.pendingProps,f=null!==a?a.memoizedProps:
null,g=e.children,Yd(d,e)?g=null:null!==f&&Yd(d,f)&&(b.effectTag|=16),qh(a,b),b.mode&4&&1!==c&&e.hidden?(b.expirationTime=b.childExpirationTime=1,b=null):(T(a,b,g,c),b=b.child),b;case 6:return null===a&&De(b),null;case 13:return th(a,b,c);case 4:return se(b,b.stateNode.containerInfo),d=b.pendingProps,null===a?b.child=wb(b,null,d,c):T(a,b,d,c),b.child;case 11:return d=b.type,e=b.pendingProps,e=b.elementType===d?e:aa(d,e),nh(a,b,d,e,c);case 7:return T(a,b,b.pendingProps,c),b.child;case 8:return T(a,
b,b.pendingProps.children,c),b.child;case 12:return T(a,b,b.pendingProps.children,c),b.child;case 10:a:{d=b.type._context;e=b.pendingProps;g=b.memoizedProps;f=e.value;var h=b.type._context;y(Ic,h._currentValue);h._currentValue=f;if(null!==g)if(h=g.value,f=Qa(h,f)?0:("function"===typeof d._calculateChangedBits?d._calculateChangedBits(h,f):1073741823)|0,0===f){if(g.children===e.children&&!G.current){b=sa(a,b,c);break a}}else for(h=b.child,null!==h&&(h.return=b);null!==h;){var m=h.dependencies;if(null!==
m){g=h.child;for(var l=m.firstContext;null!==l;){if(l.context===d&&0!==(l.observedBits&f)){1===h.tag&&(l=Ea(c,null),l.tag=Jc,Fa(h,l));h.expirationTime<c&&(h.expirationTime=c);l=h.alternate;null!==l&&l.expirationTime<c&&(l.expirationTime=c);Sg(h.return,c);m.expirationTime<c&&(m.expirationTime=c);break}l=l.next}}else g=10===h.tag?h.type===b.type?null:h.child:h.child;if(null!==g)g.return=h;else for(g=h;null!==g;){if(g===b){g=null;break}h=g.sibling;if(null!==h){h.return=g.return;g=h;break}g=g.return}h=
g}T(a,b,e.children,c);b=b.child}return b;case 9:return e=b.type,f=b.pendingProps,d=f.children,rb(b,c),e=W(e,f.unstable_observedBits),d=d(e),b.effectTag|=1,T(a,b,d,c),b.child;case 14:return e=b.type,f=aa(e,b.pendingProps),f=aa(e.type,f),oh(a,b,e,f,d,c);case 15:return ph(a,b,b.type,b.pendingProps,d,c);case 17:return d=b.type,e=b.pendingProps,e=b.elementType===d?e:aa(d,e),null!==a&&(a.alternate=null,b.alternate=null,b.effectTag|=2),b.tag=1,N(d)?(a=!0,Bc(b)):a=!1,rb(b,c),Yg(b,d,e),pe(b,d,e,c),Ie(null,
b,d,!0,a,c);case 19:return vh(a,b,c)}throw Error(k(156,b.tag));};var bf=null,Ne=null,la=function(a,b,c,d){return new Fj(a,b,c,d)};ef.prototype.render=function(a){md(a,this._internalRoot,null,null)};ef.prototype.unmount=function(){var a=this._internalRoot,b=a.containerInfo;md(null,a,null,function(){b[Lb]=null})};var Di=function(a){if(13===a.tag){var b=Fc(ka(),150,100);Ja(a,b);df(a,b)}};var Yf=function(a){13===a.tag&&(Ja(a,3),df(a,3))};var Bi=function(a){if(13===a.tag){var b=ka();b=Va(b,a,null);Ja(a,
b);df(a,b)}};sd=function(a,b,c){switch(b){case "input":Dd(a,c);b=c.name;if("radio"===c.type&&null!=b){for(c=a;c.parentNode;)c=c.parentNode;c=c.querySelectorAll("input[name="+JSON.stringify(""+b)+'][type="radio"]');for(b=0;b<c.length;b++){var d=c[b];if(d!==a&&d.form===a.form){var e=ae(d);if(!e)throw Error(k(90));Gf(d);Dd(d,e)}}}break;case "textarea":Lf(a,c);break;case "select":b=c.value,null!=b&&hb(a,!!c.multiple,b,!1)}};(function(a,b,c,d){ee=a;eg=b;vd=c;vf=d})(Qh,function(a,b,c,d,e){var f=p;p|=4;
try{return Da(98,a.bind(null,b,c,d,e))}finally{p=f,p===H&&ha()}},function(){(p&(1|ca|ma))===H&&(uj(),xb())},function(a,b){var c=p;p|=2;try{return a(b)}finally{p=c,p===H&&ha()}});var mk={Events:[Hb,Pa,ae,pf,qd,lb,function(a){Kd(a,Ki)},sf,tf,sc,pc,xb,{current:!1}]};(function(a){var b=a.findFiberByHostInstance;return Ej(M({},a,{overrideHookState:null,overrideProps:null,setSuspenseHandler:null,scheduleUpdate:null,currentDispatcherRef:da.ReactCurrentDispatcher,findHostInstanceByFiber:function(a){a=Sf(a);
return null===a?null:a.stateNode},findFiberByHostInstance:function(a){return b?b(a):null},findHostInstancesForRefresh:null,scheduleRefresh:null,scheduleRoot:null,setRefreshHandler:null,getCurrentFiber:null}))})({findFiberByHostInstance:Bb,bundleType:0,version:"16.13.1",rendererPackageName:"react-dom"});I.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED=mk;I.createPortal=Xh;I.findDOMNode=function(a){if(null==a)return null;if(1===a.nodeType)return a;var b=a._reactInternalFiber;if(void 0===
b){if("function"===typeof a.render)throw Error(k(188));throw Error(k(268,Object.keys(a)));}a=Sf(b);a=null===a?null:a.stateNode;return a};I.flushSync=function(a,b){if((p&(ca|ma))!==H)throw Error(k(187));var c=p;p|=1;try{return Da(99,a.bind(null,b))}finally{p=c,ha()}};I.hydrate=function(a,b,c){if(!bc(b))throw Error(k(200));return nd(null,a,b,!0,c)};I.render=function(a,b,c){if(!bc(b))throw Error(k(200));return nd(null,a,b,!1,c)};I.unmountComponentAtNode=function(a){if(!bc(a))throw Error(k(40));return a._reactRootContainer?
(Rh(function(){nd(null,null,a,!1,function(){a._reactRootContainer=null;a[Lb]=null})}),!0):!1};I.unstable_batchedUpdates=Qh;I.unstable_createPortal=function(a,b){return Xh(a,b,2<arguments.length&&void 0!==arguments[2]?arguments[2]:null)};I.unstable_renderSubtreeIntoContainer=function(a,b,c,d){if(!bc(c))throw Error(k(200));if(null==a||void 0===a._reactInternalFiber)throw Error(k(38));return nd(a,b,c,!1,d)};I.version="16.13.1"});
</script>
    <script>const e = React.createElement;

function pathToString(path) {
  if (path[0] === '/') {
    return '/' + path.slice(1).join('/');
  } else {
    return path.join('/');
  }
}

function findCommonPath(files) {
  if (!files || !files.length) {
    return [];
  }

  function isPrefix(arr, prefix) {
    if (arr.length < prefix.length) {
      return false;
    }
    for (let i = prefix.length - 1; i >= 0; --i) {
      if (arr[i] !== prefix[i]) {
        return false;
      }
    }
    return true;
  }

  let commonPath = files[0].path.slice(0, -1);
  while (commonPath.length) {
    if (files.every(file => isPrefix(file.path, commonPath))) {
      break;
    }
    commonPath.pop();
  }
  return commonPath;
}

function findFolders(files) {
  if (!files || !files.length) {
    return [];
  }

  let folders = files.filter(file => file.path.length > 1).map(file => file.path[0]);
  folders = [...new Set(folders)]; // unique
  folders.sort();

  folders = folders.map(folder => {
    let filesInFolder = files
      .filter(file => file.path[0] === folder)
      .map(file => ({
        ...file,
        path: file.path.slice(1),
        parent: [...file.parent, file.path[0]],
      }));

    const children = findFolders(filesInFolder); // recursion

    return {
      is_folder: true,
      path: [folder],
      parent: files[0].parent,
      children,
      covered: children.reduce((sum, file) => sum + file.covered, 0),
      coverable: children.reduce((sum, file) => sum + file.coverable, 0),
      prevRun: {
        covered: children.reduce((sum, file) => sum + file.prevRun.covered, 0),
        coverable: children.reduce((sum, file) => sum + file.prevRun.coverable, 0),
      },
    };
  });

  return [...folders, ...files.filter(file => file.path.length === 1)];
}

class App extends React.Component {
  constructor(...args) {
    super(...args);

    this.state = {
      current: [],
    };
  }

  componentDidMount() {
    this.updateStateFromLocation();
    window.addEventListener('hashchange', () => this.updateStateFromLocation(), false);
  }

  updateStateFromLocation() {
    if (window.location.hash.length > 1) {
      const current = window.location.hash.slice(1).split('/');
      this.setState({current});
    } else {
      this.setState({current: []});
    }
  }

  getCurrentPath() {
    let file = this.props.root;
    let path = [file];
    for (let p of this.state.current) {
      file = file.children.find(file => file.path[0] === p);
      if (!file) {
        return path;
      }
      path.push(file);
    }
    return path;
  }

  render() {
    const path = this.getCurrentPath();
    const file = path[path.length - 1];

    let w = null;
    if (file.is_folder) {
      w = e(FilesList, {
        folder: file,
        onSelectFile: this.selectFile.bind(this),
        onBack: path.length > 1 ? this.back.bind(this) : null,
      });
    } else {
      w = e(DisplayFile, {
        file,
        onBack: this.back.bind(this),
      });
    }

    return e('div', {className: 'app'}, w);
  }

  selectFile(file) {
    this.setState(
      ({current}) => {
        return {current: [...current, file.path[0]]};
      },
      () => this.updateHash(),
    );
  }

  back(file) {
    this.setState(
      ({current}) => {
        return {current: current.slice(0, current.length - 1)};
      },
      () => this.updateHash(),
    );
  }

  updateHash() {
    if (!this.state.current || !this.state.current.length) {
      window.location = '#';
    } else {
      window.location = '#' + this.state.current.join('/');
    }
  }
}

function FilesList({folder, onSelectFile, onBack}) {
  let files = folder.children;
  return e(
    'div',
    {className: 'display-folder'},
    e(FileHeader, {file: folder, onBack}),
    e(
      'table',
      {className: 'files-list'},
      e('thead', {className: 'files-list__head'}, e('tr', null, e('th', null, 'Path'), e('th', null, 'Coverage'))),
      e(
        'tbody',
        {className: 'files-list__body'},
        files.map(file => e(File, {file, onClick: onSelectFile})),
      ),
    ),
  );
}

function File({file, onClick}) {
  const coverage = file.coverable ? (file.covered / file.coverable) * 100 : -1;
  const coverageDelta =
    file.prevRun && (file.covered / file.coverable) * 100 - (file.prevRun.covered / file.prevRun.coverable) * 100;

  return e(
    'tr',
    {
      className:
        'files-list__file' +
        (coverage >= 0 && coverage < 50 ? ' files-list__file_low' : '') +
        (coverage >= 50 && coverage < 80 ? ' files-list__file_medium' : '') +
        (coverage >= 80 ? ' files-list__file_high' : '') +
        (file.is_folder ? ' files-list__file_folder' : ''),
      onClick: () => onClick(file),
    },
    e('td', null, e('a', null, pathToString(file.path))),
    e(
      'td',
      null,
      file.covered + ' / ' + file.coverable + (coverage >= 0 ? ' (' + coverage.toFixed(2) + '%)' : ''),
      e(
        'span',
        {title: 'Change from the previous run'},
        coverageDelta ? ` (${coverageDelta > 0 ? '+' : ''}${coverageDelta.toFixed(2)}%)` : '',
      ),
    ),
  );
}

function DisplayFile({file, onBack}) {
  return e('div', {className: 'display-file'}, e(FileHeader, {file, onBack}), e(FileContent, {file}));
}

function FileHeader({file, onBack}) {
  const coverage = (file.covered / file.coverable) * 100;
  const coverageDelta = file.prevRun && coverage - (file.prevRun.covered / file.prevRun.coverable) * 100;

  return e(
    'div',
    {className: 'file-header'},
    onBack ? e('a', {className: 'file-header__back', onClick: onBack}, 'Back') : null,
    e('div', {className: 'file-header__name'}, pathToString([...file.parent, ...file.path])),
    e(
      'div',
      {className: 'file-header__stat'},
      'Covered: ' + file.covered + ' of ' + file.coverable + (file.coverable ? ' (' + coverage.toFixed(2) + '%)' : ''),
      e(
        'span',
        {title: 'Change from the previous run'},
        coverageDelta ? ` (${coverageDelta > 0 ? '+' : ''}${coverageDelta.toFixed(2)}%)` : '',
      ),
      e('input', {id: 'theme-toggle', type: 'checkbox', hidden: true}),
      e('label', {for: 'theme-toggle', id: 'theme-toggle-label'}, '🌙'),
    ),
  );
}

function FileContent({file}) {
  return e(
    'pre',
    {className: 'file-content'},
    file.content.split(/\r?\n/).map((line, index) => {
      const trace = file.traces.find(trace => trace.line === index + 1);
      const covered = trace && trace.stats.Line;
      const uncovered = trace && !trace.stats.Line;
      const nbHit = covered? trace.stats.Line: 0;
      return e(
        'div',
        { className: 'code-text-container' },
        e(
          'code',
          {
            className: 'code-line' + (covered ? ' code-line_covered' : '') + (uncovered ? ' code-line_uncovered' : ''),
          },
          line
        ),
        e(
          'div',
          { className: 'cover-indicator' + (covered? ' check-cover': '') + (uncovered? ' no-cover': '')},
          e(
            'div',
            { className: (covered? 'stat-line-hit': '')},
            covered? nbHit: ""
          )
        )
      );
    }),
  );
}

(function () {
  const commonPath = findCommonPath(data.files);
  const prevFilesMap = new Map();

  previousData &&
    previousData.files.forEach(file => {
      const path = file.path.slice(commonPath.length).join('/');
      prevFilesMap.set(path, file);
    });

  const files = data.files.map(file => {
    const path = file.path.slice(commonPath.length);
    const {covered = 0, coverable = 0} = prevFilesMap.get(path.join('/')) || {};
    return {
      ...file,
      path,
      parent: commonPath,
      prevRun: {covered, coverable},
    };
  });

  const children = findFolders(files);

  const root = {
    is_folder: true,
    children,
    path: commonPath,
    parent: [],
    covered: children.reduce((sum, file) => sum + file.covered, 0),
    coverable: children.reduce((sum, file) => sum + file.coverable, 0),
    prevRun: {
      covered: children.reduce((sum, file) => sum + file.prevRun.covered, 0),
      coverable: children.reduce((sum, file) => sum + file.prevRun.coverable, 0),
    },
  };

  ReactDOM.render(e(App, {root, prevFilesMap}), document.getElementById('root'));

  const toggle = document.getElementById('theme-toggle');
  const label = document.getElementById('theme-toggle-label');
  label.textContent = '🌙';

  toggle.addEventListener('change', () => {
    if (toggle.checked) {
      document.documentElement.setAttribute('data-theme', 'dark');
      label.textContent = '☀️';
    } else {
      document.documentElement.removeAttribute('data-theme');
      label.textContent = '🌙';
    }
  });
})();
</script>
</body>
</html>